/**
 * Memory Pressure Detection and Adaptive Scaling System
 * 
 * Monitors system memory usage and automatically adjusts application behavior
 * to prevent out-of-memory errors and maintain optimal performance under
 * varying load conditions.
 */

import { EventEmitter } from 'events';

export interface MemoryPressureConfig {
  checkInterval?: number;           // How often to check memory (ms)
  lowMemoryThreshold?: number;     // Low memory threshold (0-1)
  highMemoryThreshold?: number;    // High memory threshold (0-1)
  criticalMemoryThreshold?: number; // Critical memory threshold (0-1)
  enableAutoScaling?: boolean;      // Enable automatic scaling adjustments
  enableGarbageCollection?: boolean; // Enable forced GC under pressure
  scalingFactor?: number;           // How aggressively to scale (0-1)
}

export interface MemoryStats {
  total: number;
  used: number;
  free: number;
  percentage: number;
  pressure: number;    // Added pressure field
  heapUsed: number;
  heapTotal: number;
  heapPercentage: number;
  external: number;
  arrayBuffers: number;
  timestamp: number;
}

export interface ScalingAction {
  type: string;
  component: string;
  action: string;
  message: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: number;
}

export interface AdaptiveScalingConfig {
  cacheSizeReduction: number;        // Reduce by 30%
  connectionPoolReduction: number;   // Reduce by 20%
  queueSizeReduction: number;        // Reduce by 40%
  requestRejectionThreshold: number; // Reject requests above 90%
  gcTriggerThreshold: number;        // Force GC above 80%
}

/**
 * Memory Pressure Monitor with Adaptive Scaling
 */
export class MemoryPressureMonitor extends EventEmitter {
  private config: Required<MemoryPressureConfig>;
  private scalingConfig: AdaptiveScalingConfig;
  private isMonitoring = false;
  private monitoringInterval?: NodeJS.Timeout;
  private currentStats: MemoryStats | null = null;
  private scalingHistory: ScalingAction[] = [];
  private lastScalingTime = 0;
  private scalingCooldown = 30000; // 30 seconds between scaling actions
  
  // Component registry for adaptive scaling
  private components = new Map<string, {
    type: 'cache' | 'connection_pool' | 'queue' | 'rate_limiter';
    getCurrentSize: () => number;
    setMaxSize: (size: number) => void;
    getCurrentLoad: () => number;
  }>;

  constructor(private options: MemoryPressureConfig = {}) {
    super();
    
    this.config = {
      checkInterval: options.checkInterval || 5000,        // 5 seconds
      lowMemoryThreshold: options.lowMemoryThreshold || 0.7,    // 70%
      highMemoryThreshold: options.highMemoryThreshold || 0.85,   // 85%
      criticalMemoryThreshold: options.criticalMemoryThreshold || 0.95, // 95%
      enableAutoScaling: options.enableAutoScaling !== false,
      enableGarbageCollection: options.enableGarbageCollection !== false,
      scalingFactor: options.scalingFactor || 0.5    // How aggressively to scale (0-1)
    };
    
    this.scalingConfig = {
      cacheSizeReduction: 0.3,        // Reduce by 30%
      connectionPoolReduction: 0.2,   // Reduce by 20%
      queueSizeReduction: 0.4,        // Reduce by 40%
      requestRejectionThreshold: 0.9, // Reject requests above 90%
      gcTriggerThreshold: 0.8        // Force GC above 80%
    };
  }

  /**
   * Start memory pressure monitoring
   */
  start(): void {
    if (this.isMonitoring) {
      return;
    } 
    
    this.isMonitoring = true;
    this.monitoringInterval = setInterval(() => {
      this.checkMemoryPressure();
    }, this.config.checkInterval);
    
    this.emit('monitoring:started');
    console.log('Memory pressure monitoring started');
  }

  /**
   * Stop memory pressure monitoring
   */
  stop(): void {
    if (!this.isMonitoring) {
      return;
    } 
    
    this.isMonitoring = false;
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = undefined;
    }
    
    this.emit('monitoring:stopped');
    console.log('Memory pressure monitoring stopped');
  }

  /**
   * Register a component for adaptive scaling
   */
  registerComponent(
    name: string,
    type: 'cache' | 'connection_pool' | 'queue' | 'rate_limiter',
    getCurrentSize: () => number,
    setMaxSize: (size: number) => void,
    getCurrentLoad: () => number = () => 0.5,
    ): void {
    this.components.set(name, {
      type,
      getCurrentSize,
      setMaxSize,
      getCurrentLoad
    });
    
    console.debug(`Registered component for adaptive scaling: ${name} (${type})`);
  }

  /**
   * Unregister a component
   */
  unregisterComponent(name: string): void {
    this.components.delete(name);
    console.debug(`Unregistered component: ${name}`);
  }

  /**
   * Get current memory statistics
   */
  getMemoryStats(): MemoryStats | null {
    return this.currentStats;
  }

  /**
   * Get scaling action history
   */
  getScalingHistory(durationMs?: number): ScalingAction[] {
    if (!durationMs) {
      return [...this.scalingHistory];
    }
    
    const cutoff = Date.now() - durationMs;
    return this.scalingHistory
      .filter(action => action.timestamp >= cutoff)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(-1000); // Last 1000 actions
  }

  /**
   * Check memory pressure and trigger adaptive scaling
   */
  private checkMemoryPressure(): void {
    try {
      const memUsage = process.memoryUsage();
      const totalMem = require('os').totalmem();
      const usedMem = totalMem - require('os').freemem();
      const percentage = usedMem / totalMem;
      
      const stats: MemoryStats = {
        total: totalMem,
        used: usedMem,
        free: require('os').freemem(),
        percentage,
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        heapPercentage: memUsage.heapUsed / memUsage.heapTotal,
        external: memUsage.external,
        arrayBuffers: memUsage.arrayBuffers,
        timestamp: Date.now()
      };
      
      this.currentStats = stats;
      this.emit('memory:stats', stats);
      
      const pressure = this.determinePressureLevel(percentage);
      
      if (this.config.enableAutoScaling) {
        this.performAdaptiveScaling(stats, pressure);
      }
    } catch (error) {
      console.error('Memory pressure check failed:', error);
      this.emit('memory:error', error);
    }
  }

  /**
   * Determine memory pressure level
   */
  private determinePressureLevel(percentage: number): 'low' | 'medium' | 'high' | 'critical' {
    if (percentage >= this.config.criticalMemoryThreshold) {
      return 'critical';
    } else if (percentage >= this.config.highMemoryThreshold) {
      return 'high';
    } else if (percentage >= this.config.lowMemoryThreshold) {
      return 'medium';
    } else {
      return 'low';
    }
  }

  /**
   * Perform adaptive scaling based on memory pressure
   */
  private async performAdaptiveScaling(stats: MemoryStats, pressure: string): Promise<void> {
    const now = Date.now();
    
    // Respect scaling cooldown to prevent oscillation
    if (now - this.lastScalingTime < this.scalingCooldown) {
      return;
    }
    
    let scalingPerformed = false;
    
    switch (pressure) {
      case 'critical':
        scalingPerformed = await this.handleCriticalMemory(stats);
        break;
      case 'high':
        scalingPerformed = await this.handleHighMemory(stats);
        break;
      case 'medium':
        scalingPerformed = await this.handleMediumMemory(stats);
        break;
      case 'low':
        scalingPerformed = await this.handleLowMemory(stats);
        break;
    }
    
    if (scalingPerformed) {
      this.lastScalingTime = now;
    }
  }

  /**
   * Handle critical memory pressure
   */
  private async handleCriticalMemory(stats: MemoryStats): Promise<boolean> {
    console.warn('CRITICAL memory pressure detected, performing emergency scaling');
    
    let actionsPerformed = 0;
    
    // Aggressive cache reduction
    actionsPerformed += await this.scaleComponents('cache', 0.5, 'critical');
    
    // Aggressive connection pool reduction
    actionsPerformed += await this.scaleComponents('connection_pool', 0.3, 'critical');
    
    // Aggressive queue reduction
    actionsPerformed += await this.scaleComponents('queue', 0.6, 'critical');
    
    // Force garbage collection
    this.forceGarbageCollection();
    
    // Emit critical alert
    this.emit('memory:critical', { stats, actionsPerformed });
    
    return actionsPerformed > 0;
  }

  /**
   * Handle high memory pressure
   */
  private async handleHighMemory(stats: MemoryStats): Promise<boolean> {
    console.warn('High memory pressure detected, performing scaling');
    
    let actionsPerformed = 0;
    
    // Moderate cache reduction
    actionsPerformed += await this.scaleComponents('cache', this.scalingConfig.cacheSizeReduction, 'high');
    
    // Moderate connection pool reduction
    actionsPerformed += await this.scaleComponents('connection_pool', this.scalingConfig.connectionPoolReduction, 'high');
    
    // Moderate queue reduction
    actionsPerformed += await this.scaleComponents('queue', this.scalingConfig.queueSizeReduction, 'high');
    
    // Emit high pressure alert
    this.emit('memory:high', { stats, actionsPerformed });
    
    return actionsPerformed > 0;
  }

  /**
   * Handle medium memory pressure
   */
  private async handleMediumMemory(stats: MemoryStats): Promise<boolean> {
    console.log('Medium memory pressure detected, performing light scaling');
    
    let actionsPerformed = 0;
    
    // Light cache reduction
    actionsPerformed += await this.scaleComponents('cache', 0.15, 'medium');
    
    // Light queue reduction
    actionsPerformed += await this.scaleComponents('queue', this.scalingConfig.queueSizeReduction, 'medium');
    
    // Emit medium pressure alert
    this.emit('memory:medium', { stats, actionsPerformed });
    
    return actionsPerformed > 0;
  }

  /**
   * Handle low memory pressure (recovery)
   */
  private async handleLowMemory(stats: MemoryStats): Promise<boolean> {
    // Gradually restore component sizes if we've been scaling down
    let actionsPerformed = 0;
    
    for (const [name, component] of this.components) {
      const currentLoad = component.getCurrentLoad();
      const currentSize = component.getCurrentSize();
      
      // Only restore if load is low and we've previously scaled down
      if (currentLoad < 0.5 && this.hasBeenScaledDown(name)) {
        const newSize = Math.min(currentSize * 1.1, currentSize * 1.5); // Restore 10-50%
        
        if (component.setMaxSize && typeof component.setMaxSize === 'function') {
          component.setMaxSize(newSize);
          this.recordScalingAction(name, 'restore', `Restored size from ${currentSize} to ${newSize}`, 'medium');
          actionsPerformed++;
        } else {
          console.warn(`Component ${name} does not support dynamic resizing, but scaling action recorded`);
          const message = `Size change recorded for ${name} from ${currentSize} to ${newSize}`, severity);
          this.recordScalingAction(name, 'size_change_attempt', `Size change recorded for ${name} from ${currentSize} to ${newSize}`, 'medium');
        }
      }
    }
    
    // Emit recovery alert if any actions were performed
    if (actionsPerformed > 0) {
      this.emit('memory:recovery', { stats, actionsPerformed });
    }
    
    return actionsPerformed > 0;
  }

  /**
   * Scale components of a specific type
   */
  private async scaleComponents(
    type: string,
    reductionFactor: number,
    severity: 'low' | 'medium' | 'high' | 'critical'
  ): Promise<number> {
    let actionsPerformed = 0;
    
    for (const [name, component] of this.components) {
      if (component.type !== type) {
        continue;
      }

      const currentSize = component.getCurrentSize();
      const newSize = Math.max(1, Math.floor(currentSize * (1 - reductionFactor)));
      
      // Check if component supports setMaxSize method
      if (component.setMaxSize && typeof component.setMaxSize === 'function') {
        component.setMaxSize(newSize);
        this.recordScalingAction(name, 'reduce', `Reduced size from ${currentSize} to ${newSize}`, severity);
        actionsPerformed++;
      } else {
        // Alternative: log the scaling action but don't fail
        console.warn(`Component ${name} does not support dynamic resizing, but scaling action recorded`);
        const message = `Size change recorded for ${name} from ${currentSize} to ${newSize}`, severity);
        this.recordScalingAction(name, 'size_change_attempt', `Size change recorded for ${name} from ${currentSize} to ${newSize}`, 'medium');
      }
    }
    }

    this.recordScalingAction('system', 'scale', `Scaled ${actionsPerformed} components of type ${type}`, severity);
    return actionsPerformed;
  }

  /**
   * Check if a component has been scaled down recently
   */
  private hasBeenScaledDown(componentName: string): boolean {
    const recentActions = this.getScalingHistory(300000); // Last 5 minutes
    return recentActions.some(action => 
      action.component === componentName && 
      action.action === 'reduce'
    );
  }

  /**
   * Force garbage collection
   */
  private forceGarbageCollection(): void {
    try {
      if (global.gc) {
        const beforeGC = process.memoryUsage();
        global.gc();
        const afterGC = process.memoryUsage();
        
        const memoryFreed = beforeGC.heapUsed - afterGC.heapUsed;
        this.recordScalingAction('system', 'force_gc', `Freed ${memoryFreed} bytes`, 'medium');
        
        console.debug(`Forced garbage collection, freed ${memoryFreed} bytes`);
        this.emit('memory:gc', { before: beforeGC, after: afterGC, freed: memoryFreed });
      }
    } catch (error) {
      console.warn('Failed to force garbage collection:', error);
    }
  }

  /**
   * Record a scaling action
   */
  private recordScalingAction(
    component: string,
    action: string,
    message: string,
    severity: 'low' | 'medium' | 'high' | 'critical',
    timestamp: number
  ): void {
    const scalingAction: ScalingAction = {
      type,
      component,
      action,
      message,
      severity,
      timestamp: Date.now()
    };
    
    this.scalingHistory.push(scalingAction);
    
    // Keep only recent history (last 1000 actions)
    if (this.scalingHistory.length > 1000) {
      this.scalingHistory = this.scalingHistory.slice(-1000);
    }
    
    this.emit('scaling:action', scalingAction);
  }

  /**
   * Get system recommendations based on current memory state
   */
  getRecommendations(): string[] {
    if (!this.currentStats) {
      return ['Memory monitoring not active'];
    }
    
    const { percentage, pressure } = this.currentStats;
    const recommendations: string[] = [];
    
    switch (pressure) {
      case 'critical':
        recommendations.push('CRITICAL: Immediate action required - consider restarting application');
        recommendations.push('Reduce all cache sizes and connection pools to minimum');
        recommendations.push('Enable request rejection to prevent overload');
        break;
      case 'high':
        recommendations.push('Reduce cache sizes by at least 30%');
        recommendations.push('Consider reducing connection pool sizes');
        recommendations.push('Monitor for potential memory leaks');
        break;
      case 'medium':
        recommendations.push('Reduce cache sizes by at least 30%');
        recommendations.push('Consider reducing connection pool sizes');
        recommendations.push('Monitor for potential memory leaks');
        break;
      case 'low':
        recommendations.push('System is operating normally');
        break;
    }
    
    return recommendations;
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = undefined;
    }
    
    this.components.clear();
    this.scalingHistory = [];
    this.currentStats = null;
    this.lastScalingTime = 0;
    
    this.emit('cleanup:complete');
    console.log('Memory pressure monitor cleanup completed');
  }

  /**
   * Create a memory pressure monitor with default configuration
   */
  export function createMemoryPressureMonitor(config?: Partial<MemoryPressureConfig>): MemoryPressureMonitor {
    return new MemoryPressureMonitor(config);
  }

  /**
   * Global memory pressure monitor instance
   */
  export const globalMemoryPressureMonitor = createMemoryPressureMonitor();
  default MemoryPressureMonitor;
}