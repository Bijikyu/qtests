Testing Modules
@codex/circuit-breaker
Purpose: Circuit breaker pattern implementation for preventing cascading failures in external service calls.

Explanation:
This module provides a robust circuit breaker implementation that protects applications from cascading failures when external services become unavailable. It implements standard circuit breaker states (CLOSED, OPEN, HALF_OPEN) with configurable failure thresholds, timeouts, and monitoring periods. The module includes factory pattern for lifecycle management, preventing memory leaks through automatic cleanup and LRU eviction. It's particularly valuable for microservices architectures and applications that depend on external APIs.

The circuit breaker wraps external operations with automatic failure detection, tracks success/failure rates, and provides detailed statistics for monitoring. It includes pre-configured breakers for common use cases and supports domain-specific configurations for different service types (LLM providers, file uploads, etc.).

/**
 * Circuit Breaker Pattern Implementation for Scalability
 * Rationale: Prevents cascading failures when external services become unavailable
 * Implements standard circuit breaker states: CLOSED, OPEN, HALF_OPEN
 */
export type CircuitState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';
export interface CircuitBreakerOptions {
  failureThreshold?: number; // Number of failures before opening circuit
  timeout?: number; // How long to stay open before trying again (ms)
  resetTimeout?: number; // How long to stay in half-open before closing (ms)
  monitoringPeriod?: number; // Window for failure counting (ms)
}
export interface CircuitBreakerStats {
  state: CircuitState;
  failures: number;
  successes: number;
  lastFailureTime?: number;
  lastSuccessTime?: number;
  totalRequests: number;
}
/**
 * Circuit Breaker class for external service protection
 * Rationale: Wraps external API calls with failure detection and automatic recovery
 */
export class CircuitBreaker {
  private state: CircuitState = 'CLOSED';
  private failures = 0;
  private successes = 0;
  private lastFailureTime?: number;
  private lastSuccessTime?: number;
  private totalRequests = 0;
  private failureWindow: number[] = []; // Timestamps of recent failures
  private readonly failureThreshold: number;
  private readonly timeout: number;
  private readonly resetTimeout: number;
  private readonly monitoringPeriod: number;
  constructor(options: CircuitBreakerOptions = {}) {
    this.failureThreshold = options.failureThreshold ?? 5;
    this.timeout = options.timeout ?? 60000; // 1 minute
    this.resetTimeout = options.resetTimeout ?? 120000; // 2 minutes
    this.monitoringPeriod = options.monitoringPeriod ?? 300000; // 5 minutes
  }
  /**
   * Executes an operation with circuit breaker protection
   * @param operation The function to execute
   * @param context Optional context for error reporting
   * @returns Promise resolving to operation result
   * @throws Error when circuit is OPEN or operation fails
   */
  async execute<T>(operation: () => Promise<T>, context?: string): Promise<T> {
    this.totalRequests++;
    // Check if circuit should trip to OPEN
    if (this.state === 'CLOSED' && this.shouldTripOpen()) {
      this.tripOpen();
    }
    // Handle OPEN state
    if (this.state === 'OPEN') {
      if (this.shouldAttemptReset()) {
        this.state = 'HALF_OPEN';
        this.failures = 0;
      } else {
        throw new Error(`Circuit breaker is OPEN for ${context || 'operation'}. Last failure: ${this.getTimeSinceLastFailure()}ms ago`);
      }
    }
    // Execute operation
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  /**
   * Records a successful operation
   */
  private onSuccess(): void {
    this.successes++;
    this.lastSuccessTime = Date.now();
    
    if (this.state === 'HALF_OPEN') {
      this.reset();
    }
  }
  /**
   * Records a failed operation
   */
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    this.failureWindow.push(Date.now());
    
    // Clean old failures outside monitoring window
    const cutoff = Date.now() - this.monitoringPeriod;
    this.failureWindow = this.failureWindow.filter(time => time > cutoff);
  }
  /**
   * Determines if circuit should trip to OPEN state
   */
  private shouldTripOpen(): boolean {
    return this.failures >= this.failureThreshold || 
           this.failureWindow.length >= this.failureThreshold;
  }
  /**
   * Determines if circuit should attempt reset
   */
  private shouldAttemptReset(): boolean {
    return this.lastFailureTime ? 
           Date.now() - this.lastFailureTime >= this.timeout : false;
  }
  /**
   * Trips circuit to OPEN state
   */
  private tripOpen(): void {
    this.state = 'OPEN';
    console.warn(`ðŸš¨ Circuit breaker TRIPPED to OPEN for operation. ${this.failures} failures detected`);
  }
  /**
   * Resets circuit to CLOSED state
   */
  private reset(): void {
    this.state = 'CLOSED';
    this.failures = 0;
    this.failureWindow = [];
    console.info(`âœ… Circuit breaker RESET to CLOSED for operation`);
  }
  /**
   * Gets time since last failure in milliseconds
   */
  private getTimeSinceLastFailure(): number {
    return this.lastFailureTime ? Date.now() - this.lastFailureTime : 0;
  }
  /**
   * Gets current circuit breaker statistics
   */
  getStats(): CircuitBreakerStats {
    return {
      state: this.state,
      failures: this.failures,
      successes: this.successes,
      lastFailureTime: this.lastFailureTime,
      lastSuccessTime: this.lastSuccessTime,
      totalRequests: this.totalRequests
    };
  }
  /**
   * Manually resets the circuit breaker
   */
  manualReset(): void {
    this.reset();
  }
  /**
   * Gets success rate as percentage
   */
  getSuccessRate(): number {
    if (this.totalRequests === 0) return 100;
    return Math.round((this.successes / this.totalRequests) * 100);
  }
}
/**
 * Factory function to create circuit breakers with common configurations
 */
export const createCircuitBreaker = (options?: CircuitBreakerOptions): CircuitBreaker => {
  return new CircuitBreaker(options);
};
// Pre-configured circuit breakers for common use cases
export const defaultCircuitBreaker = createCircuitBreaker({
  failureThreshold: 5,
  timeout: 60000,
  resetTimeout: 120000,
  monitoringPeriod: 300000
});
export const fastCircuitBreaker = createCircuitBreaker({
  failureThreshold: 3,
  timeout: 30000,
  resetTimeout: 60000,
  monitoringPeriod: 120000
});
export const slowCircuitBreaker = createCircuitBreaker({
  failureThreshold: 10,
  timeout: 120000,
  resetTimeout: 300000,
  monitoringPeriod: 600000
});

@codex/distributed-rate-limiter
Purpose: Redis-based distributed rate limiting for multi-instance deployments with graceful fallback.

Explanation:
This module provides distributed rate limiting using Redis sliding window algorithm, essential for applications running across multiple server instances. It implements graceful fallback to in-memory rate limiting when Redis is unavailable, ensuring rate limiting works even during infrastructure issues. The module includes Express middleware for drop-in replacement of express-rate-limit, comprehensive statistics, and automatic cleanup of expired counters.

The rate limiter uses sliding window algorithm for accurate rate limiting, supports custom key generators, and provides detailed rate limit headers. It's particularly valuable for API services, SaaS applications, and any system that needs consistent rate limiting across multiple instances.

/**
 * @file Distributed Rate Limiter
 * @description Redis-based distributed rate limiting for multi-instance deployments
 * 
 * Rationale: In-memory rate limiting doesn't work across multiple server instances
 * Redis provides shared state for consistent rate limiting across all instances
 * Includes sliding window algorithm, graceful degradation, and cluster support
 */
interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  skipSuccessfulRequests?: boolean;
  keyGenerator?: (req: any) => string;
}
interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetTime: number;
  retryAfter?: number;
}
/**
 * Distributed rate limiter using Redis sliding window
 * Rationale: Provides consistent rate limiting across multiple server instances
 */
class DistributedRateLimiter {
  private redis: any = null;
  private isRedisAvailable = false;
  private fallbackCounters = new Map<string, { count: number; resetTime: number }>();
  constructor(private config: RateLimitConfig) {
    this.initializeRedis();
  }
  /**
   * Initialize Redis connection with graceful fallback
   * Rationale: Provides distributed limiting when Redis is available
   */
  private async initializeRedis(): Promise<void> {
    try {
      const redisUrl = process.env.REDIS_URL || process.env.REDISCLOUD_URL;
      if (!redisUrl) {
        console.log('Redis not configured for rate limiting, using fallback');
        return;
      }
      const { createClient } = await import('redis');
      this.redis = createClient({ url: redisUrl });
      this.redis.on('error', (error: Error) => {
        console.warn('Redis rate limiter error:', error.message);
        this.isRedisAvailable = false;
      });
      this.redis.on('connect', () => {
        console.log('Redis rate limiter connected');
        this.isRedisAvailable = true;
      });
      await this.redis.connect();
    } catch (error) {
      console.warn('Redis rate limiter initialization failed:', 
        error instanceof Error ? error.message : String(error));
      this.isRedisAvailable = false;
    }
  }
  /**
   * Check if request is allowed using distributed sliding window
   * Rationale: Provides accurate rate limiting with shared state
   */
  async isAllowed(req: any): Promise<RateLimitResult> {
    const key = this.config.keyGenerator ? 
      this.config.keyGenerator(req) : 
      `rate_limit:${req.ip}:${req.path}`;
    const now = Date.now();
    const windowStart = now - this.config.windowMs;
    if (this.isRedisAvailable && this.redis) {
      return await this.checkRedisLimit(key, now, windowStart);
    } else {
      return this.checkFallbackLimit(key, now, windowStart);
    }
  }
  /**
   * Check rate limit using Redis sliding window algorithm
   * Rationale: Provides accurate distributed rate limiting
   */
  private async checkRedisLimit(key: string, now: number, windowStart: number): Promise<RateLimitResult> {
    try {
      const pipeline = this.redis.pipeline();
      
      // Remove old entries outside window
      pipeline.zRemRangeByScore(key, 0, windowStart);
      
      // Count current requests in window
      pipeline.zCard(key);
      
      // Add current request timestamp
      pipeline.zAdd(key, [{ score: now, value: `${now}-${Math.random()}` }]);
      
      // Set expiry on the sorted set
      pipeline.expire(key, Math.ceil(this.config.windowMs / 1000) + 1);
      
      const results = await pipeline.exec();
      const currentCount = results[1][1]; // zCard result
      if (currentCount >= this.config.maxRequests) {
        // Find oldest request to calculate retry after
        const oldestResult = await this.redis.zRange(key, 0, 0);
        const oldestTimestamp = parseFloat(oldestResult[0]?.split('-')[0] || '0');
        
        return {
          allowed: false,
          remaining: 0,
          resetTime: now + this.config.windowMs,
          retryAfter: Math.max(0, Math.ceil((oldestTimestamp + this.config.windowMs - now) / 1000))
        };
      }
      return {
        allowed: true,
        remaining: this.config.maxRequests - currentCount - 1,
        resetTime: now + this.config.windowMs
      };
    } catch (error) {
      console.warn('Redis rate limit check failed, using fallback:', error);
      this.isRedisAvailable = false;
      return this.checkFallbackLimit(key, now, windowStart);
    }
  }
  /**
   * Fallback in-memory rate limiting when Redis is unavailable
   * Rationale: Ensures rate limiting works even when Redis fails
   */
  private checkFallbackLimit(key: string, now: number, windowStart: number): RateLimitResult {
    const counter = this.fallbackCounters.get(key);
    
    // Reset counter if window has expired
    if (!counter || now > counter.resetTime) {
      this.fallbackCounters.set(key, {
        count: 1,
        resetTime: now + this.config.windowMs
      });
      
      return {
        allowed: true,
        remaining: this.config.maxRequests - 1,
        resetTime: now + this.config.windowMs
      };
    }
    // Check if limit exceeded
    if (counter.count >= this.config.maxRequests) {
      return {
        allowed: false,
        remaining: 0,
        resetTime: counter.resetTime,
        retryAfter: Math.max(0, Math.ceil((counter.resetTime - now) / 1000))
      };
    }
    // Increment counter
    counter.count++;
    return {
      allowed: true,
      remaining: this.config.maxRequests - counter.count,
      resetTime: counter.resetTime
    };
  }
  /**
   * Reset rate limit for specific key
   * Rationale: Provides manual reset capability for testing or admin functions
   */
  async resetKey(key: string): Promise<boolean> {
    try {
      if (this.isRedisAvailable && this.redis) {
        await this.redis.del(key);
      }
      this.fallbackCounters.delete(key);
      return true;
    } catch (error) {
      console.warn('Failed to reset rate limit key:', error);
      return false;
    }
  }
  /**
   * Get rate limit statistics
   * Rationale: Provides monitoring data for performance tuning
   */
  async getStats(): Promise<{
    isDistributed: boolean;
    fallbackCounters: number;
    redisConnected: boolean;
  }> {
    return {
      isDistributed: this.isRedisAvailable,
      fallbackCounters: this.fallbackCounters.size,
      redisConnected: this.isRedisAvailable
    };
  }
  /**
   * Clean up expired fallback counters
   * Rationale: Prevents memory leaks in fallback mode
   */
  cleanup(): void {
    const now = Date.now();
    const toDelete: string[] = [];
    
    this.fallbackCounters.forEach((counter, key) => {
      if (now > counter.resetTime) {
        toDelete.push(key);
      }
    });
    
    toDelete.forEach(key => this.fallbackCounters.delete(key));
  }
  /**
   * Graceful shutdown
   * Rationale: Ensures clean Redis connection termination
   */
  async shutdown(): Promise<void> {
    try {
      if (this.redis) {
        await this.redis.quit();
      }
    } catch (error) {
      console.warn('Redis rate limiter shutdown error:', error);
    }
    
    this.fallbackCounters.clear();
  }
}
/**
 * Factory for creating distributed rate limiters
 * Rationale: Provides consistent configuration and lifecycle management
 */
export function createDistributedRateLimiter(config: RateLimitConfig): DistributedRateLimiter {
  const limiter = new DistributedRateLimiter(config);
  
  // Start cleanup interval for fallback counters
  setInterval(() => {
    limiter.cleanup();
  }, 60000); // Cleanup every minute
  return limiter;
}
/**
 * Express middleware for distributed rate limiting
 * Rationale: Drop-in replacement for express-rate-limit with distributed support
 */
export function distributedRateLimit(config: RateLimitConfig) {
  const limiter = createDistributedRateLimiter(config);
  return async (req: any, res: any, next: any) => {
    try {
      const result = await limiter.isAllowed(req);
      // Add rate limit headers
      res.set({
        'X-RateLimit-Limit': config.maxRequests,
        'X-RateLimit-Remaining': Math.max(0, result.remaining),
        'X-RateLimit-Reset': new Date(result.resetTime).toISOString()
      });
      if (!result.allowed) {
        if (result.retryAfter) {
          res.set('Retry-After', result.retryAfter);
        }
        
        return res.status(429).json({
          error: 'Too many requests',
          message: 'Rate limit exceeded. Please try again later.',
          retryAfter: result.retryAfter
        });
      }
      next();
    } catch (error) {
      console.error('Rate limiting error:', error);
      // Fail open - allow request if rate limiting fails
      next();
    }
  };
}
// Graceful shutdown handler
const handleShutdown = async () => {
  // Clean up all active limiters if needed
  console.log('Distributed rate limiters shutting down');
};
process.on('SIGINT', handleShutdown);
process.on('SIGTERM', handleShutdown);
export { DistributedRateLimiter };

@codex/streaming-validation
Purpose: High-performance async streaming validation middleware to prevent event loop blocking.

Explanation:
This module provides streaming input validation for large payloads using chunked parallel processing and backpressure handling. It processes large strings and objects in chunks to prevent event loop blocking, implements progressive validation with configurable concurrency limits, and includes comprehensive security pattern detection. The module is particularly valuable for APIs that handle large user inputs, file uploads, or high-volume data processing.

The streaming validator uses overlapping chunks to catch patterns spanning boundaries, implements backpressure control to prevent resource exhaustion, and provides detailed validation metrics. It includes pre-configured security patterns for XSS prevention and supports custom validation rules.

/**
 * @file Streaming Input Validation Middleware
 * @description High-performance async streaming validation to prevent event loop blocking
 * 
 * Rationale: Processes large payloads using streaming and chunked parallel processing
 * Implements backpressure handling and progressive validation for maximum scalability
 */
import validator from 'validator';
export interface ValidationConfig {
  maxChunkSize: number;
  maxStringLength: number;
  maxQueryStringLength: number;
  maxConcurrentChunks: number;
  dangerousPatterns: RegExp[];
}
export interface ValidationResult {
  isValid: boolean;
  sanitized?: any;
  error?: string;
  processingTime: number;
}
/**
 * Default configuration for streaming validation
 */
const DEFAULT_CONFIG: ValidationConfig = {
  maxChunkSize: 2048, // Optimized chunk size for parallel processing
  maxStringLength: 50000, // Increased limit for marketing content
  maxQueryStringLength: 500,
  maxConcurrentChunks: 10, // Limit concurrent chunks to prevent resource exhaustion
  dangerousPatterns: [
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    /javascript:/gi,
    /on\w+\s*=/gi,
    /data:text\/html/gi,
    /<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi,
    /<object\b[^<]*(?:(?!<\/object>)<[^<]*)*<\/object>/gi,
    /<embed\b[^<]*(?:(?!<\/embed>)<[^<]*)*<\/embed>/gi,
    /vbscript:/gi,
    /<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi
  ]
};
/**
 * Streaming string validator with progressive processing
 */
class StreamingStringValidator {
  private config: ValidationConfig;
  private chunkQueue: Array<{ chunk: string; resolve: (result: string) => void; reject: (error: Error) => void }> = [];
  private processingChunks = 0;
  constructor(config: Partial<ValidationConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Validate string using streaming approach with backpressure handling
   */
  async validateString(input: string, maxLength?: number): Promise<string> {
    if (typeof input !== 'string') return '';
    
    const actualMaxLength = maxLength || this.config.maxStringLength;
    if (input.length === 0) return '';
    
    // For small strings, use direct validation
    if (input.length <= this.config.maxChunkSize) {
      return this.validateChunk(input, actualMaxLength);
    }
    // For large strings, use chunked processing with backpressure
    return this.processLargeString(input, actualMaxLength);
  }
  /**
   * Process large strings with chunked parallel processing and backpressure
   */
  private async processLargeString(input: string, maxLength: number): Promise<string> {
    const chunks = this.createChunks(input);
    const validatedChunks: string[] = [];
    
    // Process chunks with controlled concurrency
    for (let i = 0; i < chunks.length; i++) {
      // Wait for available slot if we're at max concurrency
      if (this.processingChunks >= this.config.maxConcurrentChunks) {
        await this.waitForChunkSlot();
      }
      
      // Process chunk asynchronously
      const chunkPromise = this.processChunkAsync(chunks[i], maxLength);
      validatedChunks.push(await chunkPromise);
    }
    // Combine validated chunks and apply final length limit
    const result = validatedChunks.join('');
    return result.substring(0, maxLength);
  }
  /**
   * Create optimized chunks for parallel processing
   */
  private createChunks(input: string): string[] {
    const chunks: string[] = [];
    const chunkSize = this.config.maxChunkSize;
    
    // Create overlapping chunks to catch patterns that span chunk boundaries
    for (let i = 0; i < input.length; i += chunkSize - 100) { // 100 char overlap
      const end = Math.min(i + chunkSize, input.length);
      chunks.push(input.substring(i, end));
    }
    
    return chunks;
  }
  /**
   * Process chunk asynchronously with backpressure control
   */
  private async processChunkAsync(chunk: string, maxLength: number): Promise<string> {
    this.processingChunks++;
    
    try {
      return await new Promise((resolve, reject) => {
        // Add to processing queue
        this.chunkQueue.push({
          chunk,
          resolve: (result: string) => resolve(result),
          reject: (error: Error) => reject(error)
        });
        
        // Process queue if not already processing
        this.processQueue();
      });
    } finally {
      this.processingChunks--;
    }
  }
  /**
   * Process chunk queue with controlled concurrency
   */
  private async processQueue(): Promise<void> {
    if (this.chunkQueue.length === 0) return;
    
    const item = this.chunkQueue.shift();
    if (!item) return;
    
    try {
      const result = this.validateChunk(item.chunk, item.chunk.length);
      item.resolve(result);
    } catch (error) {
      item.reject(error instanceof Error ? error : new Error(String(error)));
    }
  }
  /**
   * Wait for available processing slot
   */
  private async waitForChunkSlot(): Promise<void> {
    return new Promise(resolve => {
      const checkSlot = () => {
        if (this.processingChunks < this.config.maxConcurrentChunks) {
          resolve();
        } else {
          setImmediate(checkSlot);
        }
      };
      checkSlot();
    });
  }
  /**
   * Validate individual chunk
   */
  private validateChunk(chunk: string, maxLength: number): string {
    // Check for dangerous patterns
    for (const pattern of this.config.dangerousPatterns) {
      if (pattern.test(chunk)) {
        throw new Error(`Suspicious content detected: ${pattern.source}`);
      }
    }
    
    // Escape HTML entities and limit length
    return validator.escape(chunk.substring(0, maxLength));
  }
}
/**
 * Progressive object validator that processes properties in parallel
 */
class ProgressiveObjectValidator {
  private stringValidator: StreamingStringValidator;
  constructor(config: Partial<ValidationConfig> = {}) {
    this.stringValidator = new StreamingStringValidator(config);
  }
  /**
   * Validate object properties progressively
   */
  async validateObject(obj: any, maxDepth = 3, currentDepth = 0): Promise<any> {
    if (!obj || typeof obj !== 'object' || currentDepth >= maxDepth) {
      return obj;
    }
    const result: any = Array.isArray(obj) ? [] : {};
    const entries = Object.entries(obj);
    
    // Process properties in parallel with depth control
    const validationPromises = entries.map(async ([key, value]) => {
      if (typeof value === 'string') {
        // Use string validator for string properties
        result[key] = await this.stringValidator.validateString(value);
      } else if (typeof value === 'object' && value !== null) {
        // Recursively validate nested objects
        result[key] = await this.validateObject(value, maxDepth, currentDepth + 1);
      } else {
        // Pass through primitive values
        result[key] = value;
      }
    });
    await Promise.all(validationPromises);
    return result;
  }
}
/**
 * High-performance streaming validation middleware
 */
export function createStreamingValidationMiddleware(config: Partial<ValidationConfig> = {}) {
  const objectValidator = new ProgressiveObjectValidator(config);
  const stringValidator = new StreamingStringValidator(config);
  return async (req: any, res: any, next: any): Promise<void> => {
    // Skip validation for health check and static files
    if (req.path === '/health' || !req.path.startsWith('/api/')) {
      return next();
    }
    const startTime = Date.now();
    try {
      // Validate request body progressively
      if (req.body && typeof req.body === 'object') {
        req.body = await objectValidator.validateObject(req.body);
      }
      // Validate query parameters with shorter limits
      if (req.query && typeof req.query === 'object') {
        const queryConfig = { ...config, maxStringLength: config.maxQueryStringLength || 500 };
        const queryValidator = new StreamingStringValidator(queryConfig);
        const queryObjectValidator = new ProgressiveObjectValidator(queryConfig);
        
        req.query = await queryObjectValidator.validateObject(req.query);
      }
      // Add validation metrics to request
      req.validationMetrics = {
        processingTime: Date.now() - startTime,
        validated: true
      };
      next();
    } catch (error: unknown) {
      const processingTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      // Log validation error with metrics
      console.error('Streaming validation error:', {
        error: errorMessage,
        processingTime,
        path: req.path,
        ip: req.ip,
        userAgent: req.get('User-Agent')
      });
      res.status(400).json({ 
        error: 'Invalid input format',
        processingTime,
        details: process.env.NODE_ENV === 'development' ? (error instanceof Error ? error.message : String(error)) : undefined
      });
    }
  };
}
/**
 * Legacy compatibility wrapper
 */
export const validateAndSanitizeInput = createStreamingValidationMiddleware();
/**
 * Utility function for direct string validation
 */
export async function validateInputString(input: string, config?: Partial<ValidationConfig>): Promise<string> {
  const validator = new StreamingStringValidator(config);
  return validator.validateString(input);
}
/**
 * Utility function for direct object validation
 */
export async function validateInputObject(obj: any, config?: Partial<ValidationConfig>): Promise<any> {
  const validator = new ProgressiveObjectValidator(config);
  return validator.validateObject(obj);
}
export default {
  createStreamingValidationMiddleware,
  validateAndSanitizeInput,
  validateInputString,
  validateInputObject,
  StreamingStringValidator,
  ProgressiveObjectValidator
};

@codex/test-factory
Purpose: Factory for creating standardized integration tests with deterministic behavior.

Explanation:
This module provides a comprehensive test factory for generating standardized integration tests with deterministic behavior and parallel test safety. It includes utilities for creating unique test routes, managing fake timers, and generating consistent test responses. The factory pattern ensures test consistency across different test suites while supporting various HTTP methods and response scenarios.

The module is particularly valuable for API testing, microservices integration testing, and any scenario requiring reproducible test conditions. It includes built-in support for success testing, not found scenarios, and custom response handling.

// ðŸ”— Tests: Test factory for generated integration tests
// ðŸš©AI: MUST_UPDATE_IF_GENERATED_TEST_PATTERNS_CHANGE
import { createMockApp, supertest } from '../testBootstrap.js';
import { setupApiTest } from './testUtilities.js';
export interface GeneratedTestConfig {
  route: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  testDate?: string;
  successData?: any;
  errorData?: any;
}
export interface GeneratedTestResult {
  app: ReturnType<typeof createMockApp>;
  uniqueRoute: string;
  testHash: string;
  successResponse: any;
  errorResponse: any;
}
/**
 * Factory function to create standardized generated tests
 */
export function createGeneratedTest(config: GeneratedTestConfig) {
  const { route, method, testDate, successData, errorData } = config;
  const { uniqueRoute, testHash, successResponse, errorResponse } = setupApiTest(route, testDate);
  
  let app: ReturnType<typeof createMockApp>;
  beforeEach(() => {
    app = createMockApp();
  });
  const setupSuccessHandler = (customResponse?: any) => {
    const response = customResponse || successResponse;
    
    const handler = (req: any, res: any) => {
      res.statusCode = 200;
      res.setHeader('content-type', 'application/json');
      res.end(JSON.stringify(response));
    };
    switch (method) {
      case 'GET':
        app.get(uniqueRoute, handler);
        break;
      case 'POST':
        app.post(uniqueRoute, handler);
        break;
      case 'PUT':
        app.put(uniqueRoute, handler);
        break;
      case 'DELETE':
        app.delete(uniqueRoute, handler);
        break;
    }
  };
  const executeSuccessTest = async (requestData?: any) => {
    setupSuccessHandler(successData);
    
    let request = supertest(app).get(uniqueRoute);
    
    switch (method) {
      case 'POST':
        request = supertest(app).post(uniqueRoute).send(requestData || {});
        break;
      case 'PUT':
        request = supertest(app).put(uniqueRoute).send(requestData || {});
        break;
      case 'DELETE':
        request = supertest(app).delete(uniqueRoute);
        break;
      default:
        request = supertest(app).get(uniqueRoute);
    }
    
    const res = await request.expect(200);
    return res;
  };
  const executeNotFoundTest = async (requestData?: any) => {
    let request = supertest(app).get('/nonexistent-route');
    
    switch (method) {
      case 'POST':
        request = supertest(app).post('/nonexistent-route').send(requestData || {});
        break;
      case 'PUT':
        request = supertest(app).put('/nonexistent-route').send(requestData || {});
        break;
      case 'DELETE':
        request = supertest(app).delete('/nonexistent-route');
        break;
      default:
        request = supertest(app).get('/nonexistent-route');
    }
    
    const res = await request.expect(404);
    return res;
  };
  return {
    app,
    uniqueRoute,
    testHash,
    successResponse,
    errorResponse,
    setupSuccessHandler,
    executeSuccessTest,
    executeNotFoundTest
  };
}
/**
 * Standard test suite for generated tests
 */
export function createGeneratedTestSuite(config: GeneratedTestConfig) {
  const testFactory = createGeneratedTest(config);
  const { method, route } = config;
  
  return {
    describe: `${method} ${route}`,
    successTest: async (customData?: any) => {
      const res = await testFactory.executeSuccessTest(customData);
      expect(res.body.success).toBe(true);
      expect(res.body.message).toBe('Request processed successfully');
    },
    notFoundTest: async (requestData?: any) => {
      const res = await testFactory.executeNotFoundTest(requestData);
      expect(res.body.error).toBe('Not Found');
    }
  };
}

@codex/test-utilities
Purpose: Shared test utilities for common Jest patterns and deterministic testing.

Explanation:
This module provides essential test utilities for creating deterministic test conditions, managing fake timers, and generating unique test identifiers. It includes functions for setting up consistent timing, creating unique routes for parallel test execution, and generating standard test response structures. The utilities ensure test reproducibility and prevent test interference in parallel execution environments.

The module is particularly valuable for Jest-based testing suites, API integration testing, and any scenario requiring consistent test conditions across multiple test runs.

// ðŸ”— Tests: Shared test utilities for common Jest patterns
// ðŸš©AI: MUST_UPDATE_IF_JEST_SETUP_PATTERNS_CHANGE
import { jest } from '@jest/globals';
/**
 * Sets up deterministic fake timers for consistent test behavior
 */
export function setupFakeTimers(date: string = '2023-01-01T00:00:00Z'): void {
  jest.useFakeTimers().setSystemTime(new Date(date));
}
/**
 * Cleans up fake timers after tests
 */
export function cleanupFakeTimers(): void {
  jest.useRealTimers();
}
/**
 * Common beforeEach/afterEach setup for deterministic timing
 */
export function deterministicTimerSetup(date?: string): void {
  beforeEach(() => setupFakeTimers(date));
  afterEach(() => cleanupFakeTimers);
}
/**
 * Creates a mock axios instance with common setup
 * Note: Using qtests createMockAxios instead of custom implementation
 */
export function createMockedAxios() {
  // Import from qtests utilities for comprehensive axios mocking
  const { createMockAxios } = require('qtests/utils/mockAxios');
  const mockAxios = createMockAxios();
  return { axios: mockAxios, mockedAxios: mockAxios };
}
/**
 * Creates a unique test hash for parallel test safety
 */
export function createTestHash(route: string): string {
  const crypto = require('crypto');
  return crypto.createHash('md5').update(route).digest('hex').slice(0, 8);
}
/**
 * Creates a unique route for parallel test execution
 */
export function createUniqueRoute(route: string): string {
  const testHash = createTestHash(route);
  const separator = route.includes('?') ? '&' : '?';
  return `${route}${separator}testId=${testHash}`;
}
/**
 * Common test response structure for API tests
 */
export const createSuccessResponse = (data: any = {}) => ({
  success: true,
  message: 'Request processed successfully',
  ...data
});
/**
 * Common test response structure for API tests
 */
export const createErrorResponse = (error: string = 'Not Found') => ({
  error
});
/**
 * Standard test setup for API integration tests
 */
export function setupApiTest(route: string, date?: string) {
  deterministicTimerSetup(date);
  const uniqueRoute = createUniqueRoute(route);
  
  return {
    uniqueRoute,
    testHash: createTestHash(route),
    successResponse: createSuccessResponse(),
    errorResponse: createErrorResponse()
  };
}