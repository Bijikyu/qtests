// ðŸ”— Enhanced Test Isolation Framework
// Prevents cross-test contamination with comprehensive resource management and memory tracking

import { EventEmitter } from "events";

export interface IsolationCleanup {
  (): Promise<void>;
}

export interface ResourceTracker {
  type: string;
  id: string;
  cleanup: IsolationCleanup;
  createdAt: number;
}

export interface TestMetrics {
  testName: string;
  startTime: number;
  memoryBefore: NodeJS.MemoryUsage;
  resourcesAllocated: number;
  resourcesCleaned: number;
  errors: string[];
  endTime?: number;
  memoryAfter?: NodeJS.MemoryUsage;
}

export class TestIsolationManager extends EventEmitter {
  private cleanupTasks: IsolationCleanup[] = [];
  private allocatedResources: Map<string, ResourceTracker> = new Map();
  private currentTest: TestMetrics | null = null;
  private testHistory: TestMetrics[] = [];
  private maxHistoryLength = 20;

  constructor() {
    super();
  }

  // Add cleanup task with timeout protection
  addCleanupTask(cleanup: IsolationCleanup): void {
    this.cleanupTasks.push(cleanup);
  }

  // Track allocated resources
  trackResource(type: string, id: string, cleanup: IsolationCleanup): void {
    const tracker: ResourceTracker = {
      type,
      id,
      cleanup,
      createdAt: Date.now(),
    };
    this.allocatedResources.set(`${type}:${id}`, tracker);

    if (this.currentTest) {
      this.currentTest.resourcesAllocated++;
    }
  }

  // Start memory tracking for a test
  startMemoryTracking(testName?: string): void {
    const memoryBefore = process.memoryUsage();
    this.currentTest = {
      testName: testName || "test",
      startTime: Date.now(),
      memoryBefore,
      resourcesAllocated: 0,
      resourcesCleaned: 0,
      errors: [],
    };
  }

  // Memory measurement with logging
  measure(label: string): NodeJS.MemoryUsage {
    const usage = process.memoryUsage();
    const heapUsedMB = usage.heapUsed / 1024 / 1024;
    console.log(`ðŸ“Š Memory [${label}]: ${heapUsedMB.toFixed(2)}MB`);
    return usage;
  }

  /**
   * Run all cleanup tasks with enhanced error handling and timeout protection
   */
  async runCleanup(): Promise<void> {
    const errors: string[] = [];
    let cleanedCount = 0;
    const timeoutMs = process.env.NODE_ENV === "test" ? 1000 : 5000;
    const timeoutHandles: NodeJS.Timeout[] = [];

    try {
      const cleanupPromises = this.cleanupTasks.map(async (cleanup, index) => {
        const startTime = Date.now();
        let timeoutHandle: NodeJS.Timeout | null = null;

        try {
          const cleanupPromise = cleanup();
          const timeoutPromise = new Promise<never>((_, reject) => {
            timeoutHandle = setTimeout(() => {
              reject(
                new Error(`Cleanup ${index} timeout after ${timeoutMs}ms`),
              );
            }, timeoutMs);
          });

          if (timeoutHandle) {
            timeoutHandles.push(timeoutHandle);
          }

          await Promise.race([cleanupPromise, timeoutPromise]);

          cleanedCount++;
          return { success: true, duration: Date.now() - startTime };
        } catch (error) {
          const errorMsg = `Cleanup task ${index} failed: ${error}`;
          errors.push(errorMsg);
          console.warn(errorMsg);
          return { success: false, error, duration: Date.now() - startTime };
        }
      });

      await Promise.allSettled(cleanupPromises);

      // Clear all timeout handles
      timeoutHandles.forEach((handle) => {
        if (handle) {
          clearTimeout(handle);
        }
      });
    } catch (error) {
      // Ensure timeout handles are cleared even if Promise.allSettled fails
      timeoutHandles.forEach((handle) => {
        if (handle) {
          clearTimeout(handle);
        }
      });
      throw error;
    } finally {
      // Always clear cleanup tasks and resources
      this.cleanupTasks = [];
      this.allocatedResources.clear();

      // Update current test metrics
      if (this.currentTest) {
        this.currentTest.resourcesCleaned = cleanedCount;
        this.currentTest.errors.push(...errors);
      }

      // Force garbage collection if available
      if (global.gc) {
        try {
          global.gc();
        } catch (error) {
          console.warn("Failed to force garbage collection:", error);
        }
      }

      // Emit cleanup completion event
      this.emit("cleanup-completed", {
        cleanedCount,
        errorCount: errors.length,
        errors,
      });

      if (errors.length > 0) {
        this.emit("cleanup-errors", errors);
      }

      // Log cleanup completion
      if (errors.length > 0) {
        console.warn(`Cleanup completed with ${errors.length} errors`);
      } else {
        console.log("âœ… All cleanup tasks completed successfully");
      }
    }
  }

  // End memory tracking for a test
  endMemoryTracking(): TestMetrics {
    if (!this.currentTest) {
      throw new Error("No active test to end");
    }

    const memoryAfter = process.memoryUsage();
    const duration = Date.now() - this.currentTest.startTime;

    this.currentTest.endTime = Date.now();
    this.currentTest.memoryAfter = memoryAfter;

    // Log performance warnings
    if (duration > 30000) {
      console.warn(
        `âš  Slow test detected: ${this.currentTest.testName} (${duration}ms)`,
      );
    }

    const memoryGrowthMB =
      (memoryAfter.heapUsed - this.currentTest.memoryBefore.heapUsed) /
      1024 /
      1024;
    if (memoryGrowthMB > 50) {
      console.warn(
        `âš  High memory growth in test: ${this.currentTest.testName} (+${memoryGrowthMB.toFixed(2)}MB)`,
      );
    }

    // Log test completion
    console.log(
      `âœ… Test completed: ${this.currentTest.testName} (${duration}ms, ${this.currentTest.resourcesAllocated} resources)`,
    );

    return this.currentTest;
  }

  // Get current test metrics
  getCurrentTest(): TestMetrics | null {
    return this.currentTest;
  }

  // Get test history
  getTestHistory(): TestMetrics[] {
    return [...this.testHistory];
  }

  // Clear test history
  clearHistory(): void {
    this.testHistory = [];
  }
}

// Global instance for test isolation
export const testIsolation = new TestIsolationManager();

// Global memory tracker for performance monitoring
export const memoryTracker = {
  startTracking(): void {
    console.log("ðŸ§  Memory tracking started");
  },
  measure(label: string): NodeJS.MemoryUsage {
    const usage = process.memoryUsage();
    const heapUsedMB = usage.heapUsed / 1024 / 1024;
    console.log(`ðŸ“Š Memory [${label}]: ${heapUsedMB.toFixed(2)}MB`);
    return usage;
  },
};

// Session cleanup utility
export class SessionCleaner {
  constructor(private sessionStore: any) {}

  async cleanupSessions(sessionIds: string[]): Promise<void> {
    const cleanupPromises = Array.from(this.sessionStore.sessions).map(
      (sessionId) =>
        this.sessionStore
          .delete(sessionId)
          .catch((err: unknown) =>
            console.warn(`Failed to cleanup session ${sessionId}:`, err),
          ),
    );

    await Promise.allSettled(cleanupPromises);
    console.log("âœ… All sessions cleaned up");
  }
}