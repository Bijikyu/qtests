codex
You’re right — patching individual generated tests in-app is
pointless if you’ll overwrite them with --force. The right fix
is inside qtests. Here’s exactly what I recommend changing in
your qtests module so regeneration produces stable React/Hook
tests and avoids the “.tsx unknown”, “invalid hook call”, and
placeholder assertion failures.

Recommended changes in qtests (module you own)

- Test file extension selection:
    - Logic: If source is .tsx or generated test uses JSX,
write .GenerateTest.test.tsx; otherwise .ts.
    - Or simpler: never emit JSX in generated tests; use
React.createElement so they can remain .ts.
    - Or simpler: never emit JSX in generated tests; use
React.createElement so they can remain .ts.
- 
Component templates:
    - Import React and RTL: import * as React from 'react';
import { render } from '@testing-library/react';
    - Smoke test per export:
    - Resolve component as `const Comp = (testModule as
any).default ?? (testModule as any)['ExportName']`
    - `render(React.createElement(Comp as any, {}))` and
assert container exists.
- Heuristic provider wrappers (optional but useful):
    - If the source imports `@tanstack/react-query`, wrap with
`QueryClientProvider`.
    - Similar for router libs if you want higher resilience.
- 
Avoid calling components as plain functions.
- 
Hook templates:
    - Don’t call hooks directly. Generate a probe:
    - `function HookProbe(){ const v = (testModule as
any)['useThing'](); return React.createElement('div',
{'data-testid':'hook-result'}, String(!!v)); }`
    - `render(React.createElement(HookProbe))` and assert the
element exists.
- 
Use React.createElement so the file can be .ts safely (no JSX
parsing issues).
- 
Function templates (non-React):
    - Default to existence tests or a safe zero-arg call if
it’s callable with no params.
    - Remove table-driven placeholders comparing to "expected
output"; they create constant failures by design.
- 
Import form in generated tests:
    - Prefer not appending the extension: import * as
testModule from './Component' to keep ts-jest resolution happy
across environments.
- 
Jest scaffolding heuristic (only when qtests scaffolds
config):
    - If you detect React (dependency or scanned sources),
set:
    - `testEnvironment: 'jsdom'`
    - `extensionsToTreatAsEsm: ['.ts', '.tsx']`
    - `moduleFileExtensions` includes `tsx`
    - `transform` for `^.+\\.tsx?$` via ts-jest with
`tsconfig: { jsx: 'react-jsx' }`
- 
Keep current Node-only scaffold for pure server repos.
- 
qtests jest-setup improvements:
    - Add DOM polyfills commonly needed by UI/hook tests:
    - `window.matchMedia` mock
    - `ResizeObserver` mock
- 
Keep importing qtests/setup first.
- 
Export detection:
    - Your current heuristics are fine; continue classifying
hooks as names starting with use and treat all else as
components/functions. If AST mode is on, keep augmenting.
- 
CLI enhancement (optional):
    - Add --react flag to force React-aware templates even if
heuristics are inconclusive.
    - Document that --force overwrites only .GenerateTest.*
files as you already do.

Why these changes

- Prevents invalid hook calls by never calling hooks directly.
- Prevents JSX parse errors in .ts by either using .tsx or
avoiding JSX entirely.
- Prevents “expected output” placeholders from causing red
tests.
- Makes component tests resilient and minimal, while still
exercising the render path.
- Aligns Jest scaffold to projects that use React without
breaking Node-only consumers.

If you want, I can draft a focused PR against your qtests
repo with:

- getRelativeTestPath: choose .tsx when needed or generate
JSX-free tests
- createUnitTest: React/component/hook-specific templates
using React.createElement and RTL
- jest-setup.ts: add matchMedia/ResizeObserver mocks
- scaffoldJestSetup: jsdom + tsx transform when React detected

Once that’s merged, you can regen with --force and drop any
hand-edited tests.