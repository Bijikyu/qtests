/**
 * Robust Test Helper with Error Handling and Timeouts
 * Provides common utilities for test stability and reliability
 */

const axios = require('axios');

// Import qtests utilities - CommonJS compatibility layer
let mockConsole;
try {
  const qtestsModule = require('qtests');
  mockConsole = qtestsModule.mockConsole;
} catch (e) {
  // Fallback to basic console functionality
  mockConsole = (method) => ({
    mock: { calls: [] },
    mockRestore: () => {}
  });
}

// Enhanced axios instance with better error handling
const testAxios = axios.create({
  timeout: 10000,
  maxRedirects: 0,
  validateStatus: (status) => status < 500 // Don't throw on 4xx errors
});

// Request interceptor for better error tracking
testAxios.interceptors.request.use((config) => {
  config.metadata = { startTime: Date.now() };
  return config;
}, (error) => {
  return Promise.reject(error);
});

// Response interceptor for timing and error handling
testAxios.interceptors.response.use((response) => {
  if (response.config.metadata) {
    response.config.metadata.endTime = Date.now();
    response.duration = response.config.metadata.endTime - response.config.metadata.startTime;
    // Clean up to prevent memory leaks
    response.config.metadata = null;
  }
  return response;
}, (error) => {
  if (error.config && error.config.metadata) {
    error.config.metadata.endTime = Date.now();
    error.duration = error.config.metadata.endTime - error.config.metadata.startTime;
    // Clean up to prevent memory leaks
    error.config.metadata = null;
  }
  return Promise.reject(error);
});

/**
 * Wrapper for HTTP requests with retry logic and better error handling
 */
async function makeRequest(method, url, data = null, options = {}) {
  const {
    retries = 3,
    retryDelay = 1000,
    expectedStatus = [200, 201],
    timeout = 10000
  } = options;

  let lastError;
  
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const config = {
        ...options,
        method,
        url,
        timeout
      };
      
      if (data) {
        config.data = data;
      }
      
      const response = await testAxios(config);
      
      // Check if status is expected
      if (!expectedStatus.includes(response.status)) {
        throw new Error(`Unexpected status ${response.status}. Expected: ${expectedStatus.join(', ')}`);
      }
      
      return response;
      
    } catch (error) {
      lastError = error;
      
      // Don't retry on client errors (4xx) except for 429 (rate limit)
      if (error.response && error.response.status >= 400 && error.response.status < 500 && error.response.status !== 429) {
        throw error;
      }
      
      // Don't retry on timeout
      if (error.code === 'ECONNABORTED') {
        throw new Error(`Request timeout after ${timeout}ms`);
      }
      
      if (attempt < retries) {
        console.log(`⚠️  Request attempt ${attempt} failed, retrying in ${retryDelay}ms...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
  }
  
  // Enhance error with more context
  if (lastError.response) {
    const enhancedError = new Error(`HTTP ${lastError.response.status}: ${lastError.response.data?.error || lastError.message}`);
    enhancedError.status = lastError.response.status;
    enhancedError.data = lastError.response.data;
    enhancedError.config = lastError.config;
    throw enhancedError;
  }
  
  throw lastError;
}

/**
 * Wait for server to be ready with timeout
 */
async function waitForServer(baseUrl, timeout = 15000) {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      await makeRequest('GET', `${baseUrl}/api/health`, null, { 
        timeout: 3000,
        retries: 1,
        expectedStatus: [200]
      });
      return true;
    } catch (error) {
      // Server not ready yet, wait and retry
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }
  
  throw new Error(`Server not ready after ${timeout}ms`);
}

/**
 * Clean up test data with error handling
 */
async function cleanupTestData() {
  // BUG FIX: Don't create spies unnecessarily - they're not being used
  try {
    // Reset global test data
    if (global.testData) {
      global.testData.rules = [];
      global.testData.templates = [];
      global.testData.users = [];
      global.testData._counters = { user: 1, rule: 1, template: 1, snooze: 1 };
    }
    
    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }
  } catch (error) {
    console.warn('⚠️  Error during test cleanup:', error.message);
  }
}

/**
 * Create test data with validation
 */
function createTestData(type, data) {
  try {
    switch (type) {
      case 'rule':
        return createRuleData(data);
      case 'template':
        return createTemplateData(data);
      case 'user':
        return createUserData(data);
      default:
        throw new Error(`Unknown test data type: ${type}`);
    }
  } catch (error) {
    throw new Error(`Failed to create ${type} test data: ${error.message}`);
  }
}

/**
 * Create valid rule test data
 */
function createRuleData(overrides = {}) {
  const defaultRule = {
    name: `Test Rule ${Date.now()}`,
    provider: 'gmail',
    isActive: true,
    conditions: {
      sender: 'test@example.com',
      subject: 'Test Subject'
    },
    actions: {
      moveTo: 'inbox',
      markAs: 'read'
    }
  };
  
  return { ...defaultRule, ...overrides };
}

/**
 * Create valid template test data
 */
function createTemplateData(overrides = {}) {
  const defaultTemplate = {
    name: `Test Template ${Date.now()}`,
    subject: 'Test Subject',
    body: 'This is a test template with {{variable}}',
    category: 'business',
    provider: 'gmail',
    isActive: true,
    variables: [
      { name: 'variable', type: 'string', required: true, defaultValue: 'value' }
    ]
  };
  
  return { ...defaultTemplate, ...overrides };
}

/**
 * Create valid user test data
 */
function createUserData(overrides = {}) {
  const defaultUser = {
    name: `Test User ${Date.now()}`,
    email: `test${Date.now()}@example.com`,
    role: 'user'
  };
  
  return { ...defaultUser, ...overrides };
}

/**
 * Assert with better error messages
 */
function assert(condition, message) {
  if (!condition) {
    throw new Error(`Assertion failed: ${message}`);
  }
}

/**
 * Test helper for API responses
 */
function expectApiResponse(response, expectedStatus = 200) {
  assert(response, 'Response should not be null');
  assert(response.status === expectedStatus, `Expected status ${expectedStatus}, got ${response.status}`);
  assert(response.data, 'Response should have data');
  
  return {
    toHaveProperty: (prop) => {
      assert(response.data.hasOwnProperty(prop), `Response should have property: ${prop}`);
      return response.data[prop];
    },
    
    toMatchSchema: (schema) => {
      // Basic schema validation
      Object.keys(schema).forEach(key => {
        if (schema[key].required && !response.data.hasOwnProperty(key)) {
          throw new Error(`Response missing required property: ${key}`);
        }
      });
      return true;
    }
  };
}

module.exports = {
  makeRequest,
  waitForServer,
  cleanupTestData,
  createTestData,
  createRuleData,
  createTemplateData,
  createUserData,
  assert,
  expectApiResponse,
  testAxios
};