#!/usr/bin/env node
// IMPORTANT: This CLI is sacrosanct and not generated. Do not overwrite.
// Provides batching, summaries, and debug report creation for failing tests.

// qtests Test Runner - Feature-rich CLI with batching, summaries, and debug file
// Restores original functionality while ensuring Jest is launched with project config

import fs from 'fs';
import path from 'path';
import { spawn } from 'child_process';
import os from 'os';
import qerrors from '../dist/lib/qerrorsFallback.js';

// ANSI color codes for terminal output
const colors = {
  green: '\u001b[32m',
  red: '\u001b[31m',
  yellow: '\u001b[33m',
  blue: '\u001b[34m',
  magenta: '\u001b[35m',
  cyan: '\u001b[36m',
  white: '\u001b[37m',
  reset: '\u001b[0m',
  bold: '\u001b[1m',
  dim: '\u001b[2m'
};

// Test discovery patterns - optimized for single regex compilation
const TEST_PATTERNS = [
  /\.test\.(js|ts|jsx|tsx)$/,
  /\.spec\.(js|ts|jsx|tsx)$/,
  /_test\.(js|ts|jsx|tsx)$/,
  /_spec\.(js|ts|jsx|tsx)$/
];

// Combined regex for faster pattern matching - FIXED: properly matches original patterns
const COMBINED_TEST_PATTERN = /\.(test|spec)\.(js|ts|jsx|tsx)$|(_test|_spec)\.(js|ts|jsx|tsx)$/;

// Cache for discovered tests to avoid repeated filesystem operations - FIXED: bounded cache with TTL
const testDiscoveryCache = new Map();
const CACHE_TTL = 30000; // 30 seconds cache TTL
const MAX_CACHE_SIZE = 1000; // Prevent memory leaks

class TestRunner {
  constructor() {
    this.passedTests = 0;
    this.failedTests = 0;
    this.testResults = [];
    this.startTime = Date.now();
    this.configCache = null; // Cache for config discovery
  }

  // Discover all test files in the project (from current working directory) - OPTIMIZED VERSION
  async discoverTests(dir = process.cwd(), depth = 0, maxDepth = 10, visited = new Set()) {
    // Check cache first with TTL validation - FIXED: prevent stale cache and handle old format
    const cacheKey = `${dir}:${depth}:${maxDepth}`;
    const cached = testDiscoveryCache.get(cacheKey);
    if (cached) {
// Handle both old format (array) and new format (object with timestamp) - FIXED: remove stale cache entries
if (cached) {
        if (Array.isArray(cached)) {
          // Old cache format - assume it's stale and remove it
          testDiscoveryCache.delete(cacheKey);
        } else {
          // New cache format with timestamp
          if ((Date.now() - cached.timestamp) < CACHE_TTL) {
            return cached.files;
          } else {
            // Cache entry expired - remove it
            testDiscoveryCache.delete(cacheKey);
          }
        }
      }
      
      // Clean up old cache entries to prevent memory leaks - FIXED: move cleanup outside cache logic
      if (testDiscoveryCache.size > MAX_CACHE_SIZE) {
        // Remove 25% of entries when over limit to maintain reasonable size
        const entriesToRemove = Math.floor(testDiscoveryCache.size * 0.25);
        const keysToRemove = Array.from(testDiscoveryCache.keys()).slice(0, entriesToRemove);
        keysToRemove.forEach(key => testDiscoveryCache.delete(key));
      }
        }
      }
      }
    }

    const testFiles = [];
    if (depth > maxDepth) return testFiles;
    
    // Cycle detection - prevent infinite recursion
    let realPath;
    try {
      realPath = await fs.promises.realpath(dir);
    } catch (error) {
      qerrors(error as Error, 'testRunner.discoverTests: realpath failed', {
        directory: dir,
        depth,
        errorType: error.constructor.name,
        errorMessage: error instanceof Error ? error.message : String(error)
      });
      return testFiles;
    }
    
    if (visited.has(realPath)) {
      qerrors(new Error('Directory cycle detected'), 'testRunner.discoverTests: cycle prevention', {
        directory: dir,
        realPath,
        depth,
        visitedCount: visited.size
      });
      return testFiles;
    }
    visited.add(realPath);
    
    try {
      const entries = await fs.promises.readdir(dir, { withFileTypes: true });
      // Pre-allocate array for better performance
      const pendingDirs = [];
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        // Skip node_modules, hidden directories, and demo directory - optimized checks
        if (entry.name.startsWith('.') || entry.name === 'node_modules' || entry.name === 'demo') {
          continue;
        }
        if (entry.isDirectory()) {
          pendingDirs.push(fullPath);
        } else if (entry.isFile()) {
          // Use combined regex for faster pattern matching
          const isTestFile = COMBINED_TEST_PATTERN.test(entry.name);
          if (!isTestFile) continue;
          // Skip tests in __mocks__ and other ignored folders - optimized path check
          const pathSep = path.sep;
          if (fullPath.includes(`${pathSep}__mocks__${pathSep}`)) continue;
          // In generated-tests, only include files that follow the GeneratedTest naming convention
          if (fullPath.includes(`${pathSep}generated-tests${pathSep}`) && !/GeneratedTest/.test(entry.name)) {
            continue;
          }
          testFiles.push(fullPath);
        }
      }
      
      // Process directories in parallel for better performance - FIXED: separate visited sets
      if (pendingDirs.length > 0) {
        const dirResults = await Promise.all(
          pendingDirs.map(fullPath => {
            // Create separate visited set for each parallel branch to avoid race conditions
            const branchVisited = new Set(visited);
            return this.discoverTests(fullPath, depth + 1, maxDepth, branchVisited);
          })
        );
        testFiles.push(...dirResults.flat());
      }
    } catch (error) {
      qerrors(error as Error, 'testRunner.discoverTests: directory read failed', {
        directory: dir,
        depth,
        errorType: error.constructor.name,
        errorMessage: error instanceof Error ? error.message : String(error)
      });
      // Silently skip directories we can't read
    } finally {
      // Clean up visited set for this branch
      visited.delete(realPath);
    }
    
    // Optional pattern filter via env to limit scope for large repos/CI - FIXED: add validation
    const pattern = process.env.QTESTS_PATTERN;
    if (pattern) {
      try {
        const rx = new RegExp(pattern);
        const filteredFiles = testFiles.filter(f => rx.test(f));
        // Cache the result with timestamp
        testDiscoveryCache.set(cacheKey, { files: filteredFiles, timestamp: Date.now() });
        return filteredFiles;
      } catch (error) {
        qerrors(error as Error, 'testRunner.discoverTests: pattern compilation failed', {
          pattern,
          testFilesCount: testFiles.length,
          errorType: error.constructor.name,
          errorMessage: error instanceof Error ? error.message : String(error)
        });
        // Cache the unfiltered result with timestamp on invalid pattern
        testDiscoveryCache.set(cacheKey, { files: testFiles, timestamp: Date.now() });
        return testFiles; // invalid pattern, ignore
      }
    }
    
    // Cache the result with timestamp
    testDiscoveryCache.set(cacheKey, { files: testFiles, timestamp: Date.now() });
    return testFiles;
  }

// Run a single test file via Jest and capture output - OPTIMIZED VERSION
  async runTestFile(testFile) {
    const spawnOnce = async () => {
      const startTime = Date.now();
      let stdout = '';
      let stderr = '';

      try {
        // Use cached config discovery to avoid repeated filesystem checks
        let cfg = this.configCache;
        if (cfg === null) {
          // First time discovery - cache the result
          const configCandidates = [
            path.join(process.cwd(), 'config', 'jest.config.mjs'),
            path.join(process.cwd(), 'jest.config.mjs')
          ];
          try {
            for (const candidate of configCandidates) {
              try {
                if (await fs.promises.access(candidate).then(() => true).catch(() => false)) {
                  cfg = candidate;
                  this.configCache = cfg;
                  break;
                }
              } catch { continue; }
            }
            // Cache null result if no config found
            if (cfg === undefined) {
              this.configCache = null;
            }
          } catch (error) {
            qerrors(error as Error, 'testRunner.runTestFile: config discovery failed', {
              testFile,
              configCandidates,
              errorType: error.constructor.name,
              errorMessage: error instanceof Error ? error.message : String(error)
            });
            this.configCache = null;
          }
        }
        
        const jestArgs = [];
        if (cfg) {
          jestArgs.push('--config', cfg);
        }
        jestArgs.push('--passWithNoTests');
        // Per-file execution tuning: allow in-band or worker override via env
        const fileWorkers = process.env.QTESTS_FILE_WORKERS ? String(process.env.QTESTS_FILE_WORKERS) : '';
        const inBand = process.env.QTESTS_INBAND === '1' || process.env.QTESTS_INBAND === 'true';
        jestArgs.push(testFile);
        if (inBand) {
          jestArgs.push('--runInBand');
        } else if (fileWorkers) {
          jestArgs.push(`--maxWorkers=${fileWorkers}`);
        }
        jestArgs.push('--cache', '--no-coverage');

        // Validate and sanitize jest arguments - optimized to avoid full object copy
        const allowedEnvVars = ['NODE_ENV', 'NODE_OPTIONS', 'QTESTS_SILENT', 'QTESTS_INBAND', 'QTESTS_CONCURRENCY'];
        const sanitizedEnv = {};
        
        // Only copy allowed environment variables
        for (const key of allowedEnvVars) {
          if (process.env[key] !== undefined) {
            sanitizedEnv[key] = process.env[key];
          }
        }

        return new Promise((resolve) => {
          const child = spawn('jest', jestArgs, {
            stdio: ['pipe', 'pipe', 'pipe'],
            shell: false, // CRITICAL: Remove shell to prevent command injection
            env: {
              ...sanitizedEnv,
              NODE_ENV: 'test',
              NODE_OPTIONS: [process.env.NODE_OPTIONS || '', '--experimental-vm-modules'].filter(Boolean).join(' ').trim()
            },
            timeout: 300000 // 5 minute timeout per test file
          });

          child.stdout.on('data', (data) => { stdout += data.toString(); });
          child.stderr.on('data', (data) => { stderr += data.toString(); });

          child.on('close', (code) => {
            const duration = Date.now() - startTime;
            let output = stdout + stderr;
            if (code !== 0 && !output.trim()) {
              output = 'No output captured from jest. Possible worker crash or environment restriction.';
            }
            resolve({ file: testFile, success: code === 0, duration, output, stdout, stderr });
          });

          child.on('error', (err) => {
            qerrors(err, 'testRunner.runTestFile: jest process spawn failed', {
              testFile,
              jestArgs,
              errorType: err.constructor.name,
              errorMessage: err.message
            });
            const duration = Date.now() - startTime;
            const msg = (stderr && stderr.trim()) || (err && err.message) || 'Runner error';
            resolve({ file: testFile, success: false, duration, output: msg, stdout, stderr });
          });

          // Handle process timeout
          if (child.timeout) {
            child.on('timeout', () => {
              qerrors(new Error('Test execution timeout'), 'testRunner.runTestFile: jest process timeout', {
                testFile,
                timeoutMs: 300000,
                duration: Date.now() - startTime
              });
              child.kill('SIGTERM');
              const duration = Date.now() - startTime;
              resolve({ 
                file: testFile, 
                success: false, 
                duration, 
                output: 'Test execution timed out after 5 minutes', 
                stdout, 
                stderr 
              });
            });
          }
        });
      } catch (error) {
        qerrors(error as Error, 'testRunner.runTestFile: test execution setup failed', {
          testFile,
          errorType: error.constructor.name,
          errorMessage: error instanceof Error ? error.message : String(error)
        });
        const duration = Date.now() - startTime;
        return { 
          file: testFile, 
          success: false, 
          duration, 
          output: `Test setup failed: ${error instanceof Error ? error.message : String(error)}`, 
          stdout: '', 
          stderr: '' 
        };
      }
    };

    // First attempt
    const first = await spawnOnce();
    // Detect worker crash signature and retry in-band automatically
    const crashed = /A jest worker process [^\n]* crashed/i.test(first.output || '');
    const alreadyInBand = process.env.QTESTS_INBAND === '1' || process.env.QTESTS_INBAND === 'true';
    if (!first.success && crashed && !alreadyInBand) {
      process.stderr.write(`${colors.yellow}Retrying in-band due to worker crash: ${testFile}${colors.reset}\n`);
      // Store original environment value
      const originalInBand = process.env.QTESTS_INBAND;
      process.env.QTESTS_INBAND = '1';
      try {
        return await this.runTestFile(testFile);
      } finally {
        // Restore original environment completely
        if (originalInBand) {
          process.env.QTESTS_INBAND = originalInBand;
        } else {
          delete process.env.QTESTS_INBAND;
        }
      }
    }
    return first;
  }
            } catch { continue; }
          }
        } catch (error) {
          qerrors(error as Error, 'testRunner.runTestFile: config discovery failed', {
            testFile,
            configCandidates,
            errorType: error.constructor.name,
            errorMessage: error instanceof Error ? error.message : String(error)
          });
        }
        
        const jestArgs = [];
        if (cfg) {
          jestArgs.push('--config', cfg);
        }
        jestArgs.push('--passWithNoTests');
        // Per-file execution tuning: allow in-band or worker override via env
        const fileWorkers = process.env.QTESTS_FILE_WORKERS ? String(process.env.QTESTS_FILE_WORKERS) : '';
        const inBand = process.env.QTESTS_INBAND === '1' || process.env.QTESTS_INBAND === 'true';
        jestArgs.push(testFile);
        if (inBand) {
          jestArgs.push('--runInBand');
        } else if (fileWorkers) {
          jestArgs.push(`--maxWorkers=${fileWorkers}`);
        }
        jestArgs.push('--cache', '--no-coverage');

        // Validate and sanitize jest arguments - optimized to avoid full object copy
        const allowedEnvVars = ['NODE_ENV', 'NODE_OPTIONS', 'QTESTS_SILENT', 'QTESTS_INBAND', 'QTESTS_CONCURRENCY'];
        const sanitizedEnv = {};
        
        // Only copy allowed environment variables
        for (const key of allowedEnvVars) {
          if (process.env[key] !== undefined) {
            sanitizedEnv[key] = process.env[key];
          }
        }

        const child = spawn('jest', jestArgs, {
          stdio: ['pipe', 'pipe', 'pipe'],
          shell: false, // CRITICAL: Remove shell to prevent command injection
          env: {
            ...sanitizedEnv,
            NODE_ENV: 'test',
            NODE_OPTIONS: [process.env.NODE_OPTIONS || '', '--experimental-vm-modules'].filter(Boolean).join(' ').trim()
          },
          timeout: 300000 // 5 minute timeout per test file
        });

        child.stdout.on('data', (data) => { stdout += data.toString(); });
        child.stderr.on('data', (data) => { stderr += data.toString(); });

        child.on('close', (code) => {
          const duration = Date.now() - startTime;
          let output = stdout + stderr;
          if (code !== 0 && !output.trim()) {
            output = 'No output captured from jest. Possible worker crash or environment restriction.';
          }
          resolve({ file: testFile, success: code === 0, duration, output, stdout, stderr });
        });

        child.on('error', (err) => {
          qerrors(err, 'testRunner.runTestFile: jest process spawn failed', {
            testFile,
            jestArgs,
            errorType: err.constructor.name,
            errorMessage: err.message
          });
          const duration = Date.now() - startTime;
          const msg = (stderr && stderr.trim()) || (err && err.message) || 'Runner error';
          resolve({ file: testFile, success: false, duration, output: msg, stdout, stderr });
        });

        // Handle process timeout
        if (child.timeout) {
          child.on('timeout', () => {
            qerrors(new Error('Test execution timeout'), 'testRunner.runTestFile: jest process timeout', {
              testFile,
              timeoutMs: 300000,
              duration: Date.now() - startTime
            });
            child.kill('SIGTERM');
            const duration = Date.now() - startTime;
            resolve({ 
              file: testFile, 
              success: false, 
              duration, 
              output: 'Test execution timed out after 5 minutes', 
              stdout, 
              stderr 
            });
          });
        }
      } catch (error) {
        qerrors(error as Error, 'testRunner.runTestFile: test execution setup failed', {
          testFile,
          errorType: error.constructor.name,
          errorMessage: error instanceof Error ? error.message : String(error)
        });
        const duration = Date.now() - startTime;
        resolve({ 
          file: testFile, 
          success: false, 
          duration, 
          output: `Test setup failed: ${error instanceof Error ? error.message : String(error)}`, 
          stdout: '', 
          stderr: '' 
        });
      }
    });

    // First attempt
    const first = await spawnOnce([]);
    // Detect worker crash signature and retry in-band automatically
    const crashed = /A jest worker process [^\n]* crashed/i.test(first.output || '');
    const alreadyInBand = process.env.QTESTS_INBAND === '1' || process.env.QTESTS_INBAND === 'true';
    if (!first.success && crashed && !alreadyInBand) {
      process.stderr.write(`${colors.yellow}Retrying in-band due to worker crash: ${testFile}${colors.reset}\n`);
      // Store original environment value
      const originalInBand = process.env.QTESTS_INBAND;
      process.env.QTESTS_INBAND = '1';
      try {
        return await this.runTestFile(testFile);
      } finally {
        // Restore original environment completely
        if (originalInBand) {
          process.env.QTESTS_INBAND = originalInBand;
        } else {
          delete process.env.QTESTS_INBAND;
        }
      }
    }
    return first;
  }

  // Print colored status indicator
  printStatus(success, text) {
    const indicator = success ? `${colors.green}${colors.bold}âœ“${colors.reset}` : `${colors.red}${colors.bold}âœ—${colors.reset}`;
    console.log(`${indicator} ${text}`);
  }

  // Print test file result
  printTestResult(result) {
    const { file, success, duration } = result;
    const durationText = `${colors.dim}(${duration}ms)${colors.reset}`;
    const fileText = `${colors.cyan}${file}${colors.reset}`;
    this.printStatus(success, `${fileText} ${durationText}`);
    if (!success && result.output) {
      const lines = result.output.split('\n');
      lines.forEach(line => { if (line.trim()) console.log(`  ${colors.dim}${line}${colors.reset}`); });
    }
  }

  // Generate debug file for failed tests - ASYNC VERSION
  async generateDebugFile() {
    try {
      const failedResults = this.testResults.filter(r => !r.success);
      if (failedResults.length === 0) return;
      let debugContent = '# Test Failure Analysis\n\n';
      debugContent += 'Analyze and address the following test failures:\n\n';
      failedResults.forEach((result, index) => {
        debugContent += `## Failed Test ${index + 1}: ${result.file}\n\n`;
        debugContent += '### Output:\n';
        debugContent += '```\n';
        debugContent += result.output;
        debugContent += '\n```\n\n';
        debugContent += `### Duration: ${result.duration}ms\n\n`;
        debugContent += '---\n\n';
      });
      debugContent += '## Summary\n\n';
      debugContent += `- Total failed tests: ${failedResults.length}\n`;
      debugContent += `- Failed test files: ${failedResults.map(r => r.file).join(', ')}\n`;
      debugContent += `- Generated: ${new Date().toISOString()}\n`;
      
      await fs.promises.writeFile('DEBUG_TESTS.md', debugContent);
      console.log(`\n${colors.yellow}ðŸ“‹ Debug file created: DEBUG_TESTS.md${colors.reset}`);
    } catch (error) {
      qerrors(error as Error, 'testRunner.generateDebugFile: debug file creation failed', {
        failedTestsCount: this.testResults.filter(r => !r.success).length,
        errorType: error.constructor.name,
        errorMessage: error instanceof Error ? error.message : String(error)
      });
      console.error(`${colors.red}Failed to create debug file:${colors.reset}`, error);
    }
  }

  // Print comprehensive summary
  printSummary() {
    const duration = Date.now() - this.startTime;
    const totalFiles = this.testResults.length;
    console.log(`\n${colors.bold}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.reset}`);
    console.log(`${colors.bold}${colors.white}           TEST SUMMARY${colors.reset}`);
    console.log(`${colors.bold}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.reset}`);
    const allPassed = this.failedTests === 0;
    const statusColor = allPassed ? colors.green : colors.red;
    const statusText = allPassed ? 'ALL TESTS PASSED' : 'SOME TESTS FAILED';
    console.log(`${statusColor}${colors.bold}${statusText}${colors.reset}\n`);
    console.log(`${colors.green}âœ“ Passed:${colors.reset} ${colors.bold}${this.passedTests}${colors.reset}`);
    console.log(`${colors.red}âœ— Failed:${colors.reset} ${colors.bold}${this.failedTests}${colors.reset}`);
    console.log(`${colors.blue}ðŸ“ Files:${colors.reset} ${colors.bold}${totalFiles}${colors.reset}`);
    console.log(`${colors.magenta}â±  Duration:${colors.reset} ${colors.bold}${duration}ms${colors.reset}`);
    if (this.failedTests > 0) {
      console.log(`\n${colors.red}Failed test files:${colors.reset}`);
      this.testResults.filter(r => !r.success).forEach(r => console.log(`  ${colors.red}â€¢${colors.reset} ${r.file}`));
    }
    console.log(`\n${colors.bold}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.reset}`);
  }

  // Main runner method - optimized for parallel execution
  async run() {
    console.log(`${colors.bold}${colors.blue}ðŸ§ª qtests Test Runner - Parallel Mode${colors.reset}`);
    console.log(`${colors.dim}Discovering and running all tests...\n${colors.reset}`);
    const testFiles = await this.discoverTests();
    if (testFiles.length === 0) {
      console.log(`${colors.yellow}âš   No test files found${colors.reset}`);
      console.log(`${colors.dim}Looked for files matching: ${TEST_PATTERNS.map(p => p.toString()).join(', ')}${colors.reset}`);
      process.exit(0);
    }
    console.log(`${colors.blue}Found ${testFiles.length} test file(s):${colors.reset}`);
    testFiles.forEach(file => console.log(`  ${colors.dim}â€¢${colors.reset} ${file}`));
    console.log(`\n${colors.magenta}ðŸš€ Running tests in parallel...${colors.reset}\n`);
    const cpuCount = os.cpus().length;
    const envConcurrency = parseInt(process.env.QTESTS_CONCURRENCY || '', 10);
    const defaultConcurrency = Math.max(4, cpuCount * 2);
    const maxConcurrency = Math.min(
      testFiles.length,
      Number.isFinite(envConcurrency) && envConcurrency > 0 ? envConcurrency : defaultConcurrency
    );
    console.log(`${colors.dim}Max concurrency: ${maxConcurrency} workers (${cpuCount} CPU cores)${colors.reset}\n`);

    const runBatch = async (batch) => {
      const results = await Promise.all(batch.map(async (testFile) => {
        const result = await this.runTestFile(testFile);
        if (result.success) this.passedTests++; else this.failedTests++;
        this.printTestResult(result);
        return result;
      }));
      return results;
    };

    for (let i = 0; i < testFiles.length; i += maxConcurrency) {
      const batch = testFiles.slice(i, i + maxConcurrency);
      const batchResults = await runBatch(batch);
      this.testResults.push(...batchResults);
      if (i + maxConcurrency < testFiles.length) {
        console.log(`${colors.dim}Completed batch ${Math.floor(i / maxConcurrency) + 1}, starting next...${colors.reset}\n`);
      }
    }

    if (this.failedTests > 0) await this.generateDebugFile();
    this.printSummary();
    process.exit(this.failedTests > 0 ? 1 : 0);
  }
}

// Run the test suite
const runner = new TestRunner();
runner.run().catch(error => {
  qerrors(error, 'testRunner.main: test runner execution failed', {
    errorType: error.constructor.name,
    errorMessage: error instanceof Error ? error.message : String(error)
  });
  console.error(`${colors.red}Test runner error:${colors.reset}`, error);
  process.exit(1);
});

export default TestRunner;
