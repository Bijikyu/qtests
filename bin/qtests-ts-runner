#!/usr/bin/env node
// IMPORTANT: This CLI is sacrosanct and not generated.
// Policy: API-only via Jest `runCLI` (no child processes).

import fs from 'fs';
import path from 'path';
import os from 'os';
import { Worker } from 'worker_threads';
import qerrors from '../dist/lib/qerrorsFallback.js';

const colors = {
  green: '\u001b[32m',
  red: '\u001b[31m',
  yellow: '\u001b[33m',
  blue: '\u001b[34m',
  cyan: '\u001b[36m',
  reset: '\u001b[0m',
  bold: '\u001b[1m',
  dim: '\u001b[2m'
};

const TEST_PATTERNS = [
  /\.test\.(js|ts|jsx|tsx)$/,
  /\.spec\.(js|ts|jsx|tsx)$/,
  /_test\.(js|ts|jsx|tsx)$/,
  /_spec\.(js|ts|jsx|tsx)$/
];

function isEnvTruthy(name) {
  const v = process.env[name];
  if (!v) return false;
  const s = String(v).trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'yes';
}

function writeRunnerArgs(configPath) {
  const args = ['--config', configPath, '--passWithNoTests', '--runInBand', '--cache', '--no-coverage'];
  try {
    fs.writeFileSync(path.join(process.cwd(), 'runner-jest-args.json'), JSON.stringify(args), 'utf8');
  } catch (error) {
    qerrors(error, 'qtests-ts-runner: failed to write runner-jest-args.json', { configPath });
  }
}

function discoverTests(dir, depth = 0, maxDepth = 10) {
  const testFiles = [];
  if (depth > maxDepth) return testFiles;
  let entries;
  try {
    entries = fs.readdirSync(dir, { withFileTypes: true });
  } catch {
    return testFiles;
  }

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (
      entry.name.startsWith('.') ||
      entry.name === 'node_modules' ||
      entry.name === 'dist' ||
      entry.name === 'build' ||
      entry.name === 'demo'
    ) {
      continue;
    }
    if (entry.isDirectory()) {
      testFiles.push(...discoverTests(fullPath, depth + 1, maxDepth));
      continue;
    }
    if (!entry.isFile()) continue;
    if (!TEST_PATTERNS.some((p) => p.test(entry.name))) continue;
    if (fullPath.includes(`${path.sep}__mocks__${path.sep}`)) continue;
    if (fullPath.includes(`${path.sep}generated-tests${path.sep}`) && !/GeneratedTest/.test(entry.name)) continue;
    testFiles.push(fullPath);
  }
  return testFiles;
}

function applyPatternFilter(files, pattern) {
  try {
    const rx = new RegExp(pattern);
    return files.filter((f) => rx.test(f));
  } catch {
    return files;
  }
}

function splitBatches(files, workers) {
  const buckets = Array.from({ length: workers }, () => []);
  for (let i = 0; i < files.length; i += 1) {
    buckets[i % workers].push(files[i]);
  }
  return buckets.filter((b) => b.length > 0);
}

async function runWorkerBatch(workerUrl, configPath, projectRoot, testFiles) {
  return await new Promise((resolve, reject) => {
    const worker = new Worker(workerUrl, {
      type: 'module',
      workerData: { configPath, projectRoot, testFiles }
    });
    worker.once('message', (msg) => resolve(msg));
    worker.once('error', reject);
    worker.once('exit', (code) => {
      if (code !== 0) reject(new Error(`Worker exited with code ${code}`));
    });
  });
}

async function generateDebugFile(failedResults) {
  if (failedResults.length === 0) return;
  if (isEnvTruthy('QTESTS_SUPPRESS_DEBUG') || isEnvTruthy('QTESTS_NO_DEBUG_FILE')) return;
  const debugFilePath = (process.env.QTESTS_DEBUG_FILE && String(process.env.QTESTS_DEBUG_FILE).trim()) || 'DEBUG_TESTS.md';
  const lines = ['# Test Failure Analysis', '', 'Analyze and address the following test failures:', ''];
  failedResults.forEach((r, idx) => {
    lines.push(
      `## Failed Test ${idx + 1}: ${r.file}`,
      '',
      '### Output:',
      '```',
      r.failureMessage || '',
      '```',
      '',
      `### Duration: ${r.durationMs}ms`,
      '',
      '---',
      ''
    );
  });
  lines.push(
    '## Summary',
    '',
    `- Total failed tests: ${failedResults.length}`,
    `- Failed test files: ${failedResults.map((r) => r.file).join(', ')}`,
    `- Generated: ${new Date().toISOString()}`,
    ''
  );

  try {
    fs.writeFileSync(debugFilePath, lines.join('\n'), 'utf8');
  } catch (error) {
    qerrors(error, 'qtests-ts-runner: failed to write debug file', { debugFilePath });
  }
}

async function main() {
  const projectRoot = process.cwd();
  const configPath = path.join(projectRoot, 'config', 'jest.config.mjs');
  if (!fs.existsSync(configPath)) {
    console.error(`${colors.red}Missing required Jest config:${colors.reset} ${configPath}`);
    process.exit(1);
  }

  const silent = isEnvTruthy('QTESTS_SILENT');
  if (!silent) {
    console.log(`${colors.bold}${colors.blue}ðŸ§ª qtests Test Runner - API Mode${colors.reset}`);
  }

  writeRunnerArgs(configPath);

  const manualDirs = [path.join(projectRoot, 'tests', 'manual-tests'), path.join(projectRoot, 'manual-tests')];
  const manualFiles = manualDirs.flatMap((d) => (fs.existsSync(d) ? discoverTests(d, 0, 10) : []));

  const allFiles = discoverTests(projectRoot, 0, 10);
  const manualSet = new Set(manualFiles);
  let files = allFiles.filter((f) => !manualSet.has(f));

  const pattern = process.env.QTESTS_PATTERN;
  if (pattern) files = applyPatternFilter(files, pattern);

  const ordered = [...manualFiles, ...files];
  if (ordered.length === 0) {
    if (!silent) console.log(`${colors.yellow}âš   No test files found${colors.reset}`);
    process.exit(0);
  }

  const inBand = isEnvTruthy('QTESTS_INBAND');
  const workerStr = process.env.QTESTS_FILE_WORKERS || process.env.QTESTS_CONCURRENCY;
  const requestedWorkers = workerStr ? parseInt(String(workerStr), 10) : NaN;
  const defaultWorkers = Math.max(1, Math.min(os.cpus().length || 1, 4));
  const fileWorkers = inBand ? 1 : (Number.isFinite(requestedWorkers) && requestedWorkers > 0 ? requestedWorkers : defaultWorkers);

  const workerUrl = new URL('../dist/lib/runner/jestWorker.js', import.meta.url);

  let passedFiles = 0;
  let failedFiles = 0;
  const perFileResults = [];

  for (const f of manualFiles) {
    const msg = await runWorkerBatch(workerUrl, configPath, projectRoot, [f]);
    if (msg?.error) throw new Error(msg.error.message || 'Worker error');
    passedFiles += msg.passedFiles || 0;
    failedFiles += msg.failedFiles || 0;
    perFileResults.push(...(msg.results || []));
  }

  const batches = splitBatches(files, fileWorkers);
  const batchResults = await Promise.all(batches.map((b) => runWorkerBatch(workerUrl, configPath, projectRoot, b)));
  for (const msg of batchResults) {
    if (msg?.error) throw new Error(msg.error.message || 'Worker error');
    passedFiles += msg.passedFiles || 0;
    failedFiles += msg.failedFiles || 0;
    perFileResults.push(...(msg.results || []));
  }

  if (!silent) {
    for (const r of perFileResults) {
      const indicator = r.success ? `${colors.green}${colors.bold}âœ“${colors.reset}` : `${colors.red}${colors.bold}âœ—${colors.reset}`;
      console.log(`${indicator} ${colors.cyan}${r.file}${colors.reset} ${colors.dim}(${r.durationMs}ms)${colors.reset}`);
      if (!r.success && r.failureMessage) {
        const firstLines = String(r.failureMessage).split('\n').slice(0, 20);
        firstLines.forEach((ln) => ln.trim() && console.log(`  ${colors.dim}${ln}${colors.reset}`));
      }
    }
    console.log(`${colors.bold}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.reset}`);
    console.log(`${colors.green}âœ“ Passed:${colors.reset} ${colors.bold}${passedFiles}${colors.reset}`);
    console.log(`${colors.red}âœ— Failed:${colors.reset} ${colors.bold}${failedFiles}${colors.reset}`);
    console.log(`${colors.bold}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.reset}`);
  }

  await generateDebugFile(perFileResults.filter((r) => !r.success));
  process.exit(failedFiles > 0 ? 1 : 0);
}

main().catch((error) => {
  qerrors(error, 'qtests-ts-runner: runner crashed', {
    errorType: error?.constructor?.name || 'unknown',
    errorMessage: error?.message || String(error)
  });
  console.error(`${colors.red}Test runner error:${colors.reset}`, error);
  process.exit(1);
});
