#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

function parseArgs(argv) {
  const args = argv.slice(2);
  const options = {
    dryRun: false,
    force: false,
    updatePackageScript: false,
    yes: false,
    noInteractive: false,
    autoInstall: false
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    switch (arg) {
      case '--dry-run': options.dryRun = true; break;
      case '--force': options.force = true; break;
      case '--update-pkg-script': options.updatePackageScript = true; break;
      case '--yes':
      case '-y': options.yes = true; options.noInteractive = true; break;
      case '--no-interactive': options.noInteractive = true; break;
      case '--auto-install': options.autoInstall = true; break;
      case '--help':
      case '-h': showHelp(); process.exit(0); break;
      case '--version':
      case '-v': showVersion(); process.exit(0); break;
      default:
        if (arg.startsWith('-')) {
          console.error(`Unknown option: ${arg}`);
          process.exit(1);
        }
    }
  }
  return options;
}

function showHelp() {
  console.log(`
qtests Runner Scaffolder (Node ESM)

USAGE:
  qtests-generate [OPTIONS]

OPTIONS:
      --dry-run         Show planned scaffolding without writing
      --force           Allow overwriting generated files
      --update-pkg-script  Update package.json test script to use Jest with project config

  -h, --help           Show this help message
  -v, --version        Show version information

EXAMPLES:
  qtests-generate                           # Scaffold qtests runner and config files
  qtests-generate --dry-run                # Preview what would be created
  qtests-generate --force                  # Overwrite existing runner and config files
  `);
}

function showVersion() {
  try {
    const packageJsonPath = path.join(process.cwd(), 'node_modules', 'qtests', 'package.json');
    const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    console.log(`qtests v${pkg.version}`);
  } catch {
    try {
      const pkg = JSON.parse(fs.readFileSync(path.join(process.cwd(), 'package.json'), 'utf8'));
      console.log(`qtests v${pkg.version ?? 'unknown'}`);
    } catch {
      console.log('qtests');
    }
  }
}

function exists(p) {
  try { return fs.existsSync(p); } catch { return false; }
}

function resolveClientRoot() {
  const icwd = process.env.INIT_CWD && String(process.env.INIT_CWD).trim();
  if (icwd && exists(icwd) && !icwd.includes(`${path.sep}node_modules${path.sep}`)) return icwd;
  return process.cwd();
}



class RunnerScaffolder {
  config;

  constructor(options) {
    this.config = { ...options };
  }

getJestConfig() {
  return `// jest.config.mjs - qtests Integration Test Configuration
// Generated by qtests runner scaffolder

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');

export default {
  preset: 'ts-jest/presets/default-esm',
  rootDir: PROJECT_ROOT,
  testEnvironment: 'node',
  setupFiles: [path.join(PROJECT_ROOT, 'config', 'jest-require-polyfill.cjs')],
  setupFilesAfterEnv: [path.join(PROJECT_ROOT, 'config', 'jest-setup.ts')],
  testMatch: [
    '**/integration/**/*.test.ts',
    '**/integration/**/*.test.js',
    '**/integration/**/*.test.jsx',
    '**/integration/**/*.test.tsx'
  ],
  testPathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/build/',
    '/__mocks__/',
    '/manual-tests/',
    '/generated-tests/'
  ],
  modulePathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
  watchPathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  extensionsToTreatAsEsm: ['.ts', '.tsx'],
  transform: {
    '^\\\\.+\\\\.(ts|tsx)$': ['ts-jest', { useESM: true }],
    '^\\\\.+\\\\.(js|jsx)$': ['babel-jest', {
      presets: [['@babel/preset-env', { targets: { node: 'current' } }]]
    }]
  },
  transformIgnorePatterns: ['node_modules/(?!(qtests)/)'],
  moduleNameMapper: {
    '^qtests/(.*)$': '<rootDir>/node_modules/qtests/$1',
    '^(\\\\.{1,2}/.*)\\\\.js$': '$1',
    'mongoose$': '<rootDir>/__mocks__/mongoose.js',
    '^.+\\\\.(css|less|scss|sass)$': '<rootDir>/__mocks__/fileMock.js',
    '^.+\\\\.(png|jpg|jpeg|gif|svg|webp|avif|ico|bmp)$': '<rootDir>/__mocks__/fileMock.js'
  }
};
`;
}

getJestSetup() {
  return `// jest-setup.ts - qtests Integration Test Setup
// Generated by qtests runner scaffolder

import 'qtests/setup';
import { jest as jestFromGlobals } from '@jest/globals';

process.env.NODE_ENV = 'test';

const J = (typeof jestFromGlobals !== 'undefined' && jestFromGlobals)
  ? jestFromGlobals
  : (globalThis as any).jest;
if (!(globalThis as any).jest && J) {
  (globalThis as any).jest = J as any;
}

try {
  if (!(globalThis as any).require && typeof require === 'function') {
    (globalThis as any).require = require as any;
  }
} catch {}

beforeAll(() => {
  const j = (globalThis as any).jest || J;
  if (j && typeof j.setTimeout === 'function') {
    j.setTimeout(10000);
  }
});

afterEach(() => {
  const j = (globalThis as any).jest || J;
  if (j && typeof j.clearAllMocks === 'function') {
    j.clearAllMocks();
  }
});
`;
}

getRequirePolyfill() {
  return `// jest-require-polyfill.cjs - CommonJS require polyfill for ESM tests
// Generated by qtests runner scaffolder

try {
  if (typeof global.require === 'undefined') {
    const { createRequire } = require('module');
    let req;
    try {
      req = createRequire(process.cwd() + '/package.json');
    } catch {
      req = createRequire(__filename);
    }
    Object.defineProperty(global, 'require', {
      value: req,
      writable: false,
      configurable: true,
      enumerable: false
    });
  }
} catch {};
`;
}
    Object.defineProperty(global, 'require', {
      value: req,
      writable: false,
      configurable: true,
      enumerable: false
    });
  }
} catch {}
`;
  }

async scaffoldRunner() {
  const projectRoot = resolveClientRoot();
  
  this.writeRunner(projectRoot);
  this.writeJestConfig(projectRoot);
  this.writeJestSetup(projectRoot);
  this.writeRequirePolyfill(projectRoot);
  
  console.log('‚úÖ qtests runner and configuration files scaffolded successfully');
}

writeRunner(projectRoot) {
  const runnerPath = path.join(projectRoot, 'qtests-runner.mjs');
  const content = this.getRunnerTemplate();
  
  if (!this.config.dryRun) {
    fs.writeFileSync(runnerPath, content, 'utf8');
    fs.chmodSync(runnerPath, '755');
    console.log('‚úÖ Created qtests-runner.mjs');
  } else {
    console.log('üîç Would create qtests-runner.mjs');
  }
}

getRunnerTemplate() {
  return `#!/usr/bin/env node

import { runCLI } from 'jest';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');

async function main() {
  try {
    const config = {
      rootDir: PROJECT_ROOT,
      testMatch: [
        '**/integration/**/*.test.ts',
        '**/integration/**/*.test.js',
        '**/integration/**/*.test.jsx',
        '**/integration/**/*.test.tsx'
      ],
      testPathIgnorePatterns: [
        '/node_modules/',
        '/dist/',
        '/build/',
        '/__mocks__/',
        '/manual-tests/',
        '/generated-tests/'
      ],
      modulePathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
      watchPathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
      verbose: false,
      cache: true,
      coverage: false,
      passWithNoTests: true
    };

    const results = await runCLI(config, [PROJECT_ROOT]);

    if (results.numFailedTests > 0) {
      process.exit(1);
    }
    
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Test runner failed:', error);
    process.exit(1);
  }
}

main();
`;
}

writeJestConfig(projectRoot) {
  const configDir = path.join(projectRoot, 'config');
  const configPath = path.join(configDir, 'jest.config.mjs');
  
  if (!this.config.dryRun) {
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    
    if (!fs.existsSync(configPath) || this.config.force) {
      fs.writeFileSync(configPath, this.getJestConfig(), 'utf8');
      console.log('‚úÖ Created config/jest.config.mjs');
    } else {
      console.log('‚ÑπÔ∏è config/jest.config.mjs already exists');
    }
  } else {
    console.log('üîç Would create config/jest.config.mjs');
  }
}

writeJestSetup(projectRoot) {
  const configDir = path.join(projectRoot, 'config');
  const setupPath = path.join(configDir, 'jest-setup.ts');
  
  if (!this.config.dryRun) {
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    
    if (!fs.existsSync(setupPath) || this.config.force) {
      fs.writeFileSync(setupPath, this.getJestSetup(), 'utf8');
      console.log('‚úÖ Created config/jest-setup.ts');
    } else {
      console.log('‚ÑπÔ∏è config/jest-setup.ts already exists');
    }
  } else {
    console.log('üîç Would create config/jest-setup.ts');
  }
}

writeRequirePolyfill(projectRoot) {
  const configDir = path.join(projectRoot, 'config');
  const polyfillPath = path.join(configDir, 'jest-require-polyfill.cjs');
  
  if (!this.config.dryRun) {
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    
    if (!fs.existsSync(polyfillPath) || this.config.force) {
      fs.writeFileSync(polyfillPath, this.getRequirePolyfill(), 'utf8');
      console.log('‚úÖ Created config/jest-require-polyfill.cjs');
    } else {
      console.log('‚ÑπÔ∏è config/jest-require-polyfill.cjs already exists');
    }
  } else {
    console.log('üîç Would create config/jest-require-polyfill.cjs');
  }
}

updatePackageScript(projectRoot) {
  if (!this.config.updatePackageScript) return;
  
  const pkgPath = path.join(projectRoot, 'package.json');
  if (!exists(pkgPath)) return;
  
  try {
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
    pkg.scripts = pkg.scripts || {};
    
    const testScript = 'node qtests-runner.mjs';
    if (pkg.scripts.test === testScript) {
      console.log('‚ÑπÔ∏è package.json test script already set correctly');
      return;
    }
    
    pkg.scripts.test = testScript;
    
    fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2), 'utf8');
    console.log('‚úÖ Updated package.json test script');
  } catch (error) {
    console.log('‚ö†Ô∏è  Failed to update package.json:', error.message);
  }
}
}

async function main() {
  try {
    console.log('üîß qtests Runner Scaffolder (Node ESM)\n');
    const options = parseArgs(process.argv);
    console.log('Configuration:');
    console.log(`  Dry run: ${options.dryRun ? 'yes' : 'no'}`);
    console.log(`  Force overwrite: ${options.force ? 'yes' : 'no'}`);
    console.log(`  Update package.json script: ${options.updatePackageScript ? 'yes' : 'no'}`);

    const { RunnerScaffolder } = await import('../lib/runnerScaffolder.js');
    const scaffolder = new RunnerScaffolder(options);

    if (options.dryRun) {
      console.log('üîç Dry run - showing planned scaffolding...\n');
      await scaffolder.scaffoldRunner();
    } else {
      await scaffolder.scaffoldRunner();
      scaffolder.updatePackageScript(resolveClientRoot());
    }

    console.log('\nüí° Next steps:');
    console.log('  ‚Ä¢ Run tests: npm test');
    console.log('  ‚Ä¢ Jest config created at config/jest.config.mjs (customize as needed)');
    console.log('  ‚Ä¢ Runner created at qtests-runner.mjs (API-only execution)');
  } catch (error) {
    console.error('‚ùå Error scaffolding runner:', error && (error.stack || error.message) || String(error));
    process.exit(1);
  }
}

main().catch(err => {
  console.error('‚ùå Unexpected error:', err && (err.stack || err.message) || String(err));
  process.exit(1);
});