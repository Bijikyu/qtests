#!/usr/bin/env node

import fs from 'fs/promises';
import fsSync from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import qerrors from 'qerrors';


function parseArgs(argv) {
  const args = argv.slice(2);
  const options = {
    dryRun: false,
    force: false,
    updatePackageScript: false,
    yes: false,
    noInteractive: false,
    autoInstall: false
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    switch (arg) {
      case '--dry-run': options.dryRun = true; break;
      case '--force': options.force = true; break;
      case '--update-pkg-script': options.updatePackageScript = true; break;
      case '--yes':
      case '-y': options.yes = true; options.noInteractive = true; break;
      case '--no-interactive': options.noInteractive = true; break;
      case '--auto-install': options.autoInstall = true; break;
      case '--help':
      case '-h': showHelp(); process.exit(0); break;
      case '--version':
      case '-v': showVersion(); process.exit(0); break;
      default:
        if (arg.startsWith('-')) {
          console.error(`Unknown option: ${arg}`);
          process.exit(1);
        }
    }
  }
  return options;
}

function showHelp() {
  console.log(`
qtests Runner Scaffolder (Node ESM)

USAGE:
  qtests-generate [OPTIONS]

OPTIONS:
      --dry-run         Show planned scaffolding without writing
      --force           Allow overwriting generated files
      --update-pkg-script  Update package.json test script to use Jest with project config

  -h, --help           Show this help message
  -v, --version        Show version information

EXAMPLES:
  qtests-generate                           # Scaffold qtests runner and config files
  qtests-generate --dry-run                # Preview what would be created
  qtests-generate --force                  # Overwrite existing runner and config files
  `);
}

function showVersion() {
  try {
    const packageJsonPath = path.join(process.cwd(), 'node_modules', '@bijikyu/qtests', 'package.json');
    const content = fsSync.readFileSync(packageJsonPath, 'utf8');
    const pkg = JSON.parse(content);
    console.log(`qtests v${pkg.version}`);
  } catch (error) {
    qerrors(error, 'showVersion: reading qtests package.json', { 
      packageJsonPath,
      cwd: process.cwd() 
    });
    try {
      const content = fsSync.readFileSync(path.join(process.cwd(), 'package.json'), 'utf8');
      const pkg = JSON.parse(content);
      console.log(`qtests v${pkg.version ?? 'unknown'}`);
    } catch (fallbackError) {
      qerrors(fallbackError, 'showVersion: reading project package.json', { 
        projectPackagePath: path.join(process.cwd(), 'package.json'),
        cwd: process.cwd() 
      });
      console.log('@bijikyu/qtests');
    }
  }
}

async function exists(p) {
  try { 
    await fs.access(p);
    return true;
  } catch (error) {
    return false; 
  }
}

async function resolveClientRoot() {
  const icwd = process.env.INIT_CWD && String(process.env.INIT_CWD).trim();
  if (icwd && await exists(icwd) && !icwd.includes(`${path.sep}node_modules${path.sep}`)) return icwd;
  return process.cwd();
}



class RunnerScaffolder {
  config;

  constructor(options) {
    this.config = { ...options };
  }

getJestConfig() {
  return `// jest.config.mjs - qtests Integration Test Configuration
// Generated by qtests runner scaffolder

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');

export default {
  preset: 'ts-jest/presets/default-esm',
  rootDir: PROJECT_ROOT,
  testEnvironment: 'node',
  setupFiles: [path.join(PROJECT_ROOT, 'config', 'jest-require-polyfill.cjs')],
  setupFilesAfterEnv: [path.join(PROJECT_ROOT, 'config', 'jest-setup.ts')],
  testMatch: [
    '**/integration/**/*.test.ts',
    '**/integration/**/*.test.js',
    '**/integration/**/*.test.jsx',
    '**/integration/**/*.test.tsx'
  ],
  testPathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/build/',
    '/__mocks__/',
    '/manual-tests/',
    '/generated-tests/'
  ],
  modulePathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
  watchPathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  extensionsToTreatAsEsm: ['.ts', '.tsx'],
  transform: {
    '^\\\\.+\\\\.(ts|tsx)$': ['ts-jest', { useESM: true }],
    '^\\\\.+\\\\.(js|jsx)$': ['babel-jest', {
      presets: [['@babel/preset-env', { targets: { node: 'current' } }]]
    }]
  },
  transformIgnorePatterns: ['node_modules/(?!(qtests)/)'],
  moduleNameMapper: {
    '^qtests/(.*)$': '<rootDir>/node_modules/@bijikyu/qtests/$1',
    '^(\\\\.{1,2}/.*)\\\\.js$': '$1',
    'mongoose$': '<rootDir>/__mocks__/mongoose.js',
    '^.+\\\\.(css|less|scss|sass)$': '<rootDir>/__mocks__/fileMock.js',
    '^.+\\\\.(png|jpg|jpeg|gif|svg|webp|avif|ico|bmp)$': '<rootDir>/__mocks__/fileMock.js'
  }
  `;

  }

getJestSetup() {
  return `// jest-setup.ts - qtests Integration Test Setup
// Generated by qtests runner scaffolder

import '@bijikyu/qtests/setup';
import { jest as jestFromGlobals } from '@jest/globals';

// NODE_ENV is set in localVars.ts for consistency

const J = (typeof jestFromGlobals !== 'undefined' && jestFromGlobals)
  ? jestFromGlobals
  : (globalThis as any).jest;
if (!(globalThis as any).jest && J) {
  (globalThis as any).jest = J as any;
}

try {
  if (!(globalThis as any).require && typeof require === 'function') {
    (globalThis as any).require = require as any;
  }
} catch (error) {
      qerrors(error, 'getRequirePolyfill: global require setup failed', {
        operation: 'globalRequireSetup'
      });
    }

beforeAll(() => {
  const j = (globalThis as any).jest || J;
  if (j && typeof j.setTimeout === 'function') {
    j.setTimeout(10000);
  }
});

afterEach(() => {
  const j = (globalThis as any).jest || J;
  if (j && typeof j.clearAllMocks === 'function') {
    j.clearAllMocks();
  }
});
`;
}

getRequirePolyfill() {
  return `// jest-require-polyfill.cjs - CommonJS require polyfill for ESM tests
// Generated by qtests runner scaffolder

try {
  if (typeof global.require === 'undefined') {
    const { createRequire } = require('module');
    let req;
    try {
      req = createRequire(process.cwd() + '/package.json');
    } catch {
      req = createRequire(__filename);
    }
    Object.defineProperty(global, 'require', {
      value: req,
      writable: false,
      configurable: true,
      enumerable: false
    });
    } catch (error) {
      qerrors(error, 'getJestConfig: template generation failed', { 
        operation: 'templateLiteral'
      });
    }
  `;
}

async scaffoldRunner() {
  const projectRoot = await resolveClientRoot();
  
  await this.writeRunner(projectRoot);
  await this.writeJestConfig(projectRoot);
  await this.writeJestSetup(projectRoot);
  await this.writeRequirePolyfill(projectRoot);
  
  console.log('‚úÖ qtests runner and configuration files scaffolded successfully');
}

async writeRunner(projectRoot) {
  const runnerPath = path.join(projectRoot, 'qtests-runner.mjs');
  const content = this.getRunnerTemplate();
  
  if (!this.config.dryRun) {
    try {
      await fs.writeFile(runnerPath, content, 'utf8');
      await fs.chmod(runnerPath, '755');
      console.log('‚úÖ Created qtests-runner.mjs');
    } catch (error) {
      qerrors(error, 'writeRunner: file creation failed', { 
        runnerPath, 
        contentLength: content.length,
        operation: 'writeAndChmod'
      });
      console.error('‚ùå Failed to create qtests-runner.mjs:', error.message);
      process.exit(1);
    }
  } else {
    console.log('üîç Would create qtests-runner.mjs');
  }
}

getRunnerTemplate() {
  return `#!/usr/bin/env node

import { runCLI } from 'jest';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');

async function main() {
  try {
    const config = {
      rootDir: PROJECT_ROOT,
      testMatch: [
        '**/integration/**/*.test.ts',
        '**/integration/**/*.test.js',
        '**/integration/**/*.test.jsx',
        '**/integration/**/*.test.tsx'
      ],
      testPathIgnorePatterns: [
        '/node_modules/',
        '/dist/',
        '/build/',
        '/__mocks__/',
        '/manual-tests/',
        '/generated-tests/'
      ],
      modulePathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
      watchPathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
      verbose: false,
      cache: true,
      coverage: false,
      passWithNoTests: true
    };

    const results = await runCLI(config, [PROJECT_ROOT]);

    if (results.numFailedTests > 0) {
      process.exit(1);
    }
    
    process.exit(0);
  } catch (error) {
    qerrors(error, 'generatedRunner.main: test execution failed', {
      errorType: error?.constructor?.name || 'unknown'
    });
    console.error('‚ùå Test runner failed:', error);
    process.exit(1);
  }
}

main();
`;
}

async writeJestConfig(projectRoot) {
  const configDir = path.join(projectRoot, 'config');
  const configPath = path.join(configDir, 'jest.config.mjs');
  
  if (!this.config.dryRun) {
    try {
      const configDirExists = await exists(configDir);
      if (!configDirExists) {
        await fs.mkdir(configDir, { recursive: true });
      }
      
      const configPathExists = await exists(configPath);
      if (!configPathExists || this.config.force) {
        const configContent = this.getJestConfig();
        await fs.writeFile(configPath, configContent, 'utf8');
        console.log('‚úÖ Created config/jest.config.mjs');
      } else {
        console.log('‚ÑπÔ∏è config/jest.config.mjs already exists');
      }
    } catch (error) {
      qerrors(error, 'writeJestConfig: config file creation failed', { 
        configPath, 
        configDir,
        operation: 'mkdirAndWrite'
      });
      console.error('‚ùå Failed to create jest.config.mjs:', error.message);
      process.exit(1);
    }
  } else {
    console.log('üîç Would create config/jest.config.mjs');
  }
}

async writeJestSetup(projectRoot) {
  const configDir = path.join(projectRoot, 'config');
  const setupPath = path.join(configDir, 'jest-setup.ts');
  
  if (!this.config.dryRun) {
    const configDirExists = await exists(configDir);
    if (!configDirExists) {
      await fs.mkdir(configDir, { recursive: true });
    }
    
    const setupPathExists = await exists(setupPath);
    if (!setupPathExists || this.config.force) {
      await fs.writeFile(setupPath, this.getJestSetup(), 'utf8');
      console.log('‚úÖ Created config/jest-setup.ts');
    } else {
      console.log('‚ÑπÔ∏è config/jest-setup.ts already exists');
    }
  } else {
    console.log('üîç Would create config/jest-setup.ts');
  }
}

async writeRequirePolyfill(projectRoot) {
  const configDir = path.join(projectRoot, 'config');
  const polyfillPath = path.join(configDir, 'jest-require-polyfill.cjs');
  
  if (!this.config.dryRun) {
    const configDirExists = await exists(configDir);
    if (!configDirExists) {
      await fs.mkdir(configDir, { recursive: true });
    }
    
    const polyfillPathExists = await exists(polyfillPath);
    if (!polyfillPathExists || this.config.force) {
      await fs.writeFile(polyfillPath, this.getRequirePolyfill(), 'utf8');
      console.log('‚úÖ Created config/jest-require-polyfill.cjs');
    } else {
      console.log('‚ÑπÔ∏è config/jest-require-polyfill.cjs already exists');
    }
  } else {
    console.log('üîç Would create config/jest-require-polyfill.cjs');
  }
}

async updatePackageScript(projectRoot) {
  if (!this.config.updatePackageScript) return;
  
  const pkgPath = path.join(projectRoot, 'package.json');
  if (!(await exists(pkgPath))) return;
  
  try {
    const content = await fs.readFile(pkgPath, 'utf8');
    const pkg = JSON.parse(content);
    pkg.scripts = pkg.scripts || {};
    
    const testScript = 'node qtests-runner.mjs';
    if (pkg.scripts.test === testScript) {
      console.log('‚ÑπÔ∏è package.json test script already set correctly');
      return;
    }
    
    pkg.scripts.test = testScript;
    
    await fs.writeFile(pkgPath, JSON.stringify(pkg, null, 2), 'utf8');
    console.log('‚úÖ Updated package.json test script');
  } catch (error) {
    qerrors(error, 'updatePackageScript: parsing or writing package.json', { projectRoot, pkgPath });
    console.log('‚ö†Ô∏è  Failed to update package.json:', error.message);
  }
}
}

async function main() {
  try {
    console.log('üîß qtests Runner Scaffolder (Node ESM)\n');
    const options = parseArgs(process.argv);
    console.log('Configuration:');
    console.log(`  Dry run: ${options.dryRun ? 'yes' : 'no'}`);
    console.log(`  Force overwrite: ${options.force ? 'yes' : 'no'}`);
    console.log(`  Update package.json script: ${options.updatePackageScript ? 'yes' : 'no'}`);

    const { RunnerScaffolder } = await import('../lib/runnerScaffolder.js');
    const scaffolder = new RunnerScaffolder(options);

    if (options.dryRun) {
      console.log('üîç Dry run - showing planned scaffolding...\n');
      await scaffolder.scaffoldRunner();
    } else {
      await scaffolder.scaffoldRunner();
      await scaffolder.updatePackageScript(await resolveClientRoot());
    }

    console.log('\nüí° Next steps:');
    console.log('  ‚Ä¢ Run tests: npm test');
    console.log('  ‚Ä¢ Jest config created at config/jest.config.mjs (customize as needed)');
    console.log('  ‚Ä¢ Runner created at qtests-runner.mjs (API-only execution)');
  } catch (error) {
    qerrors(error, 'main: scaffolding runner', { options });
    console.error('‚ùå Error scaffolding runner:', error && (error.stack || error.message) || String(error));
    process.exit(1);
  }
}

main().catch(err => {
  qerrors(err, 'main: unexpected error in top-level catch');
  console.error('‚ùå Unexpected error:', err && (err.stack || err.message) || String(err));
  process.exit(1);
});