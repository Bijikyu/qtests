#!/usr/bin/env node
import{MemoryPressureMonitor}from'../../dist/lib/memoryPressure.js';import{PerformanceMonitor}from'../../dist/lib/performanceMonitor.js';
class MemoryScalabilityBenchmark{constructor(){this.memoryMonitor=new MemoryPressureMonitor({checkInterval:1000,lowMemoryThreshold:0.5,highMemoryThreshold:0.8,criticalMemoryThreshold:0.9,enableAutoScaling:true,enableGarbageCollection:true});this.perfMonitor=new PerformanceMonitor({intervalMs:2000,historySize:150,enableMemoryMonitoring:true});this.results=[];console.log('Memory Scalability Benchmark Initialized');}
async runAllBenchmarks(){console.log('Starting comprehensive memory scalability benchmarks...');const scenarios=[{name:'Light Load',targetMemory:100*1024*1024,duration:30000,expectedActions:['minimal_adaptive_scaling']},{name:'Moderate Load',targetMemory:300*1024*1024,duration:30000,expectedActions:['cache_size_reduction','moderate_scaling']},{name:'High Load',targetMemory:600*1024*1024,duration:30000,expectedActions:['aggressive_scaling','forced_gc','cache_reduction']},{name:'Extreme Load',targetMemory:900*1024*1024,duration:20000,expectedActions:['emergency_scaling','massive_cleanup','request_rejection']}];for(const scenario of scenarios){const result=await this.runScenario(scenario);this.results.push(result);console.log(`Completed: ${scenario.name} - Memory: ${Math.round(result.peakMemory/1024/1024)}MB, Pressure: ${Math.round(result.memoryPressure*100)}%`);await this.recoveryPeriod(5000);}return this.results;}
async runScenario(scenario){console.log(`Testing: ${scenario.name} (${Math.round(scenario.targetMemory/1024/1024)}MB target)`);const startTime=Date.now();const startMemory=process.memoryUsage();const scalingActions=[];let actionCount=0;this.memoryMonitor.start();this.perfMonitor.start();try{const memoryChunks=this.createMemoryLoad(scenario.targetMemory);const endTime=startTime+scenario.duration;let peakMemory=0;let maxMemoryPressure=0;while(Date.now()<endTime){this.applyMemoryPressure(memoryChunks);const currentMemory=process.memoryUsage();peakMemory=Math.max(peakMemory,currentMemory.heapUsed);const memoryStats=this.memoryMonitor.getMemoryStats();if(memoryStats){maxMemoryPressure=Math.max(maxMemoryPressure,memoryStats.percentage);}const recentActions=this.memoryMonitor.getScalingHistory(5000);if(recentActions.length>actionCount){recentActions.slice(actionCount).forEach(action=>{scalingActions.push({action:action.type+'_'+action.component,timestamp:action.timestamp});});actionCount=recentActions.length;}await this.sleep(100);}const cleanupStart=Date.now();memoryChunks=null;if(global.gc)global.gc();const cleanupTime=Date.now()-cleanupStart;const endMemory=process.memoryUsage();return{scenario:scenario.name,targetMemory:scenario.targetMemory,peakMemory,memoryPressure:maxMemoryPressure,adaptiveScalingActions:scalingActions,cleanupPerformance:cleanupTime,memoryFreed:Math.max(0,startMemory.heapUsed-endMemory.heapUsed),totalDuration:Date.now()-startTime,success:true};}catch(error){console.error(`Scenario ${scenario.name} failed:`,error);return{scenario:scenario.name,targetMemory:scenario.targetMemory,peakMemory:0,memoryPressure:0,adaptiveScalingActions:[],cleanupPerformance:0,memoryFreed:0,totalDuration:Date.now()-startTime,success:false};}finally{this.memoryMonitor.stop();this.perfMonitor.stop();}}
createMemoryLoad(targetBytes){const chunks=[];const chunkSize=10*1024*1024;const numChunks=Math.floor(targetBytes/chunkSize);for(let i=0;i<numChunks;i++){chunks.push(new Uint8Array(chunkSize));}return chunks;}
applyMemoryPressure(memoryChunks){if(!memoryChunks)return;const activeChunks=Math.floor(Math.random()*memoryChunks.length)+1;for(let i=0;i<activeChunks;i++){const chunk=memoryChunks[i];for(let j=0;j<chunk.length;j+=1024){chunk[j]=Math.random()*255;}}}
async recoveryPeriod(ms){console.log(`Recovery period: ${ms}ms`);if(global.gc)global.gc();await new Promise(resolve=>setTimeout(resolve,ms));}
sleep(ms){return new Promise(resolve=>setTimeout(resolve,ms));}
generateReport(){console.log('\nMEMORY SCALABILITY BENCHMARK REPORT');console.log('='.repeat(50));for(const result of this.results){const status=result.success?'PASS':'FAIL';const peakMemoryMB=Math.round(result.peakMemory/1024/1024);const avgActions=result.adaptiveScalingActions.length/(result.totalDuration/60000);console.log(`${status} ${result.scenario.padEnd(15)}`);console.log(`  Target Memory:    ${Math.round(result.targetMemory/1024/1024)}MB`);console.log(`  Peak Memory:      ${peakMemoryMB}MB`);console.log(`  Max Pressure:    ${Math.round(result.memoryPressure*100)}%`);console.log(`  Scaling Actions:  ${result.adaptiveScalingActions.length}`);console.log(`  Actions/Minute:   ${avgActions.toFixed(1)}`);console.log(`  Cleanup Time:    ${result.cleanupPerformance}ms`);console.log(`  Memory Freed:    ${Math.round(result.memoryFreed/1024)}KB`);console.log(`  Duration:        ${result.totalDuration}ms`);console.log('');}const successfull=this.results.filter(r=>r.success);const avgPeakMemory=successfull.reduce((sum,r)=>sum+r.peakMemory,0)/successfull.length;const avgPressure=successfull.reduce((sum,r)=>sum+r.memoryPressure,0)/successfull.length;const avgCleanupTime=successfull.reduce((sum,r)=>sum+r.cleanupPerformance,0)/successfull.length;console.log('PERFORMANCE SUMMARY');console.log(`  Success Rate:     ${successfull.length}/${this.results.length} (${Math.round(successfull.length/this.results.length*100)}%)`);console.log(`  Avg Peak Memory:  ${Math.round(avgPeakMemory/1024/1024)}MB`);console.log(`  Avg Pressure:     ${Math.round(avgPressure*100)}%`);console.log(`  Avg Cleanup Time: ${Math.round(avgCleanupTime)}ms`);console.log('\nRECOMMENDATIONS:');if(avgPressure>0.8){console.log('HIGH MEMORY PRESSURE DETECTED');console.log('   → Consider reducing cache sizes');console.log('   → Increase cleanup frequency');}if(avgCleanupTime>5000){console.log('SLOW CLEANUP PERFORMANCE');console.log('   → Optimize cleanup algorithms');console.log('   → Consider incremental cleanup');}if(successfull.length===this.results.length){console.log('ALL SCENARIOS PASSED');}else{console.log('SOME SCENARIOS FAILED');}}}
if(import.meta.url===`file://${process.argv[1]}`){const benchmark=new MemoryScalabilityBenchmark();benchmark.runAllBenchmarks().then(()=>{benchmark.generateReport();process.exit(0);}).catch(error=>{console.error('Benchmark failed:',error);process.exit(1);});}