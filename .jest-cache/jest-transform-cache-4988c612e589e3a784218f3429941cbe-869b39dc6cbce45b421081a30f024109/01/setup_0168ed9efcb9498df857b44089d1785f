6702cdb9b9fa8831af8fbc6e92599bf4
/**
 * qtests Setup Module - Global Node.js Module Resolution Modification
 * 
 * This module modifies Node.js's global module resolution behavior to automatically
 * substitute stub implementations for real modules during testing. It's a critical
 * piece of the qtests framework that enables seamless testing without changing
 * application code.
 * 
 * Core functionality:
 * When this module is required, it patches Node.js's Module._resolveFilename method
 * to intercept require() calls and redirect them to stub implementations when
 * appropriate. This allows test code to use the same require() statements as
 * production code while getting test-appropriate implementations.
 * 
 * Design philosophy:
 * - Transparent operation: Application code doesn't need to change
 * - Automatic stub resolution: No manual require() path changes needed
 * - Safe operation: Only affects specific modules, others work normally
 * - Performance conscious: Minimal overhead on module resolution
 * 
 * Why global module resolution modification is necessary:
 * 1. Application code uses standard require() statements (require('axios'))
 * 2. Tests need different implementations (stub instead of real axios)
 * 3. Changing application code to use different requires breaks production
 * 4. Manual injection is complex and error-prone
 * 5. Automatic substitution enables testing without code changes
 * 
 * Alternative approaches considered:
 * - Dependency injection: Too complex, requires major application changes
 * - Manual stub imports: Error-prone, doesn't test real require paths
 * - Test-specific builds: Complex tooling, maintenance overhead
 * - Proxy objects: Performance impact, incomplete API coverage
 * 
 * Current approach benefits:
 * - Zero application code changes required
 * - Tests verify actual require() paths used in production
 * - Simple setup and configuration
 * - High compatibility with existing codebases
 * - Minimal performance overhead
 * 
 * Security and safety considerations:
 * - Only affects modules in the predefined stub registry
 * - Original Node.js behavior preserved for unlisted modules
 * - Changes are temporary and isolated to test execution
 * - No permanent modifications to Node.js installation
 * - Easy to disable by not requiring this module
 */

// Import Node.js Module constructor for accessing module resolution internals
// This gives us access to the private _resolveFilename method that controls
// how Node.js resolves module names to file paths
const Module = require('module');

// Import path utilities for robust path manipulation and comparison
// Path operations must be cross-platform compatible and handle edge cases
// like symbolic links, relative paths, and case sensitivity
const path = require('path');
const stubsPath = path.join(__dirname, 'stubs'); // (single absolute path for stub modules after duplicate removal)

// path to stubs directory resolved above //(single comment after removal)

/**
 * Module stub registry - defines which modules should be replaced with stubs
 * 
 * This object maps real module names to their stub implementation paths.
 * When Node.js attempts to resolve a module listed in this registry,
 * the stub path will be returned instead of the real module path.
 * 
 * Registry design rationale:
 * - Explicit mapping provides clear control over which modules are stubbed
 * - Relative paths ensure stubs are loaded from qtests directory structure
 * - Simple object structure is easy to understand and modify
 * - No regex or pattern matching reduces complexity and potential errors
 * 
 * Path resolution strategy:
 * - Stub paths are relative to this setup.js file location
 * - This ensures stubs are found regardless of where qtests is installed
 * - Relative paths prevent absolute path brittleness across environments
 * - Path normalization handles cross-platform differences automatically
 * 
 * Module selection criteria:
 * - axios: Most common HTTP client library, frequently needs stubbing
 * - winston: Popular logging library, often needs silencing in tests
 * - Easy to extend with additional modules as needed
 * 
 * Why not automatic discovery:
 * - Explicit registry prevents accidental stubbing of unexpected modules
 * - Clear intention - developers can see exactly what gets stubbed
 * - No file system scanning overhead during module resolution
 * - Prevents security issues from auto-discovering and loading arbitrary stubs
 */
const STUB_REGISTRY = {
  axios: 'axios.js',
  // HTTP client library stub file name for quick lookup
  winston: 'winston.js' // logging library stub file name for quick lookup
}; //(close registry mapping)
// (registry end for stub mappings)

// Additional stubs can be added here following the same pattern:
// 'module-name': './stubs/module-name'

// Preserve existing NODE_PATH if it exists
// Some environments or tools may have already set NODE_PATH
const currentNodePath = process.env.NODE_PATH || '';

// Determine correct path separator for current platform
// Windows uses semicolons, Unix-like systems use colons
const separator = process.platform === 'win32' ? ';' : ':';

// Prepend our stubs directory to NODE_PATH
// Prepending (not appending) ensures our stubs take precedence
// Only add separator if there's existing NODE_PATH content
process.env.NODE_PATH = stubsPath + (currentNodePath ? separator + currentNodePath : '');

// Force Node.js to recognize the updated NODE_PATH for dynamic module resolution
// _initPaths() is Node.js internal function that reads NODE_PATH and updates module search paths
// Normally NODE_PATH is only read at Node.js startup, but we need to apply changes mid-execution
// This updates Module._nodeModulePaths and other internal resolution state to include our stubs directory
require('module')._initPaths();

// Store original Module._load function for delegation to maintain normal module loading behavior
// _load is the core module loading function that handles actual file reading and module instantiation
// We preserve this to ensure non-stubbed modules load exactly as they would without qtests
const origLoad = Module._load;

// STUB_REGISTRY lookup used below for quick stub resolution on every require

// Override Node.js Module._load to intercept and redirect specific module loads
// _load is chosen over _resolveFilename because it handles the complete loading process
// Function signature must match Node.js internal API exactly for compatibility
Module._load = function (request, parent, isMain) {
  // Look up stub file via shared registry to avoid duplicate maps
  const stubFile = STUB_REGISTRY[request]; // single source of truth for stubs

  if (stubFile) {
    // Build absolute stub path and delegate load to Node's original loader
    return origLoad(path.join(stubsPath, stubFile), parent, isMain); // ensure cross platform path resolution
  }

  // Delegate to original loader for all non-stubbed modules
  // This ensures qtests doesn't interfere with normal Node.js module resolution
  // Maintains full compatibility with existing codebases and module ecosystem
  return origLoad(request, parent, isMain);
};

/**
 * Store reference to original Node.js module resolution function
 * 
 * We save the original _resolveFilename method before modifying it so that:
 * 1. We can call the original implementation for non-stubbed modules
 * 2. We can restore original behavior if needed (though qtests doesn't currently do this)
 * 3. We maintain proper Node.js resolution semantics for all other modules
 * 4. Our modification is transparent and doesn't break existing functionality
 * 
 * Why save before modification:
 * - Once we replace Module._resolveFilename, the original is lost
 * - We need the original to handle normal module resolution
 * - This pattern ensures we enhance rather than replace Node.js functionality
 * - Follows standard monkey-patching best practices
 */
const originalResolveFilename = Module._resolveFilename;

/**
 * Enhanced module resolution function with automatic stub substitution
 * 
 * This function replaces Node.js's Module._resolveFilename to intercept
 * module resolution and redirect specific modules to stub implementations.
 * For modules not in the stub registry, it delegates to the original
 * Node.js resolution function to maintain normal behavior.
 * 
 * Function signature matches Node.js Module._resolveFilename exactly:
 * - request: The module name being resolved (e.g., 'axios')
 * - parent: The module object that initiated the require call
 * - isMain: Boolean indicating if this is the main module
 * - options: Additional resolution options (Node.js internal)
 * 
 * Resolution algorithm:
 * 1. Check if requested module is in stub registry
 * 2. If yes, resolve stub path relative to this file and return it
 * 3. If no, delegate to original Node.js resolution function
 * 4. Handle any resolution errors gracefully
 * 
 * Why intercept at _resolveFilename level:
 * - This is the lowest level where module names are converted to paths
 * - Intercepting here catches all require() calls, including transitive ones
 * - We can modify path resolution without affecting other module loading steps
 * - This approach is used by other popular Node.js testing tools
 * 
 * Error handling strategy:
 * - Always delegate to original function for non-stub modules
 * - Let Node.js handle all error cases for non-stub modules
 * - Only handle stub-specific errors (missing stub files, etc.)
 * - Maintain full compatibility with Node.js error reporting
 * 
 * @param {string} request - Module name being resolved
 * @param {Object} parent - Parent module object that initiated the require
 * @param {boolean} isMain - Whether this is the main module
 * @param {Object} options - Additional Node.js resolution options
 * @returns {string} Resolved file path (either stub or original module)
 */
Module._resolveFilename = function (request, parent, isMain, options) {
  // Check if the requested module is in our stub registry
  // This is the key decision point - stub or delegate to original resolution
  if (STUB_REGISTRY.hasOwnProperty(request)) {
    // Module is in stub registry - resolve stub path

    // Get stub file name from registry and resolve using stubsPath directory
    const stubFile = STUB_REGISTRY[request];
    const resolvedStubPath = path.resolve(stubsPath, stubFile); // compute absolute stub path

    // Return the resolved stub path
    // Node.js will load this file instead of the real module
    return resolvedStubPath;
  }

  // Module is not in stub registry - use original Node.js resolution
  // This maintains normal Node.js behavior for all other modules
  // The original function handles all the complex resolution logic
  // including node_modules searching, file extension resolution, etc.
  return originalResolveFilename.call(this, request, parent, isMain, options);
};

// Note: This module performs setup through side effects when required
// There is no explicit function to call - simply requiring this module
// activates the stub resolution behavior
// 
// This approach was chosen because:
// 1. Setup must happen before any modules are required
// 2. Side-effect-on-require is a common Node.js pattern for setup modules
// 3. It prevents timing issues where setup might be called too late
// 4. The behavior is predictable and follows Node.js conventions
//
// Usage pattern:
// require('qtests/setup'); // Must be first line in test files
// const myModule = require('./myModule'); // May use stubbed dependencies
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNb2R1bGUiLCJyZXF1aXJlIiwicGF0aCIsInN0dWJzUGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJTVFVCX1JFR0lTVFJZIiwiYXhpb3MiLCJ3aW5zdG9uIiwiY3VycmVudE5vZGVQYXRoIiwicHJvY2VzcyIsImVudiIsIk5PREVfUEFUSCIsInNlcGFyYXRvciIsInBsYXRmb3JtIiwiX2luaXRQYXRocyIsIm9yaWdMb2FkIiwiX2xvYWQiLCJyZXF1ZXN0IiwicGFyZW50IiwiaXNNYWluIiwic3R1YkZpbGUiLCJvcmlnaW5hbFJlc29sdmVGaWxlbmFtZSIsIl9yZXNvbHZlRmlsZW5hbWUiLCJvcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJyZXNvbHZlZFN0dWJQYXRoIiwicmVzb2x2ZSIsImNhbGwiXSwic291cmNlcyI6WyJzZXR1cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHF0ZXN0cyBTZXR1cCBNb2R1bGUgLSBHbG9iYWwgTm9kZS5qcyBNb2R1bGUgUmVzb2x1dGlvbiBNb2RpZmljYXRpb25cbiAqIFxuICogVGhpcyBtb2R1bGUgbW9kaWZpZXMgTm9kZS5qcydzIGdsb2JhbCBtb2R1bGUgcmVzb2x1dGlvbiBiZWhhdmlvciB0byBhdXRvbWF0aWNhbGx5XG4gKiBzdWJzdGl0dXRlIHN0dWIgaW1wbGVtZW50YXRpb25zIGZvciByZWFsIG1vZHVsZXMgZHVyaW5nIHRlc3RpbmcuIEl0J3MgYSBjcml0aWNhbFxuICogcGllY2Ugb2YgdGhlIHF0ZXN0cyBmcmFtZXdvcmsgdGhhdCBlbmFibGVzIHNlYW1sZXNzIHRlc3Rpbmcgd2l0aG91dCBjaGFuZ2luZ1xuICogYXBwbGljYXRpb24gY29kZS5cbiAqIFxuICogQ29yZSBmdW5jdGlvbmFsaXR5OlxuICogV2hlbiB0aGlzIG1vZHVsZSBpcyByZXF1aXJlZCwgaXQgcGF0Y2hlcyBOb2RlLmpzJ3MgTW9kdWxlLl9yZXNvbHZlRmlsZW5hbWUgbWV0aG9kXG4gKiB0byBpbnRlcmNlcHQgcmVxdWlyZSgpIGNhbGxzIGFuZCByZWRpcmVjdCB0aGVtIHRvIHN0dWIgaW1wbGVtZW50YXRpb25zIHdoZW5cbiAqIGFwcHJvcHJpYXRlLiBUaGlzIGFsbG93cyB0ZXN0IGNvZGUgdG8gdXNlIHRoZSBzYW1lIHJlcXVpcmUoKSBzdGF0ZW1lbnRzIGFzXG4gKiBwcm9kdWN0aW9uIGNvZGUgd2hpbGUgZ2V0dGluZyB0ZXN0LWFwcHJvcHJpYXRlIGltcGxlbWVudGF0aW9ucy5cbiAqIFxuICogRGVzaWduIHBoaWxvc29waHk6XG4gKiAtIFRyYW5zcGFyZW50IG9wZXJhdGlvbjogQXBwbGljYXRpb24gY29kZSBkb2Vzbid0IG5lZWQgdG8gY2hhbmdlXG4gKiAtIEF1dG9tYXRpYyBzdHViIHJlc29sdXRpb246IE5vIG1hbnVhbCByZXF1aXJlKCkgcGF0aCBjaGFuZ2VzIG5lZWRlZFxuICogLSBTYWZlIG9wZXJhdGlvbjogT25seSBhZmZlY3RzIHNwZWNpZmljIG1vZHVsZXMsIG90aGVycyB3b3JrIG5vcm1hbGx5XG4gKiAtIFBlcmZvcm1hbmNlIGNvbnNjaW91czogTWluaW1hbCBvdmVyaGVhZCBvbiBtb2R1bGUgcmVzb2x1dGlvblxuICogXG4gKiBXaHkgZ2xvYmFsIG1vZHVsZSByZXNvbHV0aW9uIG1vZGlmaWNhdGlvbiBpcyBuZWNlc3Nhcnk6XG4gKiAxLiBBcHBsaWNhdGlvbiBjb2RlIHVzZXMgc3RhbmRhcmQgcmVxdWlyZSgpIHN0YXRlbWVudHMgKHJlcXVpcmUoJ2F4aW9zJykpXG4gKiAyLiBUZXN0cyBuZWVkIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnMgKHN0dWIgaW5zdGVhZCBvZiByZWFsIGF4aW9zKVxuICogMy4gQ2hhbmdpbmcgYXBwbGljYXRpb24gY29kZSB0byB1c2UgZGlmZmVyZW50IHJlcXVpcmVzIGJyZWFrcyBwcm9kdWN0aW9uXG4gKiA0LiBNYW51YWwgaW5qZWN0aW9uIGlzIGNvbXBsZXggYW5kIGVycm9yLXByb25lXG4gKiA1LiBBdXRvbWF0aWMgc3Vic3RpdHV0aW9uIGVuYWJsZXMgdGVzdGluZyB3aXRob3V0IGNvZGUgY2hhbmdlc1xuICogXG4gKiBBbHRlcm5hdGl2ZSBhcHByb2FjaGVzIGNvbnNpZGVyZWQ6XG4gKiAtIERlcGVuZGVuY3kgaW5qZWN0aW9uOiBUb28gY29tcGxleCwgcmVxdWlyZXMgbWFqb3IgYXBwbGljYXRpb24gY2hhbmdlc1xuICogLSBNYW51YWwgc3R1YiBpbXBvcnRzOiBFcnJvci1wcm9uZSwgZG9lc24ndCB0ZXN0IHJlYWwgcmVxdWlyZSBwYXRoc1xuICogLSBUZXN0LXNwZWNpZmljIGJ1aWxkczogQ29tcGxleCB0b29saW5nLCBtYWludGVuYW5jZSBvdmVyaGVhZFxuICogLSBQcm94eSBvYmplY3RzOiBQZXJmb3JtYW5jZSBpbXBhY3QsIGluY29tcGxldGUgQVBJIGNvdmVyYWdlXG4gKiBcbiAqIEN1cnJlbnQgYXBwcm9hY2ggYmVuZWZpdHM6XG4gKiAtIFplcm8gYXBwbGljYXRpb24gY29kZSBjaGFuZ2VzIHJlcXVpcmVkXG4gKiAtIFRlc3RzIHZlcmlmeSBhY3R1YWwgcmVxdWlyZSgpIHBhdGhzIHVzZWQgaW4gcHJvZHVjdGlvblxuICogLSBTaW1wbGUgc2V0dXAgYW5kIGNvbmZpZ3VyYXRpb25cbiAqIC0gSGlnaCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgY29kZWJhc2VzXG4gKiAtIE1pbmltYWwgcGVyZm9ybWFuY2Ugb3ZlcmhlYWRcbiAqIFxuICogU2VjdXJpdHkgYW5kIHNhZmV0eSBjb25zaWRlcmF0aW9uczpcbiAqIC0gT25seSBhZmZlY3RzIG1vZHVsZXMgaW4gdGhlIHByZWRlZmluZWQgc3R1YiByZWdpc3RyeVxuICogLSBPcmlnaW5hbCBOb2RlLmpzIGJlaGF2aW9yIHByZXNlcnZlZCBmb3IgdW5saXN0ZWQgbW9kdWxlc1xuICogLSBDaGFuZ2VzIGFyZSB0ZW1wb3JhcnkgYW5kIGlzb2xhdGVkIHRvIHRlc3QgZXhlY3V0aW9uXG4gKiAtIE5vIHBlcm1hbmVudCBtb2RpZmljYXRpb25zIHRvIE5vZGUuanMgaW5zdGFsbGF0aW9uXG4gKiAtIEVhc3kgdG8gZGlzYWJsZSBieSBub3QgcmVxdWlyaW5nIHRoaXMgbW9kdWxlXG4gKi9cblxuLy8gSW1wb3J0IE5vZGUuanMgTW9kdWxlIGNvbnN0cnVjdG9yIGZvciBhY2Nlc3NpbmcgbW9kdWxlIHJlc29sdXRpb24gaW50ZXJuYWxzXG4vLyBUaGlzIGdpdmVzIHVzIGFjY2VzcyB0byB0aGUgcHJpdmF0ZSBfcmVzb2x2ZUZpbGVuYW1lIG1ldGhvZCB0aGF0IGNvbnRyb2xzXG4vLyBob3cgTm9kZS5qcyByZXNvbHZlcyBtb2R1bGUgbmFtZXMgdG8gZmlsZSBwYXRoc1xuY29uc3QgTW9kdWxlID0gcmVxdWlyZSgnbW9kdWxlJyk7XG5cbi8vIEltcG9ydCBwYXRoIHV0aWxpdGllcyBmb3Igcm9idXN0IHBhdGggbWFuaXB1bGF0aW9uIGFuZCBjb21wYXJpc29uXG4vLyBQYXRoIG9wZXJhdGlvbnMgbXVzdCBiZSBjcm9zcy1wbGF0Zm9ybSBjb21wYXRpYmxlIGFuZCBoYW5kbGUgZWRnZSBjYXNlc1xuLy8gbGlrZSBzeW1ib2xpYyBsaW5rcywgcmVsYXRpdmUgcGF0aHMsIGFuZCBjYXNlIHNlbnNpdGl2aXR5XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgc3R1YnNQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3N0dWJzJyk7IC8vIChzaW5nbGUgYWJzb2x1dGUgcGF0aCBmb3Igc3R1YiBtb2R1bGVzIGFmdGVyIGR1cGxpY2F0ZSByZW1vdmFsKVxuXG4vLyBwYXRoIHRvIHN0dWJzIGRpcmVjdG9yeSByZXNvbHZlZCBhYm92ZSAvLyhzaW5nbGUgY29tbWVudCBhZnRlciByZW1vdmFsKVxuXG4vKipcbiAqIE1vZHVsZSBzdHViIHJlZ2lzdHJ5IC0gZGVmaW5lcyB3aGljaCBtb2R1bGVzIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHN0dWJzXG4gKiBcbiAqIFRoaXMgb2JqZWN0IG1hcHMgcmVhbCBtb2R1bGUgbmFtZXMgdG8gdGhlaXIgc3R1YiBpbXBsZW1lbnRhdGlvbiBwYXRocy5cbiAqIFdoZW4gTm9kZS5qcyBhdHRlbXB0cyB0byByZXNvbHZlIGEgbW9kdWxlIGxpc3RlZCBpbiB0aGlzIHJlZ2lzdHJ5LFxuICogdGhlIHN0dWIgcGF0aCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgdGhlIHJlYWwgbW9kdWxlIHBhdGguXG4gKiBcbiAqIFJlZ2lzdHJ5IGRlc2lnbiByYXRpb25hbGU6XG4gKiAtIEV4cGxpY2l0IG1hcHBpbmcgcHJvdmlkZXMgY2xlYXIgY29udHJvbCBvdmVyIHdoaWNoIG1vZHVsZXMgYXJlIHN0dWJiZWRcbiAqIC0gUmVsYXRpdmUgcGF0aHMgZW5zdXJlIHN0dWJzIGFyZSBsb2FkZWQgZnJvbSBxdGVzdHMgZGlyZWN0b3J5IHN0cnVjdHVyZVxuICogLSBTaW1wbGUgb2JqZWN0IHN0cnVjdHVyZSBpcyBlYXN5IHRvIHVuZGVyc3RhbmQgYW5kIG1vZGlmeVxuICogLSBObyByZWdleCBvciBwYXR0ZXJuIG1hdGNoaW5nIHJlZHVjZXMgY29tcGxleGl0eSBhbmQgcG90ZW50aWFsIGVycm9yc1xuICogXG4gKiBQYXRoIHJlc29sdXRpb24gc3RyYXRlZ3k6XG4gKiAtIFN0dWIgcGF0aHMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgc2V0dXAuanMgZmlsZSBsb2NhdGlvblxuICogLSBUaGlzIGVuc3VyZXMgc3R1YnMgYXJlIGZvdW5kIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgcXRlc3RzIGlzIGluc3RhbGxlZFxuICogLSBSZWxhdGl2ZSBwYXRocyBwcmV2ZW50IGFic29sdXRlIHBhdGggYnJpdHRsZW5lc3MgYWNyb3NzIGVudmlyb25tZW50c1xuICogLSBQYXRoIG5vcm1hbGl6YXRpb24gaGFuZGxlcyBjcm9zcy1wbGF0Zm9ybSBkaWZmZXJlbmNlcyBhdXRvbWF0aWNhbGx5XG4gKiBcbiAqIE1vZHVsZSBzZWxlY3Rpb24gY3JpdGVyaWE6XG4gKiAtIGF4aW9zOiBNb3N0IGNvbW1vbiBIVFRQIGNsaWVudCBsaWJyYXJ5LCBmcmVxdWVudGx5IG5lZWRzIHN0dWJiaW5nXG4gKiAtIHdpbnN0b246IFBvcHVsYXIgbG9nZ2luZyBsaWJyYXJ5LCBvZnRlbiBuZWVkcyBzaWxlbmNpbmcgaW4gdGVzdHNcbiAqIC0gRWFzeSB0byBleHRlbmQgd2l0aCBhZGRpdGlvbmFsIG1vZHVsZXMgYXMgbmVlZGVkXG4gKiBcbiAqIFdoeSBub3QgYXV0b21hdGljIGRpc2NvdmVyeTpcbiAqIC0gRXhwbGljaXQgcmVnaXN0cnkgcHJldmVudHMgYWNjaWRlbnRhbCBzdHViYmluZyBvZiB1bmV4cGVjdGVkIG1vZHVsZXNcbiAqIC0gQ2xlYXIgaW50ZW50aW9uIC0gZGV2ZWxvcGVycyBjYW4gc2VlIGV4YWN0bHkgd2hhdCBnZXRzIHN0dWJiZWRcbiAqIC0gTm8gZmlsZSBzeXN0ZW0gc2Nhbm5pbmcgb3ZlcmhlYWQgZHVyaW5nIG1vZHVsZSByZXNvbHV0aW9uXG4gKiAtIFByZXZlbnRzIHNlY3VyaXR5IGlzc3VlcyBmcm9tIGF1dG8tZGlzY292ZXJpbmcgYW5kIGxvYWRpbmcgYXJiaXRyYXJ5IHN0dWJzXG4gKi9cbmNvbnN0IFNUVUJfUkVHSVNUUlkgPSB7XG4gIGF4aW9zOiAnYXhpb3MuanMnLCAvLyBIVFRQIGNsaWVudCBsaWJyYXJ5IHN0dWIgZmlsZSBuYW1lIGZvciBxdWljayBsb29rdXBcbiAgd2luc3RvbjogJ3dpbnN0b24uanMnIC8vIGxvZ2dpbmcgbGlicmFyeSBzdHViIGZpbGUgbmFtZSBmb3IgcXVpY2sgbG9va3VwXG59OyAvLyhjbG9zZSByZWdpc3RyeSBtYXBwaW5nKVxuLy8gKHJlZ2lzdHJ5IGVuZCBmb3Igc3R1YiBtYXBwaW5ncylcblxuICAvLyBBZGRpdGlvbmFsIHN0dWJzIGNhbiBiZSBhZGRlZCBoZXJlIGZvbGxvd2luZyB0aGUgc2FtZSBwYXR0ZXJuOlxuICAvLyAnbW9kdWxlLW5hbWUnOiAnLi9zdHVicy9tb2R1bGUtbmFtZSdcblxuXG4vLyBQcmVzZXJ2ZSBleGlzdGluZyBOT0RFX1BBVEggaWYgaXQgZXhpc3RzXG4vLyBTb21lIGVudmlyb25tZW50cyBvciB0b29scyBtYXkgaGF2ZSBhbHJlYWR5IHNldCBOT0RFX1BBVEhcbmNvbnN0IGN1cnJlbnROb2RlUGF0aCA9IHByb2Nlc3MuZW52Lk5PREVfUEFUSCB8fCAnJztcblxuLy8gRGV0ZXJtaW5lIGNvcnJlY3QgcGF0aCBzZXBhcmF0b3IgZm9yIGN1cnJlbnQgcGxhdGZvcm1cbi8vIFdpbmRvd3MgdXNlcyBzZW1pY29sb25zLCBVbml4LWxpa2Ugc3lzdGVtcyB1c2UgY29sb25zXG5jb25zdCBzZXBhcmF0b3IgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJzsnIDogJzonO1xuXG4vLyBQcmVwZW5kIG91ciBzdHVicyBkaXJlY3RvcnkgdG8gTk9ERV9QQVRIXG4vLyBQcmVwZW5kaW5nIChub3QgYXBwZW5kaW5nKSBlbnN1cmVzIG91ciBzdHVicyB0YWtlIHByZWNlZGVuY2Vcbi8vIE9ubHkgYWRkIHNlcGFyYXRvciBpZiB0aGVyZSdzIGV4aXN0aW5nIE5PREVfUEFUSCBjb250ZW50XG5wcm9jZXNzLmVudi5OT0RFX1BBVEggPSBzdHVic1BhdGggKyAoY3VycmVudE5vZGVQYXRoID8gc2VwYXJhdG9yICsgY3VycmVudE5vZGVQYXRoIDogJycpO1xuXG4vLyBGb3JjZSBOb2RlLmpzIHRvIHJlY29nbml6ZSB0aGUgdXBkYXRlZCBOT0RFX1BBVEggZm9yIGR5bmFtaWMgbW9kdWxlIHJlc29sdXRpb25cbi8vIF9pbml0UGF0aHMoKSBpcyBOb2RlLmpzIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmVhZHMgTk9ERV9QQVRIIGFuZCB1cGRhdGVzIG1vZHVsZSBzZWFyY2ggcGF0aHNcbi8vIE5vcm1hbGx5IE5PREVfUEFUSCBpcyBvbmx5IHJlYWQgYXQgTm9kZS5qcyBzdGFydHVwLCBidXQgd2UgbmVlZCB0byBhcHBseSBjaGFuZ2VzIG1pZC1leGVjdXRpb25cbi8vIFRoaXMgdXBkYXRlcyBNb2R1bGUuX25vZGVNb2R1bGVQYXRocyBhbmQgb3RoZXIgaW50ZXJuYWwgcmVzb2x1dGlvbiBzdGF0ZSB0byBpbmNsdWRlIG91ciBzdHVicyBkaXJlY3RvcnlcbnJlcXVpcmUoJ21vZHVsZScpLl9pbml0UGF0aHMoKTtcblxuLy8gU3RvcmUgb3JpZ2luYWwgTW9kdWxlLl9sb2FkIGZ1bmN0aW9uIGZvciBkZWxlZ2F0aW9uIHRvIG1haW50YWluIG5vcm1hbCBtb2R1bGUgbG9hZGluZyBiZWhhdmlvclxuLy8gX2xvYWQgaXMgdGhlIGNvcmUgbW9kdWxlIGxvYWRpbmcgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGFjdHVhbCBmaWxlIHJlYWRpbmcgYW5kIG1vZHVsZSBpbnN0YW50aWF0aW9uXG4vLyBXZSBwcmVzZXJ2ZSB0aGlzIHRvIGVuc3VyZSBub24tc3R1YmJlZCBtb2R1bGVzIGxvYWQgZXhhY3RseSBhcyB0aGV5IHdvdWxkIHdpdGhvdXQgcXRlc3RzXG5jb25zdCBvcmlnTG9hZCA9IE1vZHVsZS5fbG9hZDtcblxuLy8gU1RVQl9SRUdJU1RSWSBsb29rdXAgdXNlZCBiZWxvdyBmb3IgcXVpY2sgc3R1YiByZXNvbHV0aW9uIG9uIGV2ZXJ5IHJlcXVpcmVcblxuLy8gT3ZlcnJpZGUgTm9kZS5qcyBNb2R1bGUuX2xvYWQgdG8gaW50ZXJjZXB0IGFuZCByZWRpcmVjdCBzcGVjaWZpYyBtb2R1bGUgbG9hZHNcbi8vIF9sb2FkIGlzIGNob3NlbiBvdmVyIF9yZXNvbHZlRmlsZW5hbWUgYmVjYXVzZSBpdCBoYW5kbGVzIHRoZSBjb21wbGV0ZSBsb2FkaW5nIHByb2Nlc3Ncbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBtdXN0IG1hdGNoIE5vZGUuanMgaW50ZXJuYWwgQVBJIGV4YWN0bHkgZm9yIGNvbXBhdGliaWxpdHlcbk1vZHVsZS5fbG9hZCA9IGZ1bmN0aW9uKHJlcXVlc3QsIHBhcmVudCwgaXNNYWluKXtcbiAgLy8gTG9vayB1cCBzdHViIGZpbGUgdmlhIHNoYXJlZCByZWdpc3RyeSB0byBhdm9pZCBkdXBsaWNhdGUgbWFwc1xuICBjb25zdCBzdHViRmlsZSA9IFNUVUJfUkVHSVNUUllbcmVxdWVzdF07IC8vIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHN0dWJzXG5cbiAgaWYoc3R1YkZpbGUpe1xuICAgIC8vIEJ1aWxkIGFic29sdXRlIHN0dWIgcGF0aCBhbmQgZGVsZWdhdGUgbG9hZCB0byBOb2RlJ3Mgb3JpZ2luYWwgbG9hZGVyXG4gICAgcmV0dXJuIG9yaWdMb2FkKHBhdGguam9pbihzdHVic1BhdGgsIHN0dWJGaWxlKSwgcGFyZW50LCBpc01haW4pOyAvLyBlbnN1cmUgY3Jvc3MgcGxhdGZvcm0gcGF0aCByZXNvbHV0aW9uXG4gIH1cbiAgXG4gIC8vIERlbGVnYXRlIHRvIG9yaWdpbmFsIGxvYWRlciBmb3IgYWxsIG5vbi1zdHViYmVkIG1vZHVsZXNcbiAgLy8gVGhpcyBlbnN1cmVzIHF0ZXN0cyBkb2Vzbid0IGludGVyZmVyZSB3aXRoIG5vcm1hbCBOb2RlLmpzIG1vZHVsZSByZXNvbHV0aW9uXG4gIC8vIE1haW50YWlucyBmdWxsIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBjb2RlYmFzZXMgYW5kIG1vZHVsZSBlY29zeXN0ZW1cbiAgcmV0dXJuIG9yaWdMb2FkKHJlcXVlc3QsIHBhcmVudCwgaXNNYWluKTtcbn07XG5cbi8qKlxuICogU3RvcmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIE5vZGUuanMgbW9kdWxlIHJlc29sdXRpb24gZnVuY3Rpb25cbiAqIFxuICogV2Ugc2F2ZSB0aGUgb3JpZ2luYWwgX3Jlc29sdmVGaWxlbmFtZSBtZXRob2QgYmVmb3JlIG1vZGlmeWluZyBpdCBzbyB0aGF0OlxuICogMS4gV2UgY2FuIGNhbGwgdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGZvciBub24tc3R1YmJlZCBtb2R1bGVzXG4gKiAyLiBXZSBjYW4gcmVzdG9yZSBvcmlnaW5hbCBiZWhhdmlvciBpZiBuZWVkZWQgKHRob3VnaCBxdGVzdHMgZG9lc24ndCBjdXJyZW50bHkgZG8gdGhpcylcbiAqIDMuIFdlIG1haW50YWluIHByb3BlciBOb2RlLmpzIHJlc29sdXRpb24gc2VtYW50aWNzIGZvciBhbGwgb3RoZXIgbW9kdWxlc1xuICogNC4gT3VyIG1vZGlmaWNhdGlvbiBpcyB0cmFuc3BhcmVudCBhbmQgZG9lc24ndCBicmVhayBleGlzdGluZyBmdW5jdGlvbmFsaXR5XG4gKiBcbiAqIFdoeSBzYXZlIGJlZm9yZSBtb2RpZmljYXRpb246XG4gKiAtIE9uY2Ugd2UgcmVwbGFjZSBNb2R1bGUuX3Jlc29sdmVGaWxlbmFtZSwgdGhlIG9yaWdpbmFsIGlzIGxvc3RcbiAqIC0gV2UgbmVlZCB0aGUgb3JpZ2luYWwgdG8gaGFuZGxlIG5vcm1hbCBtb2R1bGUgcmVzb2x1dGlvblxuICogLSBUaGlzIHBhdHRlcm4gZW5zdXJlcyB3ZSBlbmhhbmNlIHJhdGhlciB0aGFuIHJlcGxhY2UgTm9kZS5qcyBmdW5jdGlvbmFsaXR5XG4gKiAtIEZvbGxvd3Mgc3RhbmRhcmQgbW9ua2V5LXBhdGNoaW5nIGJlc3QgcHJhY3RpY2VzXG4gKi9cbmNvbnN0IG9yaWdpbmFsUmVzb2x2ZUZpbGVuYW1lID0gTW9kdWxlLl9yZXNvbHZlRmlsZW5hbWU7XG5cbi8qKlxuICogRW5oYW5jZWQgbW9kdWxlIHJlc29sdXRpb24gZnVuY3Rpb24gd2l0aCBhdXRvbWF0aWMgc3R1YiBzdWJzdGl0dXRpb25cbiAqIFxuICogVGhpcyBmdW5jdGlvbiByZXBsYWNlcyBOb2RlLmpzJ3MgTW9kdWxlLl9yZXNvbHZlRmlsZW5hbWUgdG8gaW50ZXJjZXB0XG4gKiBtb2R1bGUgcmVzb2x1dGlvbiBhbmQgcmVkaXJlY3Qgc3BlY2lmaWMgbW9kdWxlcyB0byBzdHViIGltcGxlbWVudGF0aW9ucy5cbiAqIEZvciBtb2R1bGVzIG5vdCBpbiB0aGUgc3R1YiByZWdpc3RyeSwgaXQgZGVsZWdhdGVzIHRvIHRoZSBvcmlnaW5hbFxuICogTm9kZS5qcyByZXNvbHV0aW9uIGZ1bmN0aW9uIHRvIG1haW50YWluIG5vcm1hbCBiZWhhdmlvci5cbiAqIFxuICogRnVuY3Rpb24gc2lnbmF0dXJlIG1hdGNoZXMgTm9kZS5qcyBNb2R1bGUuX3Jlc29sdmVGaWxlbmFtZSBleGFjdGx5OlxuICogLSByZXF1ZXN0OiBUaGUgbW9kdWxlIG5hbWUgYmVpbmcgcmVzb2x2ZWQgKGUuZy4sICdheGlvcycpXG4gKiAtIHBhcmVudDogVGhlIG1vZHVsZSBvYmplY3QgdGhhdCBpbml0aWF0ZWQgdGhlIHJlcXVpcmUgY2FsbFxuICogLSBpc01haW46IEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGlzIGlzIHRoZSBtYWluIG1vZHVsZVxuICogLSBvcHRpb25zOiBBZGRpdGlvbmFsIHJlc29sdXRpb24gb3B0aW9ucyAoTm9kZS5qcyBpbnRlcm5hbClcbiAqIFxuICogUmVzb2x1dGlvbiBhbGdvcml0aG06XG4gKiAxLiBDaGVjayBpZiByZXF1ZXN0ZWQgbW9kdWxlIGlzIGluIHN0dWIgcmVnaXN0cnlcbiAqIDIuIElmIHllcywgcmVzb2x2ZSBzdHViIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBmaWxlIGFuZCByZXR1cm4gaXRcbiAqIDMuIElmIG5vLCBkZWxlZ2F0ZSB0byBvcmlnaW5hbCBOb2RlLmpzIHJlc29sdXRpb24gZnVuY3Rpb25cbiAqIDQuIEhhbmRsZSBhbnkgcmVzb2x1dGlvbiBlcnJvcnMgZ3JhY2VmdWxseVxuICogXG4gKiBXaHkgaW50ZXJjZXB0IGF0IF9yZXNvbHZlRmlsZW5hbWUgbGV2ZWw6XG4gKiAtIFRoaXMgaXMgdGhlIGxvd2VzdCBsZXZlbCB3aGVyZSBtb2R1bGUgbmFtZXMgYXJlIGNvbnZlcnRlZCB0byBwYXRoc1xuICogLSBJbnRlcmNlcHRpbmcgaGVyZSBjYXRjaGVzIGFsbCByZXF1aXJlKCkgY2FsbHMsIGluY2x1ZGluZyB0cmFuc2l0aXZlIG9uZXNcbiAqIC0gV2UgY2FuIG1vZGlmeSBwYXRoIHJlc29sdXRpb24gd2l0aG91dCBhZmZlY3Rpbmcgb3RoZXIgbW9kdWxlIGxvYWRpbmcgc3RlcHNcbiAqIC0gVGhpcyBhcHByb2FjaCBpcyB1c2VkIGJ5IG90aGVyIHBvcHVsYXIgTm9kZS5qcyB0ZXN0aW5nIHRvb2xzXG4gKiBcbiAqIEVycm9yIGhhbmRsaW5nIHN0cmF0ZWd5OlxuICogLSBBbHdheXMgZGVsZWdhdGUgdG8gb3JpZ2luYWwgZnVuY3Rpb24gZm9yIG5vbi1zdHViIG1vZHVsZXNcbiAqIC0gTGV0IE5vZGUuanMgaGFuZGxlIGFsbCBlcnJvciBjYXNlcyBmb3Igbm9uLXN0dWIgbW9kdWxlc1xuICogLSBPbmx5IGhhbmRsZSBzdHViLXNwZWNpZmljIGVycm9ycyAobWlzc2luZyBzdHViIGZpbGVzLCBldGMuKVxuICogLSBNYWludGFpbiBmdWxsIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzIGVycm9yIHJlcG9ydGluZ1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdCAtIE1vZHVsZSBuYW1lIGJlaW5nIHJlc29sdmVkXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IC0gUGFyZW50IG1vZHVsZSBvYmplY3QgdGhhdCBpbml0aWF0ZWQgdGhlIHJlcXVpcmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNYWluIC0gV2hldGhlciB0aGlzIGlzIHRoZSBtYWluIG1vZHVsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIE5vZGUuanMgcmVzb2x1dGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXNvbHZlZCBmaWxlIHBhdGggKGVpdGhlciBzdHViIG9yIG9yaWdpbmFsIG1vZHVsZSlcbiAqL1xuTW9kdWxlLl9yZXNvbHZlRmlsZW5hbWUgPSBmdW5jdGlvbihyZXF1ZXN0LCBwYXJlbnQsIGlzTWFpbiwgb3B0aW9ucykge1xuICAvLyBDaGVjayBpZiB0aGUgcmVxdWVzdGVkIG1vZHVsZSBpcyBpbiBvdXIgc3R1YiByZWdpc3RyeVxuICAvLyBUaGlzIGlzIHRoZSBrZXkgZGVjaXNpb24gcG9pbnQgLSBzdHViIG9yIGRlbGVnYXRlIHRvIG9yaWdpbmFsIHJlc29sdXRpb25cbiAgaWYgKFNUVUJfUkVHSVNUUlkuaGFzT3duUHJvcGVydHkocmVxdWVzdCkpIHtcbiAgICAvLyBNb2R1bGUgaXMgaW4gc3R1YiByZWdpc3RyeSAtIHJlc29sdmUgc3R1YiBwYXRoXG5cbiAgICAvLyBHZXQgc3R1YiBmaWxlIG5hbWUgZnJvbSByZWdpc3RyeSBhbmQgcmVzb2x2ZSB1c2luZyBzdHVic1BhdGggZGlyZWN0b3J5XG4gICAgY29uc3Qgc3R1YkZpbGUgPSBTVFVCX1JFR0lTVFJZW3JlcXVlc3RdO1xuICAgIGNvbnN0IHJlc29sdmVkU3R1YlBhdGggPSBwYXRoLnJlc29sdmUoc3R1YnNQYXRoLCBzdHViRmlsZSk7IC8vIGNvbXB1dGUgYWJzb2x1dGUgc3R1YiBwYXRoXG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc29sdmVkIHN0dWIgcGF0aFxuICAgIC8vIE5vZGUuanMgd2lsbCBsb2FkIHRoaXMgZmlsZSBpbnN0ZWFkIG9mIHRoZSByZWFsIG1vZHVsZVxuICAgIHJldHVybiByZXNvbHZlZFN0dWJQYXRoO1xuICB9XG5cbiAgLy8gTW9kdWxlIGlzIG5vdCBpbiBzdHViIHJlZ2lzdHJ5IC0gdXNlIG9yaWdpbmFsIE5vZGUuanMgcmVzb2x1dGlvblxuICAvLyBUaGlzIG1haW50YWlucyBub3JtYWwgTm9kZS5qcyBiZWhhdmlvciBmb3IgYWxsIG90aGVyIG1vZHVsZXNcbiAgLy8gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGhhbmRsZXMgYWxsIHRoZSBjb21wbGV4IHJlc29sdXRpb24gbG9naWNcbiAgLy8gaW5jbHVkaW5nIG5vZGVfbW9kdWxlcyBzZWFyY2hpbmcsIGZpbGUgZXh0ZW5zaW9uIHJlc29sdXRpb24sIGV0Yy5cbiAgcmV0dXJuIG9yaWdpbmFsUmVzb2x2ZUZpbGVuYW1lLmNhbGwodGhpcywgcmVxdWVzdCwgcGFyZW50LCBpc01haW4sIG9wdGlvbnMpO1xufTtcblxuLy8gTm90ZTogVGhpcyBtb2R1bGUgcGVyZm9ybXMgc2V0dXAgdGhyb3VnaCBzaWRlIGVmZmVjdHMgd2hlbiByZXF1aXJlZFxuLy8gVGhlcmUgaXMgbm8gZXhwbGljaXQgZnVuY3Rpb24gdG8gY2FsbCAtIHNpbXBseSByZXF1aXJpbmcgdGhpcyBtb2R1bGVcbi8vIGFjdGl2YXRlcyB0aGUgc3R1YiByZXNvbHV0aW9uIGJlaGF2aW9yXG4vLyBcbi8vIFRoaXMgYXBwcm9hY2ggd2FzIGNob3NlbiBiZWNhdXNlOlxuLy8gMS4gU2V0dXAgbXVzdCBoYXBwZW4gYmVmb3JlIGFueSBtb2R1bGVzIGFyZSByZXF1aXJlZFxuLy8gMi4gU2lkZS1lZmZlY3Qtb24tcmVxdWlyZSBpcyBhIGNvbW1vbiBOb2RlLmpzIHBhdHRlcm4gZm9yIHNldHVwIG1vZHVsZXNcbi8vIDMuIEl0IHByZXZlbnRzIHRpbWluZyBpc3N1ZXMgd2hlcmUgc2V0dXAgbWlnaHQgYmUgY2FsbGVkIHRvbyBsYXRlXG4vLyA0LiBUaGUgYmVoYXZpb3IgaXMgcHJlZGljdGFibGUgYW5kIGZvbGxvd3MgTm9kZS5qcyBjb252ZW50aW9uc1xuLy9cbi8vIFVzYWdlIHBhdHRlcm46XG4vLyByZXF1aXJlKCdxdGVzdHMvc2V0dXAnKTsgLy8gTXVzdCBiZSBmaXJzdCBsaW5lIGluIHRlc3QgZmlsZXNcbi8vIGNvbnN0IG15TW9kdWxlID0gcmVxdWlyZSgnLi9teU1vZHVsZScpOyAvLyBNYXkgdXNlIHN0dWJiZWQgZGVwZW5kZW5jaWVzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDLFFBQVEsQ0FBQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQU1FLFNBQVMsR0FBR0QsSUFBSSxDQUFDRSxJQUFJLENBQUND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