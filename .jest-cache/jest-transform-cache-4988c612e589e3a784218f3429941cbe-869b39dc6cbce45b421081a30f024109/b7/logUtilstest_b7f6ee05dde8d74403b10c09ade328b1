064a3d9405fc30d2eb774a0fda82ec27
const {
  withMockConsole
} = require('../utils/testHelpers'); //(helper for console spies)

const {
  logStart,
  logReturn,
  executeWithLogs
} = require('../lib/logUtils'); //functions under test, includes executeWithLogs

test('logStart logs correct start message', () => withMockConsole('log', spy => {
  //jest test for logStart with helper
  logStart('fn', 1, 2); //trigger log
  const last = spy.mock.calls.length - 1; //index of log entry
  expect(spy.mock.calls[last][0]).toBe('[START] fn(1, 2)'); //check output
}));
test('logReturn logs correct return message', () => withMockConsole('log', spy => {
  //jest test for logReturn with helper
  logReturn('fn', 'value'); //trigger log
  const last = spy.mock.calls.length - 1; //index of log entry
  expect(spy.mock.calls[last][0]).toBe('[RETURN] fn -> "value"'); //check output
}));
test('executeWithLogs wraps sync function', () => withMockConsole('log', spy => {
  //jest test for executeWithLogs sync with helper
  function add(a, b) {
    //simple addition
    return a + b; //return sum
  }
  const res = executeWithLogs('add', add, 1, 2); //execute with logging
  expect(res).toBe(3); //verify result
  expect(spy.mock.calls[3][0]).toBe('add is running with 1, 2'); //check start log
  const last = spy.mock.calls.length - 1; //index of last log
  expect(spy.mock.calls[last][0]).toBe('executeWithLogs is returning 3'); //check return log
}));
test('executeWithLogs wraps async function', async () => withMockConsole('log', async spy => {
  //jest test for executeWithLogs async with helper
  async function fetchVal() {
    //dummy async
    return 'ok'; //return value
  }
  const res = await executeWithLogs('fetchVal', fetchVal); //execute with logging
  expect(res).toBe('ok'); //verify result
  expect(spy.mock.calls[3][0]).toBe('fetchVal is running with none'); //check start log
  const last = spy.mock.calls.length - 1; //index of last log
  expect(spy.mock.calls[last][0]).toBe('executeWithLogs is returning ok'); //check return log
}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ3aXRoTW9ja0NvbnNvbGUiLCJyZXF1aXJlIiwibG9nU3RhcnQiLCJsb2dSZXR1cm4iLCJleGVjdXRlV2l0aExvZ3MiLCJ0ZXN0Iiwic3B5IiwibGFzdCIsIm1vY2siLCJjYWxscyIsImxlbmd0aCIsImV4cGVjdCIsInRvQmUiLCJhZGQiLCJhIiwiYiIsInJlcyIsImZldGNoVmFsIl0sInNvdXJjZXMiOlsibG9nVXRpbHMudGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuY29uc3QgeyB3aXRoTW9ja0NvbnNvbGUgfSA9IHJlcXVpcmUoJy4uL3V0aWxzL3Rlc3RIZWxwZXJzJyk7IC8vKGhlbHBlciBmb3IgY29uc29sZSBzcGllcylcblxuXG5jb25zdCB7IGxvZ1N0YXJ0LCBsb2dSZXR1cm4sIGV4ZWN1dGVXaXRoTG9ncyB9ID0gcmVxdWlyZSgnLi4vbGliL2xvZ1V0aWxzJyk7IC8vZnVuY3Rpb25zIHVuZGVyIHRlc3QsIGluY2x1ZGVzIGV4ZWN1dGVXaXRoTG9nc1xuXG5cbnRlc3QoJ2xvZ1N0YXJ0IGxvZ3MgY29ycmVjdCBzdGFydCBtZXNzYWdlJywgKCkgPT4gd2l0aE1vY2tDb25zb2xlKCdsb2cnLCBzcHkgPT4geyAvL2plc3QgdGVzdCBmb3IgbG9nU3RhcnQgd2l0aCBoZWxwZXJcbiAgbG9nU3RhcnQoJ2ZuJywgMSwgMik7IC8vdHJpZ2dlciBsb2dcbiAgY29uc3QgbGFzdCA9IHNweS5tb2NrLmNhbGxzLmxlbmd0aCAtIDE7IC8vaW5kZXggb2YgbG9nIGVudHJ5XG4gIGV4cGVjdChzcHkubW9jay5jYWxsc1tsYXN0XVswXSkudG9CZSgnW1NUQVJUXSBmbigxLCAyKScpOyAvL2NoZWNrIG91dHB1dFxufSkpO1xuXG50ZXN0KCdsb2dSZXR1cm4gbG9ncyBjb3JyZWN0IHJldHVybiBtZXNzYWdlJywgKCkgPT4gd2l0aE1vY2tDb25zb2xlKCdsb2cnLCBzcHkgPT4geyAvL2plc3QgdGVzdCBmb3IgbG9nUmV0dXJuIHdpdGggaGVscGVyXG4gIGxvZ1JldHVybignZm4nLCAndmFsdWUnKTsgLy90cmlnZ2VyIGxvZ1xuICBjb25zdCBsYXN0ID0gc3B5Lm1vY2suY2FsbHMubGVuZ3RoIC0gMTsgLy9pbmRleCBvZiBsb2cgZW50cnlcbiAgZXhwZWN0KHNweS5tb2NrLmNhbGxzW2xhc3RdWzBdKS50b0JlKCdbUkVUVVJOXSBmbiAtPiBcInZhbHVlXCInKTsgLy9jaGVjayBvdXRwdXRcbn0pKTtcblxudGVzdCgnZXhlY3V0ZVdpdGhMb2dzIHdyYXBzIHN5bmMgZnVuY3Rpb24nLCAoKSA9PiB3aXRoTW9ja0NvbnNvbGUoJ2xvZycsIHNweSA9PiB7IC8vamVzdCB0ZXN0IGZvciBleGVjdXRlV2l0aExvZ3Mgc3luYyB3aXRoIGhlbHBlclxuICBmdW5jdGlvbiBhZGQoYSwgYil7IC8vc2ltcGxlIGFkZGl0aW9uXG4gICAgcmV0dXJuIGEgKyBiOyAvL3JldHVybiBzdW1cbiAgfVxuICBjb25zdCByZXMgPSBleGVjdXRlV2l0aExvZ3MoJ2FkZCcsIGFkZCwgMSwgMik7IC8vZXhlY3V0ZSB3aXRoIGxvZ2dpbmdcbiAgZXhwZWN0KHJlcykudG9CZSgzKTsgLy92ZXJpZnkgcmVzdWx0XG4gIGV4cGVjdChzcHkubW9jay5jYWxsc1szXVswXSkudG9CZSgnYWRkIGlzIHJ1bm5pbmcgd2l0aCAxLCAyJyk7IC8vY2hlY2sgc3RhcnQgbG9nXG4gIGNvbnN0IGxhc3QgPSBzcHkubW9jay5jYWxscy5sZW5ndGggLSAxOyAvL2luZGV4IG9mIGxhc3QgbG9nXG4gIGV4cGVjdChzcHkubW9jay5jYWxsc1tsYXN0XVswXSkudG9CZSgnZXhlY3V0ZVdpdGhMb2dzIGlzIHJldHVybmluZyAzJyk7IC8vY2hlY2sgcmV0dXJuIGxvZ1xufSkpO1xuXG50ZXN0KCdleGVjdXRlV2l0aExvZ3Mgd3JhcHMgYXN5bmMgZnVuY3Rpb24nLCBhc3luYyAoKSA9PiB3aXRoTW9ja0NvbnNvbGUoJ2xvZycsIGFzeW5jIHNweSA9PiB7IC8vamVzdCB0ZXN0IGZvciBleGVjdXRlV2l0aExvZ3MgYXN5bmMgd2l0aCBoZWxwZXJcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hWYWwoKXsgLy9kdW1teSBhc3luY1xuICAgIHJldHVybiAnb2snOyAvL3JldHVybiB2YWx1ZVxuICB9XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGV4ZWN1dGVXaXRoTG9ncygnZmV0Y2hWYWwnLCBmZXRjaFZhbCk7IC8vZXhlY3V0ZSB3aXRoIGxvZ2dpbmdcbiAgZXhwZWN0KHJlcykudG9CZSgnb2snKTsgLy92ZXJpZnkgcmVzdWx0XG4gIGV4cGVjdChzcHkubW9jay5jYWxsc1szXVswXSkudG9CZSgnZmV0Y2hWYWwgaXMgcnVubmluZyB3aXRoIG5vbmUnKTsgLy9jaGVjayBzdGFydCBsb2dcbiAgY29uc3QgbGFzdCA9IHNweS5tb2NrLmNhbGxzLmxlbmd0aCAtIDE7IC8vaW5kZXggb2YgbGFzdCBsb2dcbiAgZXhwZWN0KHNweS5tb2NrLmNhbGxzW2xhc3RdWzBdKS50b0JlKCdleGVjdXRlV2l0aExvZ3MgaXMgcmV0dXJuaW5nIG9rJyk7IC8vY2hlY2sgcmV0dXJuIGxvZ1xufSkpO1xuXG4iXSwibWFwcGluZ3MiOiJBQUVBLE1BQU07RUFBRUE7QUFBZ0IsQ0FBQyxHQUFHQyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDOztBQUc3RCxNQUFNO0VBQUVDLFFBQVE7RUFBRUMsU0FBUztFQUFFQztBQUFnQixDQUFDLEdBQUdILE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7O0FBRzdFSSxJQUFJLENBQUMscUNBQXFDLEVBQUUsTUFBTUwsZUFBZSxDQUFDLEtBQUssRUFBRU0sR0FBRyxJQUFJO0VBQUU7RUFDaEZKLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDdEIsTUFBTUssSUFBSSxHQUFHRCxHQUFHLENBQUNFLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7RUFDeENDLE1BQU0sQ0FBQ0wsR0FBRyxDQUFDRSxJQUFJLENBQUNDLEtBQUssQ0FB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