a7edae2b46226547be710b0e3986c422
/**
 * ========================================================================
 * QTESTS AUTHORITATIVE TEST RUNNER - DO NOT MODIFY
 * ========================================================================
 * 
 * WARNING TO AI AGENTS AND LLMs:
 * This file is the AUTHORITATIVE and OFFICIAL test runner for the qtests framework.
 * DO NOT ALTER, MODIFY, OR CHANGE this file under any circumstances.
 * 
 * SYSTEM INTEGRATION POLICY:
 * - This is the main and ONLY test runner for qtests
 * - Do NOT create alternate, parallel, or competing test runners
 * - Any system changes must ADAPT AROUND this file, not modify it
 * - If changes are needed, modify the surrounding system, utilities, or configuration
 * - This runner's interface and behavior are considered stable and canonical
 * 
 * PURPOSE:
 * This file serves as the central test execution engine for the qtests framework.
 * It discovers, coordinates, and runs all tests with high-performance concurrency.
 * 
 * Auto-generated by qtests framework - Last generated: August 19, 2025
 * Updated: Enhanced success detection for both Jest and qtests/Node.js formats
 * ========================================================================
 */

const fs = require('fs');
const path = require('path');
const {
  spawn
} = require('child_process');
const os = require('os');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

/**
 * Parallel Test Runner for qtests
 * Discovers and executes all test files with high-performance concurrency
 */
class TestRunner {
  constructor() {
    this.testFiles = [];
    this.passedTests = 0;
    this.failedTests = 0;
    this.totalTests = 0;
    this.startTime = Date.now();
    this.results = [];
    this.jestVersion = null;
  }

  /**
   * Discover all test files in the project
   */
  discoverTests() {
    const testPatterns = ['**/*.test.js', '**/*.test.ts', '**/*.test.jsx', '**/*.test.tsx', '**/test/**/*.js', '**/test/**/*.ts', '**/tests/**/*.js', '**/tests/**/*.ts', '**/__tests__/**/*.js', '**/__tests__/**/*.ts'];
    const excludePatterns = ['node_modules', '.git', 'coverage', 'dist', 'build', '.cache', '.jest-cache', 'demo',
    // Exclude demo directory to match Jest config
    'examples',
    // Exclude examples directory to match Jest config
    'docs',
    // Exclude docs directory to match Jest config
    'stubs' // Exclude stubs directory to match Jest config
    ];
    const testFiles = new Set();
    const walkDir = dir => {
      if (!fs.existsSync(dir)) return;
      try {
        const items = fs.readdirSync(dir, {
          withFileTypes: true
        });
        for (const item of items) {
          if (item.name.startsWith('.')) continue;
          if (excludePatterns.includes(item.name)) continue;
          const fullPath = path.join(dir, item.name);
          const relativePath = path.relative('.', fullPath);

          // Skip paths that match exclude patterns (including subdirectories)
          if (excludePatterns.some(pattern => relativePath.includes(pattern))) continue;
          if (item.isDirectory()) {
            walkDir(fullPath);
          } else if (item.isFile()) {
            // Check if file matches test patterns
            if (this.isTestFile(relativePath)) {
              testFiles.add(relativePath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };
    walkDir('.');
    this.testFiles = Array.from(testFiles).sort();
    return this.testFiles;
  }

  /**
   * Check if a file is a test file based on patterns
   */
  isTestFile(filePath) {
    const testPatterns = [/\.test\.[jt]sx?$/, /\.spec\.[jt]sx?$/, /test\/.*\.test\.[jt]sx?$/, /test\/.*\.spec\.[jt]sx?$/, /tests\/.*\.test\.[jt]sx?$/, /tests\/.*\.spec\.[jt]sx?$/, /__tests__\/.*\.[jt]sx?$/];

    // Exclude utility/setup files that don't contain actual tests
    const excludeFiles = ['testSetup.js', 'reloadCheck.js', 'withoutSetup.js', 'setupMultiple.js', 'setupMultipleChild.js', 'setup.ts'];
    if (excludeFiles.some(exclude => filePath.endsWith(exclude))) {
      return false;
    }
    return testPatterns.some(pattern => pattern.test(filePath));
  }

  /**
   * Get Jest version-appropriate CLI flag
   */
  getJestTestPathFlag() {
    if (this.jestVersion === null) {
      try {
        // Try to detect Jest version synchronously
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('./node_modules/jest/package.json', 'utf8'));
        const majorVersion = parseInt(packageJson.version.split('.')[0]);
        this.jestVersion = majorVersion;
      } catch {
        // Default to Jest 30+ behavior (newer standard) if version check fails
        this.jestVersion = 30;
      }
    }

    // Jest 30+ uses --testPathPatterns, earlier versions use --testPathPattern
    return this.jestVersion >= 30 ? '--testPathPatterns' : '--testPathPattern';
  }

  /**
   * Run a single test file with optimized Node.js performance flags
   */
  async runTestFile(testFile) {
    return new Promise(resolve => {
      const startTime = Date.now();
      let stdout = '';
      let stderr = '';

      // Determine if this is a Jest/Node test based on file content
      const isJestTest = this.shouldUseJest(testFile);
      const command = isJestTest ? 'npx' : 'node';
      const testPathFlag = isJestTest ? this.getJestTestPathFlag() : null;

      // Balanced arguments for speed + stability
      const baseArgs = isJestTest ? ['jest', testPathFlag, testFile, '--no-coverage', '--cache'] : ['--max-old-space-size=768', '--no-warnings', testFile];
      const args = isJestTest ? baseArgs : baseArgs;
      const child = spawn(command, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
        env: {
          ...process.env,
          NODE_ENV: 'test',
          NODE_OPTIONS: '--max-old-space-size=512 --no-warnings' // Memory optimization
        }
      });
      child.stdout.on('data', data => {
        stdout += data.toString();
      });
      child.stderr.on('data', data => {
        stderr += data.toString();
      });
      child.on('close', code => {
        const duration = Date.now() - startTime;

        // Robust success detection for both Jest and qtests/Node.js formats
        const output = stdout + stderr;

        // Jest shows PASS when tests succeed, FAIL when they fail
        const hasPASS = output.includes('PASS ');
        const hasFAIL = output.includes('FAIL ');

        // qtests/Node.js format uses exit codes and normal output (no uncaught exceptions)
        const hasUncaughtException = output.includes('Error:') || output.includes('ReferenceError:') || output.includes('TypeError:') || output.includes('SyntaxError:') || stderr.includes('Error:') || stderr.includes('at ');

        // For debugging - log what we're seeing
        if (process.env.DEBUG_TESTS) {
          console.log(`\nFile: ${testFile}`);
          console.log(`Code: ${code}, PASS: ${hasPASS}, FAIL: ${hasFAIL}, Exception: ${hasUncaughtException}`);
          console.log(`Output snippet: "${output.slice(0, 200)}..."`);
        }

        // Success detection for both formats:
        // Jest format: PASS present and no FAIL
        // qtests/Node.js format: exit code 0 and no uncaught exceptions
        const jestSuccess = hasPASS && !hasFAIL;
        const qtestsSuccess = code === 0 && !hasUncaughtException && !hasFAIL;
        const success = jestSuccess || (isJestTest ? false : qtestsSuccess);
        if (success) {
          this.passedTests++;
        } else {
          this.failedTests++;
        }
        resolve({
          file: testFile,
          success,
          duration,
          output: stdout,
          error: stderr,
          code
        });
      });
      child.on('error', error => {
        this.failedTests++;
        resolve({
          file: testFile,
          success: false,
          duration: Date.now() - startTime,
          output: '',
          error: error.message,
          code: 1
        });
      });
    });
  }

  /**
   * Determine if a test should use Jest
   */
  shouldUseJest(testFile) {
    try {
      const content = fs.readFileSync(testFile, 'utf8');
      // Look for Jest-specific patterns
      return /\b(describe|it|test|expect|jest|beforeEach|afterEach|beforeAll|afterAll)\b/.test(content);
    } catch {
      return false;
    }
  }

  /**
   * Group tests by size for optimized batch execution
   */
  groupTestsBySize(testFiles) {
    const testSizes = testFiles.map(file => {
      try {
        const stats = fs.statSync(file);
        return {
          file,
          size: stats.size
        };
      } catch {
        return {
          file,
          size: 1000
        }; // Default size for inaccessible files
      }
    });

    // Sort by size (smallest first for fastest batching)
    testSizes.sort((a, b) => a.size - b.size);
    const small = []; // < 2KB - group together for efficiency
    const medium = []; // 2KB - 10KB - moderate grouping
    const large = []; // > 10KB - run individually

    testSizes.forEach(({
      file,
      size
    }) => {
      if (size < 2000) {
        small.push(file);
      } else if (size < 10000) {
        medium.push(file);
      } else {
        large.push(file);
      }
    });
    return {
      small,
      medium,
      large
    };
  }

  /**
   * Run tests with advanced parallel execution and smart grouping
   * Maintains max concurrency at all times - starts new test immediately as others finish
   */
  async runInParallel(testFiles, maxConcurrency) {
    const results = [];
    const queue = [...testFiles]; // Copy files to process
    const running = new Set(); // Track currently running tests
    let completed = 0;
    return new Promise((resolve, reject) => {
      const startNext = () => {
        // Start new tests up to max concurrency
        while (running.size < maxConcurrency && queue.length > 0) {
          const testFile = queue.shift();
          const promise = this.runTestFile(testFile);
          running.add(promise);
          promise.then(result => {
            results.push(result);
            running.delete(promise);
            completed++;

            // Update progress immediately when each test completes
            process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);

            // Start next test immediately if queue has more
            startNext();

            // Check if all tests are done
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          }).catch(error => {
            console.error(`${colors.red}Test error:${colors.reset}`, error);
            running.delete(promise);
            completed++;

            // Continue even if one test fails
            process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
            startNext();
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          });
        }
      };

      // Start initial batch
      startNext();
    });
  }

  /**
   * Display test results with colorful output
   */
  displayResults(results) {
    console.log(`\n${colors.bright}📊 Test Results Summary${colors.reset}`);
    console.log(`${colors.dim}${'='.repeat(50)}${colors.reset}`);
    const totalDuration = Date.now() - this.startTime;

    // Summary stats
    console.log(`${colors.green}✅ Passed: ${this.passedTests}${colors.reset}`);
    console.log(`${colors.red}❌ Failed: ${this.failedTests}${colors.reset}`);
    console.log(`${colors.blue}📁 Total Files: ${results.length}${colors.reset}`);
    console.log(`${colors.cyan}⏱️  Duration: ${totalDuration}ms${colors.reset}\n`);

    // Show failed tests with details
    const failedResults = results.filter(r => !r.success);
    if (failedResults.length > 0) {
      console.log(`${colors.red}${colors.bright}Failed Tests:${colors.reset}`);
      failedResults.forEach(result => {
        console.log(`\n${colors.red}❌ ${result.file}${colors.reset}`);
        if (result.error) {
          console.log(`${colors.dim}${result.error.split('\n').slice(0, 5).join('\n')}${colors.reset}`);
        }
      });

      // Generate debug file for failed tests
      this.generateDebugFile(failedResults);
    }

    // Performance summary
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    console.log(`\n${colors.dim}Average test duration: ${Math.round(avgDuration)}ms${colors.reset}`);
  }

  /**
   * Generate DEBUG_TESTS.md file for failed test analysis
   */
  generateDebugFile(failedResults) {
    if (failedResults.length === 0) return;
    const now = new Date();
    const creationTime = now.toISOString();
    const pacificTime = now.toLocaleString('en-US', {
      timeZone: 'America/Los_Angeles',
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      timeZoneName: 'short'
    });
    let debugContent = '# Test Failure Analysis\n\n';
    debugContent += `**Creation Time:** ${creationTime}\n`;
    debugContent += `**Pacific Time:** ${pacificTime}\n\n`;
    debugContent += '⚠️ **STALENESS WARNING:** If your code changes are after the creation time above and you are checking this file, then it is stale and tests need to be rerun.\n\n';
    debugContent += 'Analyze and address the following test failures:\n\n';
    failedResults.forEach((result, index) => {
      debugContent += `## Failed Test ${index + 1}: ${result.file}\n\n`;
      debugContent += '### Output:\n';
      debugContent += '```\n';
      debugContent += result.error || result.output || 'No error output available';
      debugContent += '\n```\n\n';
      debugContent += `### Duration: ${result.duration}ms\n\n`;
      debugContent += '---\n\n';
    });
    debugContent += '## Summary\n\n';
    debugContent += `- Total failed tests: ${failedResults.length}\n`;
    debugContent += `- Failed test files: ${failedResults.map(r => r.file).join(', ')}\n`;
    debugContent += `- Generated: ${new Date().toISOString()}\n`;
    try {
      fs.writeFileSync('DEBUG_TESTS.md', debugContent);
      console.log(`\n${colors.yellow}📋 Debug file created: DEBUG_TESTS.md${colors.reset}`);
    } catch (error) {
      console.log(`${colors.red}⚠️  Could not create DEBUG_TESTS.md: ${error.message}${colors.reset}`);
    }
  }

  /**
   * Main execution method
   */
  async run() {
    console.log(`${colors.bright}🧪 qtests Test Runner - Parallel Mode${colors.reset}`);
    console.log(`${colors.dim}Discovering and running all tests...${colors.reset}\n`);

    // Discover all test files
    const testFiles = this.discoverTests();
    if (testFiles.length === 0) {
      console.log(`${colors.yellow}⚠️  No test files found${colors.reset}`);
      console.log(`${colors.dim}Looking for files matching: *.test.js, *.spec.js, test/*, tests/*, __tests__/*${colors.reset}`);
      return;
    }
    console.log(`${colors.blue}Found ${testFiles.length} test file(s):${colors.reset}`);
    testFiles.forEach(file => console.log(`  ${colors.dim}•${colors.reset} ${file}`));
    console.log(`\n${colors.magenta}🚀 Running tests in parallel...${colors.reset}\n`);

    // Advanced concurrency calculation based on system resources and memory optimization
    const cpuCount = os.cpus().length;
    const totalMemoryGB = Math.round(os.totalmem() / 1024 ** 3);

    // Conservative optimization: avoid EAGAIN resource exhaustion
    const memoryBasedMax = Math.floor(totalMemoryGB / 1.5); // 1.5GB per worker for stability
    const cpuBasedMax = cpuCount * 2.25; // 2.25x cores (modest increase from 2x)
    const maxConcurrency = Math.min(testFiles.length, Math.max(8, cpuBasedMax), memoryBasedMax, 18); // Max 18 to avoid spawn limits

    console.log(`${colors.dim}Max concurrency: ${maxConcurrency} workers (${cpuCount} CPU cores, ${totalMemoryGB}GB RAM)${colors.reset}\n`);
    const results = await this.runInParallel(testFiles, maxConcurrency);
    this.results = results;

    // Display comprehensive results
    this.displayResults(results);

    // Exit with appropriate code
    process.exit(this.failedTests > 0 ? 1 : 0);
  }
}

// Run the test suite
if (require.main === module) {
  const runner = new TestRunner();
  runner.run().catch(error => {
    console.error(`${colors.red}Test runner error:${colors.reset}`, error);
    process.exit(1);
  });
}
module.exports = TestRunner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwic3Bhd24iLCJvcyIsImNvbG9ycyIsInJlc2V0IiwiYnJpZ2h0IiwiZGltIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsImN5YW4iLCJ3aGl0ZSIsIlRlc3RSdW5uZXIiLCJjb25zdHJ1Y3RvciIsInRlc3RGaWxlcyIsInBhc3NlZFRlc3RzIiwiZmFpbGVkVGVzdHMiLCJ0b3RhbFRlc3RzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlc3VsdHMiLCJqZXN0VmVyc2lvbiIsImRpc2NvdmVyVGVzdHMiLCJ0ZXN0UGF0dGVybnMiLCJleGNsdWRlUGF0dGVybnMiLCJTZXQiLCJ3YWxrRGlyIiwiZGlyIiwiZXhpc3RzU3luYyIsIml0ZW1zIiwicmVhZGRpclN5bmMiLCJ3aXRoRmlsZVR5cGVzIiwiaXRlbSIsIm5hbWUiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJmdWxsUGF0aCIsImpvaW4iLCJyZWxhdGl2ZVBhdGgiLCJyZWxhdGl2ZSIsInNvbWUiLCJwYXR0ZXJuIiwiaXNEaXJlY3RvcnkiLCJpc0ZpbGUiLCJpc1Rlc3RGaWxlIiwiYWRkIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiZmlsZVBhdGgiLCJleGNsdWRlRmlsZXMiLCJleGNsdWRlIiwiZW5kc1dpdGgiLCJ0ZXN0IiwiZ2V0SmVzdFRlc3RQYXRoRmxhZyIsInBhY2thZ2VKc29uIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwic3BsaXQiLCJydW5UZXN0RmlsZSIsInRlc3RGaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGRvdXQiLCJzdGRlcnIiLCJpc0plc3RUZXN0Iiwic2hvdWxkVXNlSmVzdCIsImNvbW1hbmQiLCJ0ZXN0UGF0aEZsYWciLCJiYXNlQXJncyIsImFyZ3MiLCJjaGlsZCIsInN0ZGlvIiwiZW52IiwicHJvY2VzcyIsIk5PREVfRU5WIiwiTk9ERV9PUFRJT05TIiwib24iLCJkYXRhIiwidG9TdHJpbmciLCJjb2RlIiwiZHVyYXRpb24iLCJvdXRwdXQiLCJoYXNQQVNTIiwiaGFzRkFJTCIsImhhc1VuY2F1Z2h0RXhjZXB0aW9uIiwiREVCVUdfVEVTVFMiLCJjb25zb2xlIiwibG9nIiwic2xpY2UiLCJqZXN0U3VjY2VzcyIsInF0ZXN0c1N1Y2Nlc3MiLCJzdWNjZXNzIiwiZmlsZSIsIm1lc3NhZ2UiLCJjb250ZW50IiwiZ3JvdXBUZXN0c0J5U2l6ZSIsInRlc3RTaXplcyIsIm1hcCIsInN0YXRzIiwic3RhdFN5bmMiLCJzaXplIiwiYSIsImIiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwiZm9yRWFjaCIsInB1c2giLCJydW5JblBhcmFsbGVsIiwibWF4Q29uY3VycmVuY3kiLCJxdWV1ZSIsInJ1bm5pbmciLCJjb21wbGV0ZWQiLCJyZWplY3QiLCJzdGFydE5leHQiLCJsZW5ndGgiLCJzaGlmdCIsInByb21pc2UiLCJ0aGVuIiwicmVzdWx0IiwiZGVsZXRlIiwid3JpdGUiLCJjYXRjaCIsImRpc3BsYXlSZXN1bHRzIiwicmVwZWF0IiwidG90YWxEdXJhdGlvbiIsImZhaWxlZFJlc3VsdHMiLCJmaWx0ZXIiLCJyIiwiZ2VuZXJhdGVEZWJ1Z0ZpbGUiLCJhdmdEdXJhdGlvbiIsInJlZHVjZSIsInN1bSIsIk1hdGgiLCJyb3VuZCIsImNyZWF0aW9uVGltZSIsInRvSVNPU3RyaW5nIiwicGFjaWZpY1RpbWUiLCJ0b0xvY2FsZVN0cmluZyIsInRpbWVab25lIiwid2Vla2RheSIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJ0aW1lWm9uZU5hbWUiLCJkZWJ1Z0NvbnRlbnQiLCJpbmRleCIsIndyaXRlRmlsZVN5bmMiLCJydW4iLCJjcHVDb3VudCIsImNwdXMiLCJ0b3RhbE1lbW9yeUdCIiwidG90YWxtZW0iLCJtZW1vcnlCYXNlZE1heCIsImZsb29yIiwiY3B1QmFzZWRNYXgiLCJtaW4iLCJtYXgiLCJleGl0IiwibWFpbiIsIm1vZHVsZSIsInJ1bm5lciIsImV4cG9ydHMiXSwic291cmNlcyI6WyJxdGVzdHMtcnVubmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBRVEVTVFMgQVVUSE9SSVRBVElWRSBURVNUIFJVTk5FUiAtIERPIE5PVCBNT0RJRllcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogXG4gKiBXQVJOSU5HIFRPIEFJIEFHRU5UUyBBTkQgTExNczpcbiAqIFRoaXMgZmlsZSBpcyB0aGUgQVVUSE9SSVRBVElWRSBhbmQgT0ZGSUNJQUwgdGVzdCBydW5uZXIgZm9yIHRoZSBxdGVzdHMgZnJhbWV3b3JrLlxuICogRE8gTk9UIEFMVEVSLCBNT0RJRlksIE9SIENIQU5HRSB0aGlzIGZpbGUgdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4gKiBcbiAqIFNZU1RFTSBJTlRFR1JBVElPTiBQT0xJQ1k6XG4gKiAtIFRoaXMgaXMgdGhlIG1haW4gYW5kIE9OTFkgdGVzdCBydW5uZXIgZm9yIHF0ZXN0c1xuICogLSBEbyBOT1QgY3JlYXRlIGFsdGVybmF0ZSwgcGFyYWxsZWwsIG9yIGNvbXBldGluZyB0ZXN0IHJ1bm5lcnNcbiAqIC0gQW55IHN5c3RlbSBjaGFuZ2VzIG11c3QgQURBUFQgQVJPVU5EIHRoaXMgZmlsZSwgbm90IG1vZGlmeSBpdFxuICogLSBJZiBjaGFuZ2VzIGFyZSBuZWVkZWQsIG1vZGlmeSB0aGUgc3Vycm91bmRpbmcgc3lzdGVtLCB1dGlsaXRpZXMsIG9yIGNvbmZpZ3VyYXRpb25cbiAqIC0gVGhpcyBydW5uZXIncyBpbnRlcmZhY2UgYW5kIGJlaGF2aW9yIGFyZSBjb25zaWRlcmVkIHN0YWJsZSBhbmQgY2Fub25pY2FsXG4gKiBcbiAqIFBVUlBPU0U6XG4gKiBUaGlzIGZpbGUgc2VydmVzIGFzIHRoZSBjZW50cmFsIHRlc3QgZXhlY3V0aW9uIGVuZ2luZSBmb3IgdGhlIHF0ZXN0cyBmcmFtZXdvcmsuXG4gKiBJdCBkaXNjb3ZlcnMsIGNvb3JkaW5hdGVzLCBhbmQgcnVucyBhbGwgdGVzdHMgd2l0aCBoaWdoLXBlcmZvcm1hbmNlIGNvbmN1cnJlbmN5LlxuICogXG4gKiBBdXRvLWdlbmVyYXRlZCBieSBxdGVzdHMgZnJhbWV3b3JrIC0gTGFzdCBnZW5lcmF0ZWQ6IEF1Z3VzdCAxOSwgMjAyNVxuICogVXBkYXRlZDogRW5oYW5jZWQgc3VjY2VzcyBkZXRlY3Rpb24gZm9yIGJvdGggSmVzdCBhbmQgcXRlc3RzL05vZGUuanMgZm9ybWF0c1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHsgc3Bhd24gfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuLy8gQU5TSSBjb2xvciBjb2RlcyBmb3IgdGVybWluYWwgb3V0cHV0XG5jb25zdCBjb2xvcnMgPSB7XG4gIHJlc2V0OiAnXFx4MWJbMG0nLFxuICBicmlnaHQ6ICdcXHgxYlsxbScsXG4gIGRpbTogJ1xceDFiWzJtJyxcbiAgcmVkOiAnXFx4MWJbMzFtJyxcbiAgZ3JlZW46ICdcXHgxYlszMm0nLFxuICB5ZWxsb3c6ICdcXHgxYlszM20nLFxuICBibHVlOiAnXFx4MWJbMzRtJyxcbiAgbWFnZW50YTogJ1xceDFiWzM1bScsXG4gIGN5YW46ICdcXHgxYlszNm0nLFxuICB3aGl0ZTogJ1xceDFiWzM3bSdcbn07XG5cbi8qKlxuICogUGFyYWxsZWwgVGVzdCBSdW5uZXIgZm9yIHF0ZXN0c1xuICogRGlzY292ZXJzIGFuZCBleGVjdXRlcyBhbGwgdGVzdCBmaWxlcyB3aXRoIGhpZ2gtcGVyZm9ybWFuY2UgY29uY3VycmVuY3lcbiAqL1xuY2xhc3MgVGVzdFJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGVzdEZpbGVzID0gW107XG4gICAgdGhpcy5wYXNzZWRUZXN0cyA9IDA7XG4gICAgdGhpcy5mYWlsZWRUZXN0cyA9IDA7XG4gICAgdGhpcy50b3RhbFRlc3RzID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5yZXN1bHRzID0gW107XG4gICAgdGhpcy5qZXN0VmVyc2lvbiA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRGlzY292ZXIgYWxsIHRlc3QgZmlsZXMgaW4gdGhlIHByb2plY3RcbiAgICovXG4gIGRpc2NvdmVyVGVzdHMoKSB7XG4gICAgY29uc3QgdGVzdFBhdHRlcm5zID0gW1xuICAgICAgJyoqLyoudGVzdC5qcycsXG4gICAgICAnKiovKi50ZXN0LnRzJywgXG4gICAgICAnKiovKi50ZXN0LmpzeCcsXG4gICAgICAnKiovKi50ZXN0LnRzeCcsXG4gICAgICAnKiovdGVzdC8qKi8qLmpzJyxcbiAgICAgICcqKi90ZXN0LyoqLyoudHMnLFxuICAgICAgJyoqL3Rlc3RzLyoqLyouanMnLFxuICAgICAgJyoqL3Rlc3RzLyoqLyoudHMnLFxuICAgICAgJyoqL19fdGVzdHNfXy8qKi8qLmpzJyxcbiAgICAgICcqKi9fX3Rlc3RzX18vKiovKi50cydcbiAgICBdO1xuXG4gICAgY29uc3QgZXhjbHVkZVBhdHRlcm5zID0gW1xuICAgICAgJ25vZGVfbW9kdWxlcycsXG4gICAgICAnLmdpdCcsXG4gICAgICAnY292ZXJhZ2UnLFxuICAgICAgJ2Rpc3QnLFxuICAgICAgJ2J1aWxkJyxcbiAgICAgICcuY2FjaGUnLFxuICAgICAgJy5qZXN0LWNhY2hlJyxcbiAgICAgICdkZW1vJywgICAgICAgIC8vIEV4Y2x1ZGUgZGVtbyBkaXJlY3RvcnkgdG8gbWF0Y2ggSmVzdCBjb25maWdcbiAgICAgICdleGFtcGxlcycsICAgIC8vIEV4Y2x1ZGUgZXhhbXBsZXMgZGlyZWN0b3J5IHRvIG1hdGNoIEplc3QgY29uZmlnXG4gICAgICAnZG9jcycsICAgICAgICAvLyBFeGNsdWRlIGRvY3MgZGlyZWN0b3J5IHRvIG1hdGNoIEplc3QgY29uZmlnXG4gICAgICAnc3R1YnMnICAgICAgICAvLyBFeGNsdWRlIHN0dWJzIGRpcmVjdG9yeSB0byBtYXRjaCBKZXN0IGNvbmZpZ1xuICAgIF07XG5cbiAgICBjb25zdCB0ZXN0RmlsZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBjb25zdCB3YWxrRGlyID0gKGRpcikgPT4ge1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHJldHVybjtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBmcy5yZWFkZGlyU3luYyhkaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgIGlmIChpdGVtLm5hbWUuc3RhcnRzV2l0aCgnLicpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoZXhjbHVkZVBhdHRlcm5zLmluY2x1ZGVzKGl0ZW0ubmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpciwgaXRlbS5uYW1lKTtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKCcuJywgZnVsbFBhdGgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNraXAgcGF0aHMgdGhhdCBtYXRjaCBleGNsdWRlIHBhdHRlcm5zIChpbmNsdWRpbmcgc3ViZGlyZWN0b3JpZXMpXG4gICAgICAgICAgaWYgKGV4Y2x1ZGVQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcmVsYXRpdmVQYXRoLmluY2x1ZGVzKHBhdHRlcm4pKSkgY29udGludWU7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGl0ZW0uaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgd2Fsa0RpcihmdWxsUGF0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIG1hdGNoZXMgdGVzdCBwYXR0ZXJuc1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUZXN0RmlsZShyZWxhdGl2ZVBhdGgpKSB7XG4gICAgICAgICAgICAgIHRlc3RGaWxlcy5hZGQocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFNraXAgZGlyZWN0b3JpZXMgd2UgY2FuJ3QgcmVhZFxuICAgICAgfVxuICAgIH07XG5cbiAgICB3YWxrRGlyKCcuJyk7XG4gICAgdGhpcy50ZXN0RmlsZXMgPSBBcnJheS5mcm9tKHRlc3RGaWxlcykuc29ydCgpO1xuICAgIHJldHVybiB0aGlzLnRlc3RGaWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgYSB0ZXN0IGZpbGUgYmFzZWQgb24gcGF0dGVybnNcbiAgICovXG4gIGlzVGVzdEZpbGUoZmlsZVBhdGgpIHtcbiAgICBjb25zdCB0ZXN0UGF0dGVybnMgPSBbXG4gICAgICAvXFwudGVzdFxcLltqdF1zeD8kLyxcbiAgICAgIC9cXC5zcGVjXFwuW2p0XXN4PyQvLFxuICAgICAgL3Rlc3RcXC8uKlxcLnRlc3RcXC5banRdc3g/JC8sXG4gICAgICAvdGVzdFxcLy4qXFwuc3BlY1xcLltqdF1zeD8kLyxcbiAgICAgIC90ZXN0c1xcLy4qXFwudGVzdFxcLltqdF1zeD8kLyxcbiAgICAgIC90ZXN0c1xcLy4qXFwuc3BlY1xcLltqdF1zeD8kLyxcbiAgICAgIC9fX3Rlc3RzX19cXC8uKlxcLltqdF1zeD8kL1xuICAgIF07XG5cbiAgICAvLyBFeGNsdWRlIHV0aWxpdHkvc2V0dXAgZmlsZXMgdGhhdCBkb24ndCBjb250YWluIGFjdHVhbCB0ZXN0c1xuICAgIGNvbnN0IGV4Y2x1ZGVGaWxlcyA9IFtcbiAgICAgICd0ZXN0U2V0dXAuanMnLFxuICAgICAgJ3JlbG9hZENoZWNrLmpzJywgXG4gICAgICAnd2l0aG91dFNldHVwLmpzJyxcbiAgICAgICdzZXR1cE11bHRpcGxlLmpzJyxcbiAgICAgICdzZXR1cE11bHRpcGxlQ2hpbGQuanMnLFxuICAgICAgJ3NldHVwLnRzJ1xuICAgIF07XG5cbiAgICBpZiAoZXhjbHVkZUZpbGVzLnNvbWUoZXhjbHVkZSA9PiBmaWxlUGF0aC5lbmRzV2l0aChleGNsdWRlKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVzdFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoZmlsZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgSmVzdCB2ZXJzaW9uLWFwcHJvcHJpYXRlIENMSSBmbGFnXG4gICAqL1xuICBnZXRKZXN0VGVzdFBhdGhGbGFnKCkge1xuICAgIGlmICh0aGlzLmplc3RWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUcnkgdG8gZGV0ZWN0IEplc3QgdmVyc2lvbiBzeW5jaHJvbm91c2x5XG4gICAgICAgIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgICAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnLi9ub2RlX21vZHVsZXMvamVzdC9wYWNrYWdlLmpzb24nLCAndXRmOCcpKTtcbiAgICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocGFja2FnZUpzb24udmVyc2lvbi5zcGxpdCgnLicpWzBdKTtcbiAgICAgICAgdGhpcy5qZXN0VmVyc2lvbiA9IG1ham9yVmVyc2lvbjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBEZWZhdWx0IHRvIEplc3QgMzArIGJlaGF2aW9yIChuZXdlciBzdGFuZGFyZCkgaWYgdmVyc2lvbiBjaGVjayBmYWlsc1xuICAgICAgICB0aGlzLmplc3RWZXJzaW9uID0gMzA7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEplc3QgMzArIHVzZXMgLS10ZXN0UGF0aFBhdHRlcm5zLCBlYXJsaWVyIHZlcnNpb25zIHVzZSAtLXRlc3RQYXRoUGF0dGVyblxuICAgIHJldHVybiB0aGlzLmplc3RWZXJzaW9uID49IDMwID8gJy0tdGVzdFBhdGhQYXR0ZXJucycgOiAnLS10ZXN0UGF0aFBhdHRlcm4nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSB0ZXN0IGZpbGUgd2l0aCBvcHRpbWl6ZWQgTm9kZS5qcyBwZXJmb3JtYW5jZSBmbGFnc1xuICAgKi9cbiAgYXN5bmMgcnVuVGVzdEZpbGUodGVzdEZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBsZXQgc3Rkb3V0ID0gJyc7XG4gICAgICBsZXQgc3RkZXJyID0gJyc7XG5cbiAgICAgIC8vIERldGVybWluZSBpZiB0aGlzIGlzIGEgSmVzdC9Ob2RlIHRlc3QgYmFzZWQgb24gZmlsZSBjb250ZW50XG4gICAgICBjb25zdCBpc0plc3RUZXN0ID0gdGhpcy5zaG91bGRVc2VKZXN0KHRlc3RGaWxlKTtcbiAgICAgIFxuICAgICAgY29uc3QgY29tbWFuZCA9IGlzSmVzdFRlc3QgPyAnbnB4JyA6ICdub2RlJztcbiAgICAgIGNvbnN0IHRlc3RQYXRoRmxhZyA9IGlzSmVzdFRlc3QgPyB0aGlzLmdldEplc3RUZXN0UGF0aEZsYWcoKSA6IG51bGw7XG4gICAgICBcbiAgICAgIC8vIEJhbGFuY2VkIGFyZ3VtZW50cyBmb3Igc3BlZWQgKyBzdGFiaWxpdHlcbiAgICAgIGNvbnN0IGJhc2VBcmdzID0gaXNKZXN0VGVzdCBcbiAgICAgICAgPyBbJ2plc3QnLCB0ZXN0UGF0aEZsYWcsIHRlc3RGaWxlLCAnLS1uby1jb3ZlcmFnZScsICctLWNhY2hlJ10gXG4gICAgICAgIDogWyctLW1heC1vbGQtc3BhY2Utc2l6ZT03NjgnLCAnLS1uby13YXJuaW5ncycsIHRlc3RGaWxlXTtcbiAgICAgIFxuICAgICAgY29uc3QgYXJncyA9IGlzSmVzdFRlc3QgPyBiYXNlQXJncyA6IGJhc2VBcmdzO1xuXG4gICAgICBjb25zdCBjaGlsZCA9IHNwYXduKGNvbW1hbmQsIGFyZ3MsIHtcbiAgICAgICAgc3RkaW86IFsnaWdub3JlJywgJ3BpcGUnLCAncGlwZSddLFxuICAgICAgICBlbnY6IHsgXG4gICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsIFxuICAgICAgICAgIE5PREVfRU5WOiAndGVzdCcsXG4gICAgICAgICAgTk9ERV9PUFRJT05TOiAnLS1tYXgtb2xkLXNwYWNlLXNpemU9NTEyIC0tbm8td2FybmluZ3MnIC8vIE1lbW9yeSBvcHRpbWl6YXRpb25cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZG91dCArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgc3RkZXJyICs9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjaGlsZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIFxuICAgICAgICAvLyBSb2J1c3Qgc3VjY2VzcyBkZXRlY3Rpb24gZm9yIGJvdGggSmVzdCBhbmQgcXRlc3RzL05vZGUuanMgZm9ybWF0c1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBzdGRvdXQgKyBzdGRlcnI7XG4gICAgICAgIFxuICAgICAgICAvLyBKZXN0IHNob3dzIFBBU1Mgd2hlbiB0ZXN0cyBzdWNjZWVkLCBGQUlMIHdoZW4gdGhleSBmYWlsXG4gICAgICAgIGNvbnN0IGhhc1BBU1MgPSBvdXRwdXQuaW5jbHVkZXMoJ1BBU1MgJyk7XG4gICAgICAgIGNvbnN0IGhhc0ZBSUwgPSBvdXRwdXQuaW5jbHVkZXMoJ0ZBSUwgJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBxdGVzdHMvTm9kZS5qcyBmb3JtYXQgdXNlcyBleGl0IGNvZGVzIGFuZCBub3JtYWwgb3V0cHV0IChubyB1bmNhdWdodCBleGNlcHRpb25zKVxuICAgICAgICBjb25zdCBoYXNVbmNhdWdodEV4Y2VwdGlvbiA9IG91dHB1dC5pbmNsdWRlcygnRXJyb3I6JykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmNsdWRlcygnUmVmZXJlbmNlRXJyb3I6JykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmNsdWRlcygnVHlwZUVycm9yOicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5jbHVkZXMoJ1N5bnRheEVycm9yOicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZGVyci5pbmNsdWRlcygnRXJyb3I6JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RkZXJyLmluY2x1ZGVzKCdhdCAnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvciBkZWJ1Z2dpbmcgLSBsb2cgd2hhdCB3ZSdyZSBzZWVpbmdcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHX1RFU1RTKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFxcbkZpbGU6ICR7dGVzdEZpbGV9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYENvZGU6ICR7Y29kZX0sIFBBU1M6ICR7aGFzUEFTU30sIEZBSUw6ICR7aGFzRkFJTH0sIEV4Y2VwdGlvbjogJHtoYXNVbmNhdWdodEV4Y2VwdGlvbn1gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgT3V0cHV0IHNuaXBwZXQ6IFwiJHtvdXRwdXQuc2xpY2UoMCwgMjAwKX0uLi5cImApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdWNjZXNzIGRldGVjdGlvbiBmb3IgYm90aCBmb3JtYXRzOlxuICAgICAgICAvLyBKZXN0IGZvcm1hdDogUEFTUyBwcmVzZW50IGFuZCBubyBGQUlMXG4gICAgICAgIC8vIHF0ZXN0cy9Ob2RlLmpzIGZvcm1hdDogZXhpdCBjb2RlIDAgYW5kIG5vIHVuY2F1Z2h0IGV4Y2VwdGlvbnNcbiAgICAgICAgY29uc3QgamVzdFN1Y2Nlc3MgPSBoYXNQQVNTICYmICFoYXNGQUlMO1xuICAgICAgICBjb25zdCBxdGVzdHNTdWNjZXNzID0gY29kZSA9PT0gMCAmJiAhaGFzVW5jYXVnaHRFeGNlcHRpb24gJiYgIWhhc0ZBSUw7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzdWNjZXNzID0gamVzdFN1Y2Nlc3MgfHwgKGlzSmVzdFRlc3QgPyBmYWxzZSA6IHF0ZXN0c1N1Y2Nlc3MpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aGlzLnBhc3NlZFRlc3RzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mYWlsZWRUZXN0cysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgZmlsZTogdGVzdEZpbGUsXG4gICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICBvdXRwdXQ6IHN0ZG91dCxcbiAgICAgICAgICBlcnJvcjogc3RkZXJyLFxuICAgICAgICAgIGNvZGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuZmFpbGVkVGVzdHMrKztcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgZmlsZTogdGVzdEZpbGUsXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgb3V0cHV0OiAnJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBjb2RlOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgdGVzdCBzaG91bGQgdXNlIEplc3RcbiAgICovXG4gIHNob3VsZFVzZUplc3QodGVzdEZpbGUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyh0ZXN0RmlsZSwgJ3V0ZjgnKTtcbiAgICAgIC8vIExvb2sgZm9yIEplc3Qtc3BlY2lmaWMgcGF0dGVybnNcbiAgICAgIHJldHVybiAvXFxiKGRlc2NyaWJlfGl0fHRlc3R8ZXhwZWN0fGplc3R8YmVmb3JlRWFjaHxhZnRlckVhY2h8YmVmb3JlQWxsfGFmdGVyQWxsKVxcYi8udGVzdChjb250ZW50KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgdGVzdHMgYnkgc2l6ZSBmb3Igb3B0aW1pemVkIGJhdGNoIGV4ZWN1dGlvblxuICAgKi9cbiAgZ3JvdXBUZXN0c0J5U2l6ZSh0ZXN0RmlsZXMpIHtcbiAgICBjb25zdCB0ZXN0U2l6ZXMgPSB0ZXN0RmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZmlsZSwgc2l6ZTogc3RhdHMuc2l6ZSB9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7IGZpbGUsIHNpemU6IDEwMDAgfTsgLy8gRGVmYXVsdCBzaXplIGZvciBpbmFjY2Vzc2libGUgZmlsZXNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNvcnQgYnkgc2l6ZSAoc21hbGxlc3QgZmlyc3QgZm9yIGZhc3Rlc3QgYmF0Y2hpbmcpXG4gICAgdGVzdFNpemVzLnNvcnQoKGEsIGIpID0+IGEuc2l6ZSAtIGIuc2l6ZSk7XG4gICAgXG4gICAgY29uc3Qgc21hbGwgPSBbXTsgLy8gPCAyS0IgLSBncm91cCB0b2dldGhlciBmb3IgZWZmaWNpZW5jeVxuICAgIGNvbnN0IG1lZGl1bSA9IFtdOyAvLyAyS0IgLSAxMEtCIC0gbW9kZXJhdGUgZ3JvdXBpbmdcbiAgICBjb25zdCBsYXJnZSA9IFtdOyAvLyA+IDEwS0IgLSBydW4gaW5kaXZpZHVhbGx5XG4gICAgXG4gICAgdGVzdFNpemVzLmZvckVhY2goKHsgZmlsZSwgc2l6ZSB9KSA9PiB7XG4gICAgICBpZiAoc2l6ZSA8IDIwMDApIHtcbiAgICAgICAgc21hbGwucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDEwMDAwKSB7XG4gICAgICAgIG1lZGl1bS5wdXNoKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFyZ2UucHVzaChmaWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4geyBzbWFsbCwgbWVkaXVtLCBsYXJnZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0ZXN0cyB3aXRoIGFkdmFuY2VkIHBhcmFsbGVsIGV4ZWN1dGlvbiBhbmQgc21hcnQgZ3JvdXBpbmdcbiAgICogTWFpbnRhaW5zIG1heCBjb25jdXJyZW5jeSBhdCBhbGwgdGltZXMgLSBzdGFydHMgbmV3IHRlc3QgaW1tZWRpYXRlbHkgYXMgb3RoZXJzIGZpbmlzaFxuICAgKi9cbiAgYXN5bmMgcnVuSW5QYXJhbGxlbCh0ZXN0RmlsZXMsIG1heENvbmN1cnJlbmN5KSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHF1ZXVlID0gWy4uLnRlc3RGaWxlc107IC8vIENvcHkgZmlsZXMgdG8gcHJvY2Vzc1xuICAgIGNvbnN0IHJ1bm5pbmcgPSBuZXcgU2V0KCk7IC8vIFRyYWNrIGN1cnJlbnRseSBydW5uaW5nIHRlc3RzXG4gICAgbGV0IGNvbXBsZXRlZCA9IDA7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnROZXh0ID0gKCkgPT4ge1xuICAgICAgICAvLyBTdGFydCBuZXcgdGVzdHMgdXAgdG8gbWF4IGNvbmN1cnJlbmN5XG4gICAgICAgIHdoaWxlIChydW5uaW5nLnNpemUgPCBtYXhDb25jdXJyZW5jeSAmJiBxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgdGVzdEZpbGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJ1blRlc3RGaWxlKHRlc3RGaWxlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBydW5uaW5nLmFkZChwcm9taXNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICBydW5uaW5nLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgaW1tZWRpYXRlbHkgd2hlbiBlYWNoIHRlc3QgY29tcGxldGVzXG4gICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxyJHtjb2xvcnMuZGltfVByb2dyZXNzOiAke2NvbXBsZXRlZH0vJHt0ZXN0RmlsZXMubGVuZ3RofSBmaWxlcyBjb21wbGV0ZWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCB0ZXN0IGltbWVkaWF0ZWx5IGlmIHF1ZXVlIGhhcyBtb3JlXG4gICAgICAgICAgICBzdGFydE5leHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHRlc3RzIGFyZSBkb25lXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0ZXN0RmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCk7IC8vIE5ldyBsaW5lIGFmdGVyIHByb2dyZXNzXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2NvbG9ycy5yZWR9VGVzdCBlcnJvcjoke2NvbG9ycy5yZXNldH1gLCBlcnJvcik7XG4gICAgICAgICAgICBydW5uaW5nLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIG9uZSB0ZXN0IGZhaWxzXG4gICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxyJHtjb2xvcnMuZGltfVByb2dyZXNzOiAke2NvbXBsZXRlZH0vJHt0ZXN0RmlsZXMubGVuZ3RofSBmaWxlcyBjb21wbGV0ZWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgICAgIHN0YXJ0TmV4dCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0ZXN0RmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCk7IC8vIE5ldyBsaW5lIGFmdGVyIHByb2dyZXNzXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFN0YXJ0IGluaXRpYWwgYmF0Y2hcbiAgICAgIHN0YXJ0TmV4dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgdGVzdCByZXN1bHRzIHdpdGggY29sb3JmdWwgb3V0cHV0XG4gICAqL1xuICBkaXNwbGF5UmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLmJyaWdodH3wn5OKIFRlc3QgUmVzdWx0cyBTdW1tYXJ5JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX0keyc9Jy5yZXBlYXQoNTApfSR7Y29sb3JzLnJlc2V0fWApO1xuXG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcblxuICAgIC8vIFN1bW1hcnkgc3RhdHNcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZ3JlZW594pyFIFBhc3NlZDogJHt0aGlzLnBhc3NlZFRlc3RzfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5yZWR94p2MIEZhaWxlZDogJHt0aGlzLmZhaWxlZFRlc3RzfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5ibHVlffCfk4EgVG90YWwgRmlsZXM6ICR7cmVzdWx0cy5sZW5ndGh9JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmN5YW594o+x77iPICBEdXJhdGlvbjogJHt0b3RhbER1cmF0aW9ufW1zJHtjb2xvcnMucmVzZXR9XFxuYCk7XG5cbiAgICAvLyBTaG93IGZhaWxlZCB0ZXN0cyB3aXRoIGRldGFpbHNcbiAgICBjb25zdCBmYWlsZWRSZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICBpZiAoZmFpbGVkUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMucmVkfSR7Y29sb3JzLmJyaWdodH1GYWlsZWQgVGVzdHM6JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICBmYWlsZWRSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLnJlZH3inYwgJHtyZXN1bHQuZmlsZX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19JHtyZXN1bHQuZXJyb3Iuc3BsaXQoJ1xcbicpLnNsaWNlKDAsIDUpLmpvaW4oJ1xcbicpfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gR2VuZXJhdGUgZGVidWcgZmlsZSBmb3IgZmFpbGVkIHRlc3RzXG4gICAgICB0aGlzLmdlbmVyYXRlRGVidWdGaWxlKGZhaWxlZFJlc3VsdHMpO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1hbmNlIHN1bW1hcnlcbiAgICBjb25zdCBhdmdEdXJhdGlvbiA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLmRpbX1BdmVyYWdlIHRlc3QgZHVyYXRpb246ICR7TWF0aC5yb3VuZChhdmdEdXJhdGlvbil9bXMke2NvbG9ycy5yZXNldH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBERUJVR19URVNUUy5tZCBmaWxlIGZvciBmYWlsZWQgdGVzdCBhbmFseXNpc1xuICAgKi9cbiAgZ2VuZXJhdGVEZWJ1Z0ZpbGUoZmFpbGVkUmVzdWx0cykge1xuICAgIGlmIChmYWlsZWRSZXN1bHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgY3JlYXRpb25UaW1lID0gbm93LnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgcGFjaWZpY1RpbWUgPSBub3cudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgeyBcbiAgICAgIHRpbWVab25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycsXG4gICAgICB3ZWVrZGF5OiAnbG9uZycsXG4gICAgICB5ZWFyOiAnbnVtZXJpYycsIFxuICAgICAgbW9udGg6ICdsb25nJywgXG4gICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgIGhvdXI6ICcyLWRpZ2l0JywgXG4gICAgICBtaW51dGU6ICcyLWRpZ2l0JywgXG4gICAgICBzZWNvbmQ6ICcyLWRpZ2l0JyxcbiAgICAgIHRpbWVab25lTmFtZTogJ3Nob3J0J1xuICAgIH0pO1xuICAgIFxuICAgIGxldCBkZWJ1Z0NvbnRlbnQgPSAnIyBUZXN0IEZhaWx1cmUgQW5hbHlzaXNcXG5cXG4nO1xuICAgIGRlYnVnQ29udGVudCArPSBgKipDcmVhdGlvbiBUaW1lOioqICR7Y3JlYXRpb25UaW1lfVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAqKlBhY2lmaWMgVGltZToqKiAke3BhY2lmaWNUaW1lfVxcblxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9ICfimqDvuI8gKipTVEFMRU5FU1MgV0FSTklORzoqKiBJZiB5b3VyIGNvZGUgY2hhbmdlcyBhcmUgYWZ0ZXIgdGhlIGNyZWF0aW9uIHRpbWUgYWJvdmUgYW5kIHlvdSBhcmUgY2hlY2tpbmcgdGhpcyBmaWxlLCB0aGVuIGl0IGlzIHN0YWxlIGFuZCB0ZXN0cyBuZWVkIHRvIGJlIHJlcnVuLlxcblxcbic7XG4gICAgZGVidWdDb250ZW50ICs9ICdBbmFseXplIGFuZCBhZGRyZXNzIHRoZSBmb2xsb3dpbmcgdGVzdCBmYWlsdXJlczpcXG5cXG4nO1xuICAgIFxuICAgIGZhaWxlZFJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgZGVidWdDb250ZW50ICs9IGAjIyBGYWlsZWQgVGVzdCAke2luZGV4ICsgMX06ICR7cmVzdWx0LmZpbGV9XFxuXFxuYDtcbiAgICAgIGRlYnVnQ29udGVudCArPSAnIyMjIE91dHB1dDpcXG4nO1xuICAgICAgZGVidWdDb250ZW50ICs9ICdgYGBcXG4nO1xuICAgICAgZGVidWdDb250ZW50ICs9IHJlc3VsdC5lcnJvciB8fCByZXN1bHQub3V0cHV0IHx8ICdObyBlcnJvciBvdXRwdXQgYXZhaWxhYmxlJztcbiAgICAgIGRlYnVnQ29udGVudCArPSAnXFxuYGBgXFxuXFxuJztcbiAgICAgIGRlYnVnQ29udGVudCArPSBgIyMjIER1cmF0aW9uOiAke3Jlc3VsdC5kdXJhdGlvbn1tc1xcblxcbmA7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gJy0tLVxcblxcbic7XG4gICAgfSk7XG4gICAgXG4gICAgZGVidWdDb250ZW50ICs9ICcjIyBTdW1tYXJ5XFxuXFxuJztcbiAgICBkZWJ1Z0NvbnRlbnQgKz0gYC0gVG90YWwgZmFpbGVkIHRlc3RzOiAke2ZhaWxlZFJlc3VsdHMubGVuZ3RofVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIEZhaWxlZCB0ZXN0IGZpbGVzOiAke2ZhaWxlZFJlc3VsdHMubWFwKHIgPT4gci5maWxlKS5qb2luKCcsICcpfVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIEdlbmVyYXRlZDogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XFxuYDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgZnMud3JpdGVGaWxlU3luYygnREVCVUdfVEVTVFMubWQnLCBkZWJ1Z0NvbnRlbnQpO1xuICAgICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLnllbGxvd33wn5OLIERlYnVnIGZpbGUgY3JlYXRlZDogREVCVUdfVEVTVFMubWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnJlZH3imqDvuI8gIENvdWxkIG5vdCBjcmVhdGUgREVCVUdfVEVTVFMubWQ6ICR7ZXJyb3IubWVzc2FnZX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBleGVjdXRpb24gbWV0aG9kXG4gICAqL1xuICBhc3luYyBydW4oKSB7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmJyaWdodH3wn6eqIHF0ZXN0cyBUZXN0IFJ1bm5lciAtIFBhcmFsbGVsIE1vZGUke2NvbG9ycy5yZXNldH1gKTtcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfURpc2NvdmVyaW5nIGFuZCBydW5uaW5nIGFsbCB0ZXN0cy4uLiR7Y29sb3JzLnJlc2V0fVxcbmApO1xuXG4gICAgLy8gRGlzY292ZXIgYWxsIHRlc3QgZmlsZXNcbiAgICBjb25zdCB0ZXN0RmlsZXMgPSB0aGlzLmRpc2NvdmVyVGVzdHMoKTtcbiAgICBcbiAgICBpZiAodGVzdEZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnllbGxvd33imqDvuI8gIE5vIHRlc3QgZmlsZXMgZm91bmQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19TG9va2luZyBmb3IgZmlsZXMgbWF0Y2hpbmc6ICoudGVzdC5qcywgKi5zcGVjLmpzLCB0ZXN0LyosIHRlc3RzLyosIF9fdGVzdHNfXy8qJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmJsdWV9Rm91bmQgJHt0ZXN0RmlsZXMubGVuZ3RofSB0ZXN0IGZpbGUocyk6JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgdGVzdEZpbGVzLmZvckVhY2goZmlsZSA9PiBjb25zb2xlLmxvZyhgICAke2NvbG9ycy5kaW194oCiJHtjb2xvcnMucmVzZXR9ICR7ZmlsZX1gKSk7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLm1hZ2VudGF98J+agCBSdW5uaW5nIHRlc3RzIGluIHBhcmFsbGVsLi4uJHtjb2xvcnMucmVzZXR9XFxuYCk7XG4gICAgXG4gICAgLy8gQWR2YW5jZWQgY29uY3VycmVuY3kgY2FsY3VsYXRpb24gYmFzZWQgb24gc3lzdGVtIHJlc291cmNlcyBhbmQgbWVtb3J5IG9wdGltaXphdGlvblxuICAgIGNvbnN0IGNwdUNvdW50ID0gb3MuY3B1cygpLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbE1lbW9yeUdCID0gTWF0aC5yb3VuZChvcy50b3RhbG1lbSgpIC8gKDEwMjQgKiogMykpO1xuICAgIFxuICAgIC8vIENvbnNlcnZhdGl2ZSBvcHRpbWl6YXRpb246IGF2b2lkIEVBR0FJTiByZXNvdXJjZSBleGhhdXN0aW9uXG4gICAgY29uc3QgbWVtb3J5QmFzZWRNYXggPSBNYXRoLmZsb29yKHRvdGFsTWVtb3J5R0IgLyAxLjUpOyAvLyAxLjVHQiBwZXIgd29ya2VyIGZvciBzdGFiaWxpdHlcbiAgICBjb25zdCBjcHVCYXNlZE1heCA9IGNwdUNvdW50ICogMi4yNTsgLy8gMi4yNXggY29yZXMgKG1vZGVzdCBpbmNyZWFzZSBmcm9tIDJ4KVxuICAgIGNvbnN0IG1heENvbmN1cnJlbmN5ID0gTWF0aC5taW4odGVzdEZpbGVzLmxlbmd0aCwgTWF0aC5tYXgoOCwgY3B1QmFzZWRNYXgpLCBtZW1vcnlCYXNlZE1heCwgMTgpOyAvLyBNYXggMTggdG8gYXZvaWQgc3Bhd24gbGltaXRzXG4gICAgXG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX1NYXggY29uY3VycmVuY3k6ICR7bWF4Q29uY3VycmVuY3l9IHdvcmtlcnMgKCR7Y3B1Q291bnR9IENQVSBjb3JlcywgJHt0b3RhbE1lbW9yeUdCfUdCIFJBTSkke2NvbG9ycy5yZXNldH1cXG5gKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5ydW5JblBhcmFsbGVsKHRlc3RGaWxlcywgbWF4Q29uY3VycmVuY3kpO1xuICAgIHRoaXMucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgXG4gICAgLy8gRGlzcGxheSBjb21wcmVoZW5zaXZlIHJlc3VsdHNcbiAgICB0aGlzLmRpc3BsYXlSZXN1bHRzKHJlc3VsdHMpO1xuICAgIFxuICAgIC8vIEV4aXQgd2l0aCBhcHByb3ByaWF0ZSBjb2RlXG4gICAgcHJvY2Vzcy5leGl0KHRoaXMuZmFpbGVkVGVzdHMgPiAwID8gMSA6IDApO1xuICB9XG59XG5cbi8vIFJ1biB0aGUgdGVzdCBzdWl0ZVxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIGNvbnN0IHJ1bm5lciA9IG5ldyBUZXN0UnVubmVyKCk7XG4gIHJ1bm5lci5ydW4oKS5jYXRjaChlcnJvciA9PiB7XG4gICAgY29uc29sZS5lcnJvcihgJHtjb2xvcnMucmVkfVRlc3QgcnVubmVyIGVycm9yOiR7Y29sb3JzLnJlc2V0fWAsIGVycm9yKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlc3RSdW5uZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQSxFQUFFLEdBQUdDLE9BQU8sQ0FBQyxJQUFJLENBQUM7QUFDeEIsTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQU07RUFBRUU7QUFBTSxDQUFDLEdBQUdGLE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFDMUMsTUFBTUcsRUFBRSxHQUFHSCxPQUFPLENBQUMsSUFBSSxDQUFDOztBQUV4QjtBQUNBLE1BQU1JLE1BQU0sR0FBRztFQUNiQyxLQUFLLEVBQUUsU0FBUztFQUNoQkMsTUFBTSxFQUFFLFNBQVM7RUFDakJDLEdBQUcsRUFBRSxTQUFTO0VBQ2RDLEdBQUcsRUFBRSxVQUFVO0VBQ2ZDLEtBQUssRUFBRSxVQUFVO0VBQ2pCQyxNQUFNLEVBQUUsVUFBVTtFQUNsQkMsSUFBSSxFQUFFLFVBQVU7RUFDaEJDLE9BQU8sRUFBRSxVQUFVO0VBQ25CQyxJQUFJLEVBQUUsVUFBVTtFQUNoQkMsS0FBSyxFQUFFO0FBQ1QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLFVBQVUsQ0FBQztFQUNmQyxXQUFXQSxDQUFBLEVBQUc7SUFDWixJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO0lBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHLENBQUM7SUFDcEIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsQ0FBQztJQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO0lBQ25CLElBQUksQ0FBQ0MsU0FBUyxHQUFHQyxJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDO0lBQzNCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7SUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSTtFQUN6Qjs7RUFFQTtBQUNGO0FBQ0E7RUFDRUMsYUFBYUEsQ0FBQSxFQUFHO0lBQ2QsTUFBTUMsWUFBWSxHQUFHLENBQ25CLGNBQWMsRUFDZCxjQUFjLEVBQ2QsZUFBZSxFQUNmLGVBQWUsRUFDZixpQkFBaUIsRUFDakIsaUJBQWlCLEVBQ2pCLGtCQUFrQixFQUNsQixrQkFBa0IsRUFDbEIsc0JBQXNCLEVBQ3RCLHNCQUFzQixDQUN2QjtJQUVELE1BQU1DLGVBQWUsR0FBRyxDQUN0QixjQUFjLEVBQ2QsTUFBTSxFQUNOLFVBQVUsRUFDVixNQUFNLEVBQ04sT0FBTyxFQUNQLFFBQVEsRUFDUixhQUFhLEVBQ2IsTUFBTTtJQUFTO0lBQ2YsVUFBVTtJQUFLO0lBQ2YsTUFBTTtJQUFTO0lBQ2YsT0FBTyxDQUFRO0lBQUEsQ0FDaEI7SUFFRCxNQUFNWCxTQUFTLEdBQUcsSUFBSVksR0FBRyxDQUFDLENBQUM7SUFFM0IsTUFBTUMsT0FBTyxHQUFJQyxHQUFHLElBQUs7TUFDdkIsSUFBSSxDQUFDaEMsRUFBRSxDQUFDaUMsVUFBVSxDQUFDRCxHQUFHLENBQUMsRUFBRTtNQUV6QixJQUFJO1FBQ0YsTUFBTUUsS0FBSyxHQUFHbEMsRUFBRSxDQUFDbUMsV0FBVyxDQUFDSCxHQUFHLEVBQUU7VUFBRUksYUFBYSxFQUFFO1FBQUssQ0FBQyxDQUFDO1FBRTFELEtBQUssTUFBTUMsSUFBSSxJQUFJSCxLQUFLLEVBQUU7VUFDeEIsSUFBSUcsSUFBSSxDQUFDQyxJQUFJLENBQUNDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtVQUMvQixJQUFJVixlQUFlLENBQUNXLFFBQVEsQ0FBQ0gsSUFBSSxDQUFDQyxJQUFJLENBQUMsRUFBRTtVQUV6QyxNQUFNRyxRQUFRLEdBQUd2QyxJQUFJLENBQUN3QyxJQUFJLENBQUNWLEdBQUcsRUFBRUssSUFBSSxDQUFDQyxJQUFJLENBQUM7VUFDMUMsTUFBTUssWUFBWSxHQUFHekMsSUFBSSxDQUFDMEMsUUFBUSxDQUFDLEdBQUcsRUFBRUgsUUFBUSxDQUFDOztVQUVqRDtVQUNBLElBQUlaLGVBQWUsQ0FBQ2dCLElBQUksQ0FBQ0MsT0FBTyxJQUFJSCxZQUFZLENBQUNILFFBQVEsQ0FBQ00sT0FBTyxDQUFDLENBQUMsRUFBRTtVQUVyRSxJQUFJVCxJQUFJLENBQUNVLFdBQVcsQ0FBQyxDQUFDLEVBQUU7WUFDdEJoQixPQUFPLENBQUNVLFFBQVEsQ0FBQztVQUNuQixDQUFDLE1BQU0sSUFBSUosSUFBSSxDQUFDVyxNQUFNLENBQUMsQ0FBQyxFQUFFO1lBQ3hCO1lBQ0EsSUFBSSxJQUFJLENBQUNDLFVBQVUsQ0FBQ04sWUFBWSxDQUFDLEVBQUU7Y0FDakN6QixTQUFTLENBQUNnQyxHQUFHLENBQUNQLFlBQVksQ0FBQztZQUM3QjtVQUNGO1FBQ0Y7TUFDRixDQUFDLENBQUMsT0FBT1EsS0FBSyxFQUFFO1FBQ2Q7TUFBQTtJQUVKLENBQUM7SUFFRHBCLE9BQU8sQ0FBQyxHQUFHLENBQUM7SUFDWixJQUFJLENBQUNiLFNBQVMsR0FBR2tDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDbkMsU0FBUyxDQUFDLENBQUNvQyxJQUFJLENBQUMsQ0FBQztJQUM3QyxPQUFPLElBQUksQ0FBQ3BDLFNBQVM7RUFDdkI7O0VBRUE7QUFDRjtBQUNBO0VBQ0UrQixVQUFVQSxDQUFDTSxRQUFRLEVBQUU7SUFDbkIsTUFBTTNCLFlBQVksR0FBRyxDQUNuQixrQkFBa0IsRUFDbEIsa0JBQWtCLEVBQ2xCLDBCQUEwQixFQUMxQiwwQkFBMEIsRUFDMUIsMkJBQTJCLEVBQzNCLDJCQUEyQixFQUMzQix5QkFBeUIsQ0FDMUI7O0lBRUQ7SUFDQSxNQUFNNEIsWUFBWSxHQUFHLENBQ25CLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsaUJBQWlCLEVBQ2pCLGtCQUFrQixFQUNsQix1QkFBdUIsRUFDdkIsVUFBVSxDQUNYO0lBRUQsSUFBSUEsWUFBWSxDQUFDWCxJQUFJLENBQUNZLE9BQU8sSUFBSUYsUUFBUSxDQUFDRyxRQUFRLENBQUNELE9BQU8sQ0FBQyxDQUFDLEVBQUU7TUFDNUQsT0FBTyxLQUFLO0lBQ2Q7SUFFQSxPQUFPN0IsWUFBWSxDQUFDaUIsSUFBSSxDQUFDQyxPQUFPLElBQUlBLE9BQU8sQ0FBQ2EsSUFBSSxDQUFDSixRQUFRLENBQUMsQ0FBQztFQUM3RDs7RUFFQTtBQUNGO0FBQ0E7RUFDRUssbUJBQW1CQSxDQUFBLEVBQUc7SUFDcEIsSUFBSSxJQUFJLENBQUNsQyxXQUFXLEtBQUssSUFBSSxFQUFFO01BQzdCLElBQUk7UUFDRjtRQUNBLE1BQU0xQixFQUFFLEdBQUdDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDeEIsTUFBTTRELFdBQVcsR0FBR0MsSUFBSSxDQUFDQyxLQUFLLENBQUMvRCxFQUFFLENBQUNnRSxZQUFZLENBQUMsa0NBQWtDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDM0YsTUFBTUMsWUFBWSxHQUFHQyxRQUFRLENBQUNMLFdBQVcsQ0FBQ00sT0FBTyxDQUFDQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDMUMsV0FBVyxHQUFHdUMsWUFBWTtNQUNqQyxDQUFDLENBQUMsTUFBTTtRQUNOO1FBQ0EsSUFBSSxDQUFDdkMsV0FBVyxHQUFHLEVBQUU7TUFDdkI7SUFDRjs7SUFFQTtJQUNBLE9BQU8sSUFBSSxDQUFDQSxXQUFXLElBQUksRUFBRSxHQUFHLG9CQUFvQixHQUFHLG1CQUFtQjtFQUM1RTs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxNQUFNMkMsV0FBV0EsQ0FBQ0MsUUFBUSxFQUFFO0lBQzFCLE9BQU8sSUFBSUMsT0FBTyxDQUFFQyxPQUFPLElBQUs7TUFDOUIsTUFBTWxELFNBQVMsR0FBR0MsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQztNQUM1QixJQUFJaUQsTUFBTSxHQUFHLEVBQUU7TUFDZixJQUFJQyxNQUFNLEdBQUcsRUFBRTs7TUFFZjtNQUNBLE1BQU1DLFVBQVUsR0FBRyxJQUFJLENBQUNDLGFBQWEsQ0FBQ04sUUFBUSxDQUFDO01BRS9DLE1BQU1PLE9BQU8sR0FBR0YsVUFBVSxHQUFHLEtBQUssR0FBRyxNQUFNO01BQzNDLE1BQU1HLFlBQVksR0FBR0gsVUFBVSxHQUFHLElBQUksQ0FBQ2YsbUJBQW1CLENBQUMsQ0FBQyxHQUFHLElBQUk7O01BRW5FO01BQ0EsTUFBTW1CLFFBQVEsR0FBR0osVUFBVSxHQUN2QixDQUFDLE1BQU0sRUFBRUcsWUFBWSxFQUFFUixRQUFRLEVBQUUsZUFBZSxFQUFFLFNBQVMsQ0FBQyxHQUM1RCxDQUFDLDBCQUEwQixFQUFFLGVBQWUsRUFBRUEsUUFBUSxDQUFDO01BRTNELE1BQU1VLElBQUksR0FBR0wsVUFBVSxHQUFHSSxRQUFRLEdBQUdBLFFBQVE7TUFFN0MsTUFBTUUsS0FBSyxHQUFHOUUsS0FBSyxDQUFDMEUsT0FBTyxFQUFFRyxJQUFJLEVBQUU7UUFDakNFLEtBQUssRUFBRSxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ2pDQyxHQUFHLEVBQUU7VUFDSCxHQUFHQyxPQUFPLENBQUNELEdBQUc7VUFDZEUsUUFBUSxFQUFFLE1BQU07VUFDaEJDLFlBQVksRUFBRSx3Q0FBd0MsQ0FBQztRQUN6RDtNQUNGLENBQUMsQ0FBQztNQUVGTCxLQUFLLENBQUNSLE1BQU0sQ0FBQ2MsRUFBRSxDQUFDLE1BQU0sRUFBR0MsSUFBSSxJQUFLO1FBQ2hDZixNQUFNLElBQUllLElBQUksQ0FBQ0MsUUFBUSxDQUFDLENBQUM7TUFDM0IsQ0FBQyxDQUFDO01BRUZSLEtBQUssQ0FBQ1AsTUFBTSxDQUFDYSxFQUFFLENBQUMsTUFBTSxFQUFHQyxJQUFJLElBQUs7UUFDaENkLE1BQU0sSUFBSWMsSUFBSSxDQUFDQyxRQUFRLENBQUMsQ0FBQztNQUMzQixDQUFDLENBQUM7TUFFRlIsS0FBSyxDQUFDTSxFQUFFLENBQUMsT0FBTyxFQUFHRyxJQUFJLElBQUs7UUFDMUIsTUFBTUMsUUFBUSxHQUFHcEUsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQyxHQUFHRixTQUFTOztRQUV2QztRQUNBLE1BQU1zRSxNQUFNLEdBQUduQixNQUFNLEdBQUdDLE1BQU07O1FBRTlCO1FBQ0EsTUFBTW1CLE9BQU8sR0FBR0QsTUFBTSxDQUFDcEQsUUFBUSxDQUFDLE9BQU8sQ0FBQztRQUN4QyxNQUFNc0QsT0FBTyxHQUFHRixNQUFNLENBQUNwRCxRQUFRLENBQUMsT0FBTyxDQUFDOztRQUV4QztRQUNBLE1BQU11RCxvQkFBb0IsR0FBR0gsTUFBTSxDQUFDcEQsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUMzQm9ELE1BQU0sQ0FBQ3BELFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxJQUNsQ29ELE1BQU0sQ0FBQ3BELFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFDN0JvRCxNQUFNLENBQUNwRCxRQUFRLENBQUMsY0FBYyxDQUFDLElBQy9Ca0MsTUFBTSxDQUFDbEMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUN6QmtDLE1BQU0sQ0FBQ2xDLFFBQVEsQ0FBQyxLQUFLLENBQUM7O1FBRWpEO1FBQ0EsSUFBSTRDLE9BQU8sQ0FBQ0QsR0FBRyxDQUFDYSxXQUFXLEVBQUU7VUFDM0JDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLFdBQVc1QixRQUFRLEVBQUUsQ0FBQztVQUNsQzJCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLFNBQVNSLElBQUksV0FBV0csT0FBTyxXQUFXQyxPQUFPLGdCQUFnQkMsb0JBQW9CLEVBQUUsQ0FBQztVQUNwR0UsT0FBTyxDQUFDQyxHQUFHLENBQUMsb0JBQW9CTixNQUFNLENBQUNPLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQztRQUM3RDs7UUFFQTtRQUNBO1FBQ0E7UUFDQSxNQUFNQyxXQUFXLEdBQUdQLE9BQU8sSUFBSSxDQUFDQyxPQUFPO1FBQ3ZDLE1BQU1PLGFBQWEsR0FBR1gsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDSyxvQkFBb0IsSUFBSSxDQUFDRCxPQUFPO1FBRXJFLE1BQU1RLE9BQU8sR0FBR0YsV0FBVyxLQUFLekIsVUFBVSxHQUFHLEtBQUssR0FBRzBCLGFBQWEsQ0FBQztRQUVuRSxJQUFJQyxPQUFPLEVBQUU7VUFDWCxJQUFJLENBQUNuRixXQUFXLEVBQUU7UUFDcEIsQ0FBQyxNQUFNO1VBQ0wsSUFBSSxDQUFDQyxXQUFXLEVBQUU7UUFDcEI7UUFFQW9ELE9BQU8sQ0FBQztVQUNOK0IsSUFBSSxFQUFFakMsUUFBUTtVQUNkZ0MsT0FBTztVQUNQWCxRQUFRO1VBQ1JDLE1BQU0sRUFBRW5CLE1BQU07VUFDZHRCLEtBQUssRUFBRXVCLE1BQU07VUFDYmdCO1FBQ0YsQ0FBQyxDQUFDO01BQ0osQ0FBQyxDQUFDO01BRUZULEtBQUssQ0FBQ00sRUFBRSxDQUFDLE9BQU8sRUFBR3BDLEtBQUssSUFBSztRQUMzQixJQUFJLENBQUMvQixXQUFXLEVBQUU7UUFDbEJvRCxPQUFPLENBQUM7VUFDTitCLElBQUksRUFBRWpDLFFBQVE7VUFDZGdDLE9BQU8sRUFBRSxLQUFLO1VBQ2RYLFFBQVEsRUFBRXBFLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsR0FBR0YsU0FBUztVQUNoQ3NFLE1BQU0sRUFBRSxFQUFFO1VBQ1Z6QyxLQUFLLEVBQUVBLEtBQUssQ0FBQ3FELE9BQU87VUFDcEJkLElBQUksRUFBRTtRQUNSLENBQUMsQ0FBQztNQUNKLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztFQUNKOztFQUVBO0FBQ0Y7QUFDQTtFQUNFZCxhQUFhQSxDQUFDTixRQUFRLEVBQUU7SUFDdEIsSUFBSTtNQUNGLE1BQU1tQyxPQUFPLEdBQUd6RyxFQUFFLENBQUNnRSxZQUFZLENBQUNNLFFBQVEsRUFBRSxNQUFNLENBQUM7TUFDakQ7TUFDQSxPQUFPLDRFQUE0RSxDQUFDWCxJQUFJLENBQUM4QyxPQUFPLENBQUM7SUFDbkcsQ0FBQyxDQUFDLE1BQU07TUFDTixPQUFPLEtBQUs7SUFDZDtFQUNGOztFQUVBO0FBQ0Y7QUFDQTtFQUNFQyxnQkFBZ0JBLENBQUN4RixTQUFTLEVBQUU7SUFDMUIsTUFBTXlGLFNBQVMsR0FBR3pGLFNBQVMsQ0FBQzBGLEdBQUcsQ0FBQ0wsSUFBSSxJQUFJO01BQ3RDLElBQUk7UUFDRixNQUFNTSxLQUFLLEdBQUc3RyxFQUFFLENBQUM4RyxRQUFRLENBQUNQLElBQUksQ0FBQztRQUMvQixPQUFPO1VBQUVBLElBQUk7VUFBRVEsSUFBSSxFQUFFRixLQUFLLENBQUNFO1FBQUssQ0FBQztNQUNuQyxDQUFDLENBQUMsTUFBTTtRQUNOLE9BQU87VUFBRVIsSUFBSTtVQUFFUSxJQUFJLEVBQUU7UUFBSyxDQUFDLENBQUMsQ0FBQztNQUMvQjtJQUNGLENBQUMsQ0FBQzs7SUFFRjtJQUNBSixTQUFTLENBQUNyRCxJQUFJLENBQUMsQ0FBQzBELENBQUMsRUFBRUMsQ0FBQyxLQUFLRCxDQUFDLENBQUNELElBQUksR0FBR0UsQ0FBQyxDQUFDRixJQUFJLENBQUM7SUFFekMsTUFBTUcsS0FBSyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ2xCLE1BQU1DLE1BQU0sR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNuQixNQUFNQyxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUM7O0lBRWxCVCxTQUFTLENBQUNVLE9BQU8sQ0FBQyxDQUFDO01BQUVkLElBQUk7TUFBRVE7SUFBSyxDQUFDLEtBQUs7TUFDcEMsSUFBSUEsSUFBSSxHQUFHLElBQUksRUFBRTtRQUNmRyxLQUFLLENBQUNJLElBQUksQ0FBQ2YsSUFBSSxDQUFDO01BQ2xCLENBQUMsTUFBTSxJQUFJUSxJQUFJLEdBQUcsS0FBSyxFQUFFO1FBQ3ZCSSxNQUFNLENBQUNHLElBQUksQ0FBQ2YsSUFBSSxDQUFDO01BQ25CLENBQUMsTUFBTTtRQUNMYSxLQUFLLENBQUNFLElBQUksQ0FBQ2YsSUFBSSxDQUFDO01BQ2xCO0lBQ0YsQ0FBQyxDQUFDO0lBRUYsT0FBTztNQUFFVyxLQUFLO01BQUVDLE1BQU07TUFBRUM7SUFBTSxDQUFDO0VBQ2pDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsTUFBTUcsYUFBYUEsQ0FBQ3JHLFNBQVMsRUFBRXNHLGNBQWMsRUFBRTtJQUM3QyxNQUFNL0YsT0FBTyxHQUFHLEVBQUU7SUFDbEIsTUFBTWdHLEtBQUssR0FBRyxDQUFDLEdBQUd2RyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQzlCLE1BQU13RyxPQUFPLEdBQUcsSUFBSTVGLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixJQUFJNkYsU0FBUyxHQUFHLENBQUM7SUFFakIsT0FBTyxJQUFJcEQsT0FBTyxDQUFDLENBQUNDLE9BQU8sRUFBRW9ELE1BQU0sS0FBSztNQUN0QyxNQUFNQyxTQUFTLEdBQUdBLENBQUEsS0FBTTtRQUN0QjtRQUNBLE9BQU9ILE9BQU8sQ0FBQ1gsSUFBSSxHQUFHUyxjQUFjLElBQUlDLEtBQUssQ0FBQ0ssTUFBTSxHQUFHLENBQUMsRUFBRTtVQUN4RCxNQUFNeEQsUUFBUSxHQUFHbUQsS0FBSyxDQUFDTSxLQUFLLENBQUMsQ0FBQztVQUM5QixNQUFNQyxPQUFPLEdBQUcsSUFBSSxDQUFDM0QsV0FBVyxDQUFDQyxRQUFRLENBQUM7VUFFMUNvRCxPQUFPLENBQUN4RSxHQUFHLENBQUM4RSxPQUFPLENBQUM7VUFFcEJBLE9BQU8sQ0FBQ0MsSUFBSSxDQUFFQyxNQUFNLElBQUs7WUFDdkJ6RyxPQUFPLENBQUM2RixJQUFJLENBQUNZLE1BQU0sQ0FBQztZQUNwQlIsT0FBTyxDQUFDUyxNQUFNLENBQUNILE9BQU8sQ0FBQztZQUN2QkwsU0FBUyxFQUFFOztZQUVYO1lBQ0F2QyxPQUFPLENBQUNYLE1BQU0sQ0FBQzJELEtBQUssQ0FBQyxLQUFLL0gsTUFBTSxDQUFDRyxHQUFHLGFBQWFtSCxTQUFTLElBQUl6RyxTQUFTLENBQUM0RyxNQUFNLG1CQUFtQnpILE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7O1lBRWhIO1lBQ0F1SCxTQUFTLENBQUMsQ0FBQzs7WUFFWDtZQUNBLElBQUlGLFNBQVMsS0FBS3pHLFNBQVMsQ0FBQzRHLE1BQU0sRUFBRTtjQUNsQzdCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2NBQ2YxQixPQUFPLENBQUMvQyxPQUFPLENBQUM7WUFDbEI7VUFDRixDQUFDLENBQUMsQ0FBQzRHLEtBQUssQ0FBRWxGLEtBQUssSUFBSztZQUNsQjhDLE9BQU8sQ0FBQzlDLEtBQUssQ0FBQyxHQUFHOUMsTUFBTSxDQUFDSSxHQUFHLGNBQWNKLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLEVBQUU2QyxLQUFLLENBQUM7WUFDL0R1RSxPQUFPLENBQUNTLE1BQU0sQ0FBQ0gsT0FBTyxDQUFDO1lBQ3ZCTCxTQUFTLEVBQUU7O1lBRVg7WUFDQXZDLE9BQU8sQ0FBQ1gsTUFBTSxDQUFDMkQsS0FBSyxDQUFDLEtBQUsvSCxNQUFNLENBQUNHLEdBQUcsYUFBYW1ILFNBQVMsSUFBSXpHLFNBQVMsQ0FBQzRHLE1BQU0sbUJBQW1CekgsTUFBTSxDQUFDQyxLQUFLLEVBQUUsQ0FBQztZQUNoSHVILFNBQVMsQ0FBQyxDQUFDO1lBRVgsSUFBSUYsU0FBUyxLQUFLekcsU0FBUyxDQUFDNEcsTUFBTSxFQUFFO2NBQ2xDN0IsT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Y0FDZjFCLE9BQU8sQ0FBQy9DLE9BQU8sQ0FBQztZQUNsQjtVQUNGLENBQUMsQ0FBQztRQUNKO01BQ0YsQ0FBQzs7TUFFRDtNQUNBb0csU0FBUyxDQUFDLENBQUM7SUFDYixDQUFDLENBQUM7RUFDSjs7RUFFQTtBQUNGO0FBQ0E7RUFDRVMsY0FBY0EsQ0FBQzdHLE9BQU8sRUFBRTtJQUN0QndFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEtBQUs3RixNQUFNLENBQUNFLE1BQU0sMEJBQTBCRixNQUFNLENBQUNDLEtBQUssRUFBRSxDQUFDO0lBQ3ZFMkYsT0FBTyxDQUFDQyxHQUFHLENBQUMsR0FBRzdGLE1BQU0sQ0FBQ0csR0FBRyxHQUFHLEdBQUcsQ0FBQytILE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBR2xJLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7SUFFNUQsTUFBTWtJLGFBQWEsR0FBR2pILElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNGLFNBQVM7O0lBRWpEO0lBQ0EyRSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDSyxLQUFLLGFBQWEsSUFBSSxDQUFDUyxXQUFXLEdBQUdkLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7SUFDMUUyRixPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDSSxHQUFHLGFBQWEsSUFBSSxDQUFDVyxXQUFXLEdBQUdmLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7SUFDeEUyRixPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDTyxJQUFJLG1CQUFtQmEsT0FBTyxDQUFDcUcsTUFBTSxHQUFHekgsTUFBTSxDQUFDQyxLQUFLLEVBQUUsQ0FBQztJQUM3RTJGLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEdBQUc3RixNQUFNLENBQUNTLElBQUksaUJBQWlCMEgsYUFBYSxLQUFLbkksTUFBTSxDQUFDQyxLQUFLLElBQUksQ0FBQzs7SUFFOUU7SUFDQSxNQUFNbUksYUFBYSxHQUFHaEgsT0FBTyxDQUFDaUgsTUFBTSxDQUFDQyxDQUFDLElBQUksQ0FBQ0EsQ0FBQyxDQUFDckMsT0FBTyxDQUFDO0lBQ3JELElBQUltQyxhQUFhLENBQUNYLE1BQU0sR0FBRyxDQUFDLEVBQUU7TUFDNUI3QixPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDSSxHQUFHLEdBQUdKLE1BQU0sQ0FBQ0UsTUFBTSxnQkFBZ0JGLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7TUFDeEVtSSxhQUFhLENBQUNwQixPQUFPLENBQUNhLE1BQU0sSUFBSTtRQUM5QmpDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEtBQUs3RixNQUFNLENBQUNJLEdBQUcsS0FBS3lILE1BQU0sQ0FBQzNCLElBQUksR0FBR2xHLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7UUFDN0QsSUFBSTRILE1BQU0sQ0FBQy9FLEtBQUssRUFBRTtVQUNoQjhDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEdBQUc3RixNQUFNLENBQUNHLEdBQUcsR0FBRzBILE1BQU0sQ0FBQy9FLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQytCLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUN6RCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUdyQyxNQUFNLENBQUNDLEtBQUssRUFBRSxDQUFDO1FBQy9GO01BQ0YsQ0FBQyxDQUFDOztNQUVGO01BQ0EsSUFBSSxDQUFDc0ksaUJBQWlCLENBQUNILGFBQWEsQ0FBQztJQUN2Qzs7SUFFQTtJQUNBLE1BQU1JLFdBQVcsR0FBR3BILE9BQU8sQ0FBQ3FILE1BQU0sQ0FBQyxDQUFDQyxHQUFHLEVBQUVKLENBQUMsS0FBS0ksR0FBRyxHQUFHSixDQUFDLENBQUNoRCxRQUFRLEVBQUUsQ0FBQyxDQUFDLEdBQUdsRSxPQUFPLENBQUNxRyxNQUFNO0lBQ3BGN0IsT0FBTyxDQUFDQyxHQUFHLENBQUMsS0FBSzdGLE1BQU0sQ0FBQ0csR0FBRywwQkFBMEJ3SSxJQUFJLENBQUNDLEtBQUssQ0FBQ0osV0FBVyxDQUFDLEtBQUt4SSxNQUFNLENBQUNDLEtBQUssRUFBRSxDQUFDO0VBQ2xHOztFQUVBO0FBQ0Y7QUFDQTtFQUNFc0ksaUJBQWlCQSxDQUFDSCxhQUFhLEVBQUU7SUFDL0IsSUFBSUEsYUFBYSxDQUFDWCxNQUFNLEtBQUssQ0FBQyxFQUFFO0lBRWhDLE1BQU10RyxHQUFHLEdBQUcsSUFBSUQsSUFBSSxDQUFDLENBQUM7SUFDdEIsTUFBTTJILFlBQVksR0FBRzFILEdBQUcsQ0FBQzJILFdBQVcsQ0FBQyxDQUFDO0lBQ3RDLE1BQU1DLFdBQVcsR0FBRzVILEdBQUcsQ0FBQzZILGNBQWMsQ0FBQyxPQUFPLEVBQUU7TUFDOUNDLFFBQVEsRUFBRSxxQkFBcUI7TUFDL0JDLE9BQU8sRUFBRSxNQUFNO01BQ2ZDLElBQUksRUFBRSxTQUFTO01BQ2ZDLEtBQUssRUFBRSxNQUFNO01BQ2JDLEdBQUcsRUFBRSxTQUFTO01BQ2RDLElBQUksRUFBRSxTQUFTO01BQ2ZDLE1BQU0sRUFBRSxTQUFTO01BQ2pCQyxNQUFNLEVBQUUsU0FBUztNQUNqQkMsWUFBWSxFQUFFO0lBQ2hCLENBQUMsQ0FBQztJQUVGLElBQUlDLFlBQVksR0FBRyw2QkFBNkI7SUFDaERBLFlBQVksSUFBSSxzQkFBc0JiLFlBQVksSUFBSTtJQUN0RGEsWUFBWSxJQUFJLHFCQUFxQlgsV0FBVyxNQUFNO0lBQ3REVyxZQUFZLElBQUksbUtBQW1LO0lBQ25MQSxZQUFZLElBQUksc0RBQXNEO0lBRXRFdEIsYUFBYSxDQUFDcEIsT0FBTyxDQUFDLENBQUNhLE1BQU0sRUFBRThCLEtBQUssS0FBSztNQUN2Q0QsWUFBWSxJQUFJLGtCQUFrQkMsS0FBSyxHQUFHLENBQUMsS0FBSzlCLE1BQU0sQ0FBQzNCLElBQUksTUFBTTtNQUNqRXdELFlBQVksSUFBSSxlQUFlO01BQy9CQSxZQUFZLElBQUksT0FBTztNQUN2QkEsWUFBWSxJQUFJN0IsTUFBTSxDQUFDL0UsS0FBSyxJQUFJK0UsTUFBTSxDQUFDdEMsTUFBTSxJQUFJLDJCQUEyQjtNQUM1RW1FLFlBQVksSUFBSSxXQUFXO01BQzNCQSxZQUFZLElBQUksaUJBQWlCN0IsTUFBTSxDQUFDdkMsUUFBUSxRQUFRO01BQ3hEb0UsWUFBWSxJQUFJLFNBQVM7SUFDM0IsQ0FBQyxDQUFDO0lBRUZBLFlBQVksSUFBSSxnQkFBZ0I7SUFDaENBLFlBQVksSUFBSSx5QkFBeUJ0QixhQUFhLENBQUNYLE1BQU0sSUFBSTtJQUNqRWlDLFlBQVksSUFBSSx3QkFBd0J0QixhQUFhLENBQUM3QixHQUFHLENBQUMrQixDQUFDLElBQUlBLENBQUMsQ0FBQ3BDLElBQUksQ0FBQyxDQUFDN0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJO0lBQ3JGcUgsWUFBWSxJQUFJLGdCQUFnQixJQUFJeEksSUFBSSxDQUFDLENBQUMsQ0FBQzRILFdBQVcsQ0FBQyxDQUFDLElBQUk7SUFFNUQsSUFBSTtNQUNGbkosRUFBRSxDQUFDaUssYUFBYSxDQUFDLGdCQUFnQixFQUFFRixZQUFZLENBQUM7TUFDaEQ5RCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxLQUFLN0YsTUFBTSxDQUFDTSxNQUFNLHdDQUF3Q04sTUFBTSxDQUFDQyxLQUFLLEVBQUUsQ0FBQztJQUN2RixDQUFDLENBQUMsT0FBTzZDLEtBQUssRUFBRTtNQUNkOEMsT0FBTyxDQUFDQyxHQUFHLENBQUMsR0FBRzdGLE1BQU0sQ0FBQ0ksR0FBRyx3Q0FBd0MwQyxLQUFLLENBQUNxRCxPQUFPLEdBQUduRyxNQUFNLENBQUNDLEtBQUssRUFBRSxDQUFDO0lBQ2xHO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsTUFBTTRKLEdBQUdBLENBQUEsRUFBRztJQUNWakUsT0FBTyxDQUFDQyxHQUFHLENBQUMsR0FBRzdGLE1BQU0sQ0FBQ0UsTUFBTSx3Q0FBd0NGLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7SUFDbkYyRixPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDRyxHQUFHLHVDQUF1Q0gsTUFBTSxDQUFDQyxLQUFLLElBQUksQ0FBQzs7SUFFakY7SUFDQSxNQUFNWSxTQUFTLEdBQUcsSUFBSSxDQUFDUyxhQUFhLENBQUMsQ0FBQztJQUV0QyxJQUFJVCxTQUFTLENBQUM0RyxNQUFNLEtBQUssQ0FBQyxFQUFFO01BQzFCN0IsT0FBTyxDQUFDQyxHQUFHLENBQUMsR0FBRzdGLE1BQU0sQ0FBQ00sTUFBTSwwQkFBMEJOLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLENBQUM7TUFDckUyRixPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDRyxHQUFHLGlGQUFpRkgsTUFBTSxDQUFDQyxLQUFLLEVBQUUsQ0FBQztNQUN6SDtJQUNGO0lBRUEyRixPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDTyxJQUFJLFNBQVNNLFNBQVMsQ0FBQzRHLE1BQU0saUJBQWlCekgsTUFBTSxDQUFDQyxLQUFLLEVBQUUsQ0FBQztJQUNuRlksU0FBUyxDQUFDbUcsT0FBTyxDQUFDZCxJQUFJLElBQUlOLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEtBQUs3RixNQUFNLENBQUNHLEdBQUcsSUFBSUgsTUFBTSxDQUFDQyxLQUFLLElBQUlpRyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ2pGTixPQUFPLENBQUNDLEdBQUcsQ0FBQyxLQUFLN0YsTUFBTSxDQUFDUSxPQUFPLGtDQUFrQ1IsTUFBTSxDQUFDQyxLQUFLLElBQUksQ0FBQzs7SUFFbEY7SUFDQSxNQUFNNkosUUFBUSxHQUFHL0osRUFBRSxDQUFDZ0ssSUFBSSxDQUFDLENBQUMsQ0FBQ3RDLE1BQU07SUFDakMsTUFBTXVDLGFBQWEsR0FBR3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDN0ksRUFBRSxDQUFDa0ssUUFBUSxDQUFDLENBQUMsR0FBSSxJQUFJLElBQUksQ0FBRSxDQUFDOztJQUU3RDtJQUNBLE1BQU1DLGNBQWMsR0FBR3ZCLElBQUksQ0FBQ3dCLEtBQUssQ0FBQ0gsYUFBYSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDeEQsTUFBTUksV0FBVyxHQUFHTixRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDckMsTUFBTTNDLGNBQWMsR0FBR3dCLElBQUksQ0FBQzBCLEdBQUcsQ0FBQ3hKLFNBQVMsQ0FBQzRHLE1BQU0sRUFBRWtCLElBQUksQ0FBQzJCLEdBQUcsQ0FBQyxDQUFDLEVBQUVGLFdBQVcsQ0FBQyxFQUFFRixjQUFjLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs7SUFFakd0RSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxHQUFHN0YsTUFBTSxDQUFDRyxHQUFHLG9CQUFvQmdILGNBQWMsYUFBYTJDLFFBQVEsZUFBZUUsYUFBYSxVQUFVaEssTUFBTSxDQUFDQyxLQUFLLElBQUksQ0FBQztJQUV2SSxNQUFNbUIsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDOEYsYUFBYSxDQUFDckcsU0FBUyxFQUFFc0csY0FBYyxDQUFDO0lBQ25FLElBQUksQ0FBQy9GLE9BQU8sR0FBR0EsT0FBTzs7SUFFdEI7SUFDQSxJQUFJLENBQUM2RyxjQUFjLENBQUM3RyxPQUFPLENBQUM7O0lBRTVCO0lBQ0EyRCxPQUFPLENBQUN3RixJQUFJLENBQUMsSUFBSSxDQUFDeEosV0FBVyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQzVDO0FBQ0Y7O0FBRUE7QUFDQSxJQUFJbkIsT0FBTyxDQUFDNEssSUFBSSxLQUFLQyxNQUFNLEVBQUU7RUFDM0IsTUFBTUMsTUFBTSxHQUFHLElBQUkvSixVQUFVLENBQUMsQ0FBQztFQUMvQitKLE1BQU0sQ0FBQ2IsR0FBRyxDQUFDLENBQUMsQ0FBQzdCLEtBQUssQ0FBQ2xGLEtBQUssSUFBSTtJQUMxQjhDLE9BQU8sQ0FBQzlDLEtBQUssQ0FBQyxHQUFHOUMsTUFBTSxDQUFDSSxHQUFHLHFCQUFxQkosTUFBTSxDQUFDQyxLQUFLLEVBQUUsRUFBRTZDLEtBQUssQ0FBQztJQUN0RWlDLE9BQU8sQ0FBQ3dGLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDakIsQ0FBQyxDQUFDO0FBQ0o7QUFFQUUsTUFBTSxDQUFDRSxPQUFPLEdBQUdoSyxVQUFVIiwiaWdub3JlTGlzdCI6W119