896aa4471e8adc9c27d44e12186b0dda
"use strict";
/**
 * Module Reloading Utility - TypeScript Implementation
 *
 * This module provides functionality for reloading modules from Node.js cache
 * for isolated testing scenarios. It focuses solely on module cache management.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.moduleReloadLock = void 0;
exports.reload = reload;
const path_1 = __importDefault(require("path"));
const url_1 = require("url");
// For ES modules, we need to get __dirname equivalent
const __filename = (0, url_1.fileURLToPath)(import.meta.url);
const __dirname = path_1.default.dirname(__filename);
// Thread-safe module reloading lock to prevent race conditions
const moduleReloadLock = new Set();
exports.moduleReloadLock = moduleReloadLock;
/**
 * Reload a module from cache for isolated testing
 *
 * This function clears a module from Node.js require cache and reloads it,
 * enabling tests to verify module loading behavior and ensure fresh module
 * state between tests.
 *
 * Note: In ES modules, dynamic imports don't have the same caching behavior as CommonJS require.
 * This function provides a compatibility layer for testing scenarios.
 *
 * @param relPath - Relative path to module that should be reloaded
 * @returns The freshly loaded module object
 * @throws Error if module cannot be found or loaded
 */
async function reload(relPath) {
    console.log(`reload is running with ${relPath}`);
    // Resolve relative to the utils directory (parent of helpers)
    const fullPath = path_1.default.resolve(__dirname, '..', relPath);
    if (moduleReloadLock.has(fullPath)) {
        console.log(`reload has run resulting in skip`);
        try {
            return await Promise.resolve(`${fullPath}`).then(s => __importStar(require(s)));
        }
        catch (error) {
            console.log(`reload error during skip: ${error.message}`);
            throw error;
        }
    }
    try {
        moduleReloadLock.add(fullPath);
        // For ES modules, we use dynamic import with cache busting
        const cacheBuster = `?t=${Date.now()}`;
        const moduleUrl = `${fullPath}${cacheBuster}`;
        const mod = await Promise.resolve(`${moduleUrl}`).then(s => __importStar(require(s)));
        moduleReloadLock.delete(fullPath);
        console.log(`reload is returning module`);
        return mod;
    }
    catch (err) {
        moduleReloadLock.delete(fullPath);
        console.log(`reload error ${err.message}`);
        throw err;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS91dGlscy9oZWxwZXJzL21vZHVsZVJlbG9hZGVyLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7R0FLRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOERELHdCQUFNO0FBNURSLGdEQUF3QjtBQUN4Qiw2QkFBb0M7QUFFcEMsc0RBQXNEO0FBQ3RELE1BQU0sVUFBVSxHQUFHLElBQUEsbUJBQWEsRUFBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2xELE1BQU0sU0FBUyxHQUFHLGNBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFM0MsK0RBQStEO0FBQy9ELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztBQXFEekMsNENBQWdCO0FBbkRsQjs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsS0FBSyxVQUFVLE1BQU0sQ0FBQyxPQUFlO0lBQ25DLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFFakQsOERBQThEO0lBQzlELE1BQU0sUUFBUSxHQUFHLGNBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUV4RCxJQUFJLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBQ25DLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0NBQWtDLENBQUMsQ0FBQztRQUNoRCxJQUFJLENBQUM7WUFDSCxPQUFPLHlCQUFhLFFBQVEsdUNBQUMsQ0FBQztRQUNoQyxDQUFDO1FBQUMsT0FBTyxLQUFVLEVBQUUsQ0FBQztZQUNwQixPQUFPLENBQUMsR0FBRyxDQUFDLDZCQUE2QixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUMxRCxNQUFNLEtBQUssQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRUQsSUFBSSxDQUFDO1FBQ0gsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRS9CLDJEQUEyRDtRQUMzRCxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sU0FBUyxHQUFHLEdBQUcsUUFBUSxHQUFHLFdBQVcsRUFBRSxDQUFDO1FBQzlDLE1BQU0sR0FBRyxHQUFHLHlCQUFhLFNBQVMsdUNBQUMsQ0FBQztRQUVwQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBQzFDLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUFDLE9BQU8sR0FBUSxFQUFFLENBQUM7UUFDbEIsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2xDLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sR0FBRyxDQUFDO0lBQ1osQ0FBQztBQUNILENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS91dGlscy9oZWxwZXJzL21vZHVsZVJlbG9hZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIFJlbG9hZGluZyBVdGlsaXR5IC0gVHlwZVNjcmlwdCBJbXBsZW1lbnRhdGlvblxuICogXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciByZWxvYWRpbmcgbW9kdWxlcyBmcm9tIE5vZGUuanMgY2FjaGVcbiAqIGZvciBpc29sYXRlZCB0ZXN0aW5nIHNjZW5hcmlvcy4gSXQgZm9jdXNlcyBzb2xlbHkgb24gbW9kdWxlIGNhY2hlIG1hbmFnZW1lbnQuXG4gKi9cblxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBmaWxlVVJMVG9QYXRoIH0gZnJvbSAndXJsJztcblxuLy8gRm9yIEVTIG1vZHVsZXMsIHdlIG5lZWQgdG8gZ2V0IF9fZGlybmFtZSBlcXVpdmFsZW50XG5jb25zdCBfX2ZpbGVuYW1lID0gZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpO1xuY29uc3QgX19kaXJuYW1lID0gcGF0aC5kaXJuYW1lKF9fZmlsZW5hbWUpO1xuXG4vLyBUaHJlYWQtc2FmZSBtb2R1bGUgcmVsb2FkaW5nIGxvY2sgdG8gcHJldmVudCByYWNlIGNvbmRpdGlvbnNcbmNvbnN0IG1vZHVsZVJlbG9hZExvY2sgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuLyoqXG4gKiBSZWxvYWQgYSBtb2R1bGUgZnJvbSBjYWNoZSBmb3IgaXNvbGF0ZWQgdGVzdGluZ1xuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGNsZWFycyBhIG1vZHVsZSBmcm9tIE5vZGUuanMgcmVxdWlyZSBjYWNoZSBhbmQgcmVsb2FkcyBpdCxcbiAqIGVuYWJsaW5nIHRlc3RzIHRvIHZlcmlmeSBtb2R1bGUgbG9hZGluZyBiZWhhdmlvciBhbmQgZW5zdXJlIGZyZXNoIG1vZHVsZVxuICogc3RhdGUgYmV0d2VlbiB0ZXN0cy5cbiAqIFxuICogTm90ZTogSW4gRVMgbW9kdWxlcywgZHluYW1pYyBpbXBvcnRzIGRvbid0IGhhdmUgdGhlIHNhbWUgY2FjaGluZyBiZWhhdmlvciBhcyBDb21tb25KUyByZXF1aXJlLlxuICogVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICogXG4gKiBAcGFyYW0gcmVsUGF0aCAtIFJlbGF0aXZlIHBhdGggdG8gbW9kdWxlIHRoYXQgc2hvdWxkIGJlIHJlbG9hZGVkXG4gKiBAcmV0dXJucyBUaGUgZnJlc2hseSBsb2FkZWQgbW9kdWxlIG9iamVjdFxuICogQHRocm93cyBFcnJvciBpZiBtb2R1bGUgY2Fubm90IGJlIGZvdW5kIG9yIGxvYWRlZFxuICovXG5hc3luYyBmdW5jdGlvbiByZWxvYWQocmVsUGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc29sZS5sb2coYHJlbG9hZCBpcyBydW5uaW5nIHdpdGggJHtyZWxQYXRofWApO1xuXG4gIC8vIFJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHV0aWxzIGRpcmVjdG9yeSAocGFyZW50IG9mIGhlbHBlcnMpXG4gIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgcmVsUGF0aCk7XG5cbiAgaWYgKG1vZHVsZVJlbG9hZExvY2suaGFzKGZ1bGxQYXRoKSkge1xuICAgIGNvbnNvbGUubG9nKGByZWxvYWQgaGFzIHJ1biByZXN1bHRpbmcgaW4gc2tpcGApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaW1wb3J0KGZ1bGxQYXRoKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmxvZyhgcmVsb2FkIGVycm9yIGR1cmluZyBza2lwOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIG1vZHVsZVJlbG9hZExvY2suYWRkKGZ1bGxQYXRoKTtcbiAgICBcbiAgICAvLyBGb3IgRVMgbW9kdWxlcywgd2UgdXNlIGR5bmFtaWMgaW1wb3J0IHdpdGggY2FjaGUgYnVzdGluZ1xuICAgIGNvbnN0IGNhY2hlQnVzdGVyID0gYD90PSR7RGF0ZS5ub3coKX1gO1xuICAgIGNvbnN0IG1vZHVsZVVybCA9IGAke2Z1bGxQYXRofSR7Y2FjaGVCdXN0ZXJ9YDtcbiAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQobW9kdWxlVXJsKTtcbiAgICBcbiAgICBtb2R1bGVSZWxvYWRMb2NrLmRlbGV0ZShmdWxsUGF0aCk7XG4gICAgY29uc29sZS5sb2coYHJlbG9hZCBpcyByZXR1cm5pbmcgbW9kdWxlYCk7XG4gICAgcmV0dXJuIG1vZDtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBtb2R1bGVSZWxvYWRMb2NrLmRlbGV0ZShmdWxsUGF0aCk7XG4gICAgY29uc29sZS5sb2coYHJlbG9hZCBlcnJvciAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBFeHBvcnQgbW9kdWxlIHJlbG9hZGluZyB1dGlsaXRpZXMgdXNpbmcgRVMgbW9kdWxlIHN5bnRheFxuZXhwb3J0IHtcbiAgcmVsb2FkLFxuICBtb2R1bGVSZWxvYWRMb2NrXG59OyJdLCJ2ZXJzaW9uIjozfQ==