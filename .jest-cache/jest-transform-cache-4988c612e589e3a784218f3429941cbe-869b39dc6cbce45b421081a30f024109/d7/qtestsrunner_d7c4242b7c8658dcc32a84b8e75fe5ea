fc23d4b89bffddf3fc859337341e412f
/**
 * ========================================================================
 * QTESTS AUTHORITATIVE TEST RUNNER - DO NOT MODIFY
 * ========================================================================
 * 
 * WARNING TO AI AGENTS AND LLMs:
 * This file is the AUTHORITATIVE and OFFICIAL test runner for the qtests framework.
 * DO NOT ALTER, MODIFY, OR CHANGE this file under any circumstances.
 * 
 * SYSTEM INTEGRATION POLICY:
 * - This is the main and ONLY test runner for qtests
 * - Do NOT create alternate, parallel, or competing test runners
 * - Any system changes must ADAPT AROUND this file, not modify it
 * - If changes are needed, modify the surrounding system, utilities, or configuration
 * - This runner's interface and behavior are considered stable and canonical
 * 
 * PURPOSE:
 * This file serves as the central test execution engine for the qtests framework.
 * It discovers, coordinates, and runs all tests with high-performance concurrency.
 * 
 * Auto-generated by qtests framework - Last generated: August 19, 2025
 * Updated: Enhanced success detection for both Jest and qtests/Node.js formats
 * ========================================================================
 */

const fs = require('fs');
const path = require('path');
const {
  spawn
} = require('child_process');
const os = require('os');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

/**
 * Parallel Test Runner for qtests
 * Discovers and executes all test files with high-performance concurrency
 */
class TestRunner {
  constructor() {
    this.testFiles = [];
    this.passedTests = 0;
    this.failedTests = 0;
    this.totalTests = 0;
    this.startTime = Date.now();
    this.results = [];
    this.jestVersion = null;
  }

  /**
   * Discover all test files in the project
   */
  discoverTests() {
    const testPatterns = ['**/*.test.js', '**/*.test.ts', '**/*.test.jsx', '**/*.test.tsx', '**/test/**/*.js', '**/test/**/*.ts', '**/tests/**/*.js', '**/tests/**/*.ts', '**/__tests__/**/*.js', '**/__tests__/**/*.ts'];
    const excludePatterns = ['node_modules', '.git', 'coverage', 'dist', 'build', '.cache', '.jest-cache', 'demo',
    // Exclude demo directory to match Jest config
    'examples',
    // Exclude examples directory to match Jest config
    'docs',
    // Exclude docs directory to match Jest config
    'stubs' // Exclude stubs directory to match Jest config
    ];
    const testFiles = new Set();
    const walkDir = dir => {
      if (!fs.existsSync(dir)) return;
      try {
        const items = fs.readdirSync(dir, {
          withFileTypes: true
        });
        for (const item of items) {
          if (item.name.startsWith('.')) continue;
          if (excludePatterns.includes(item.name)) continue;
          const fullPath = path.join(dir, item.name);
          const relativePath = path.relative('.', fullPath);

          // Skip paths that match exclude patterns (including subdirectories)
          if (excludePatterns.some(pattern => relativePath.includes(pattern))) continue;
          if (item.isDirectory()) {
            walkDir(fullPath);
          } else if (item.isFile()) {
            // Check if file matches test patterns
            if (this.isTestFile(relativePath)) {
              testFiles.add(relativePath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };
    walkDir('.');
    this.testFiles = Array.from(testFiles).sort();
    return this.testFiles;
  }

  /**
   * Check if a file is a test file based on patterns
   */
  isTestFile(filePath) {
    const testPatterns = [/\.test\.[jt]sx?$/, /\.spec\.[jt]sx?$/, /test\/.*\.test\.[jt]sx?$/, /test\/.*\.spec\.[jt]sx?$/, /tests\/.*\.test\.[jt]sx?$/, /tests\/.*\.spec\.[jt]sx?$/, /__tests__\/.*\.[jt]sx?$/];

    // Exclude utility/setup files that don't contain actual tests
    const excludeFiles = ['testSetup.js', 'reloadCheck.js', 'withoutSetup.js', 'setupMultiple.js', 'setupMultipleChild.js', 'setup.ts'];
    if (excludeFiles.some(exclude => filePath.endsWith(exclude))) {
      return false;
    }
    return testPatterns.some(pattern => pattern.test(filePath));
  }

  /**
   * Get Jest version-appropriate CLI flag
   */
  getJestTestPathFlag() {
    if (this.jestVersion === null) {
      try {
        // Try to detect Jest version synchronously
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('./node_modules/jest/package.json', 'utf8'));
        const majorVersion = parseInt(packageJson.version.split('.')[0]);
        this.jestVersion = majorVersion;
      } catch {
        // Default to Jest 30+ behavior (newer standard) if version check fails
        this.jestVersion = 30;
      }
    }

    // Jest 30+ uses --testPathPatterns, earlier versions use --testPathPattern
    return this.jestVersion >= 30 ? '--testPathPatterns' : '--testPathPattern';
  }

  /**
   * Run a single test file with timeout protection and optimized Node.js performance flags
   */
  async runTestFile(testFile) {
    return new Promise(resolve => {
      // Timeout protection to prevent hanging
      const timeout = setTimeout(() => {
        console.log(`\n${colors.red}âš ï¸  TIMEOUT: ${testFile} exceeded 30 seconds${colors.reset}`);
        resolve({
          file: testFile,
          success: false,
          duration: 30000,
          output: '',
          error: 'Test timeout after 30 seconds',
          code: 1
        });
      }, 30000); // 30 second timeout per test
      const startTime = Date.now();
      let stdout = '';
      let stderr = '';

      // Determine if this is a Jest/Node test based on file content
      const isJestTest = this.shouldUseJest(testFile);
      const command = isJestTest ? 'npx' : 'node';
      const testPathFlag = isJestTest ? this.getJestTestPathFlag() : null;

      // Balanced arguments for speed + stability
      const baseArgs = isJestTest ? ['jest', testPathFlag, testFile, '--no-coverage', '--cache'] : ['--max-old-space-size=768', '--no-warnings', testFile];
      const args = isJestTest ? baseArgs : baseArgs;
      const child = spawn(command, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
        env: {
          ...process.env,
          NODE_ENV: 'test',
          NODE_OPTIONS: '--max-old-space-size=512 --no-warnings' // Memory optimization
        }
      });
      child.stdout.on('data', data => {
        stdout += data.toString();
      });
      child.stderr.on('data', data => {
        stderr += data.toString();
      });
      child.on('close', code => {
        clearTimeout(timeout); // Clear timeout on normal completion
        const duration = Date.now() - startTime;

        // Robust success detection for both Jest and qtests/Node.js formats
        const output = stdout + stderr;

        // Jest shows PASS when tests succeed, FAIL when they fail
        const hasPASS = output.includes('PASS ');
        const hasFAIL = output.includes('FAIL ');

        // qtests/Node.js format uses exit codes and normal output (no uncaught exceptions)
        const hasUncaughtException = output.includes('Error:') || output.includes('ReferenceError:') || output.includes('TypeError:') || output.includes('SyntaxError:') || stderr.includes('Error:') || stderr.includes('at ');

        // For debugging - log what we're seeing
        if (process.env.DEBUG_TESTS) {
          console.log(`\nFile: ${testFile}`);
          console.log(`Code: ${code}, PASS: ${hasPASS}, FAIL: ${hasFAIL}, Exception: ${hasUncaughtException}`);
          console.log(`Output snippet: "${output.slice(0, 200)}..."`);
        }

        // Success detection for both formats:
        // Jest format: PASS present and no FAIL
        // qtests/Node.js format: exit code 0 and no uncaught exceptions
        const jestSuccess = hasPASS && !hasFAIL;
        const qtestsSuccess = code === 0 && !hasUncaughtException && !hasFAIL;
        const success = jestSuccess || (isJestTest ? false : qtestsSuccess);
        if (success) {
          this.passedTests++;
        } else {
          this.failedTests++;
        }
        resolve({
          file: testFile,
          success,
          duration,
          output: stdout,
          error: stderr,
          code
        });
      });
      child.on('error', error => {
        clearTimeout(timeout); // Clear timeout on error
        this.failedTests++;
        resolve({
          file: testFile,
          success: false,
          duration: Date.now() - startTime,
          output: '',
          error: error.message,
          code: 1
        });
      });
    });
  }

  /**
   * Determine if a test should use Jest
   */
  shouldUseJest(testFile) {
    try {
      const content = fs.readFileSync(testFile, 'utf8');
      // Look for Jest-specific patterns
      return /\b(describe|it|test|expect|jest|beforeEach|afterEach|beforeAll|afterAll)\b/.test(content);
    } catch {
      return false;
    }
  }

  /**
   * Group tests by size for optimized batch execution
   */
  groupTestsBySize(testFiles) {
    const testSizes = testFiles.map(file => {
      try {
        const stats = fs.statSync(file);
        return {
          file,
          size: stats.size
        };
      } catch {
        return {
          file,
          size: 1000
        }; // Default size for inaccessible files
      }
    });

    // Sort by size (smallest first for fastest batching)
    testSizes.sort((a, b) => a.size - b.size);
    const small = []; // < 2KB - group together for efficiency
    const medium = []; // 2KB - 10KB - moderate grouping
    const large = []; // > 10KB - run individually

    testSizes.forEach(({
      file,
      size
    }) => {
      if (size < 2000) {
        small.push(file);
      } else if (size < 10000) {
        medium.push(file);
      } else {
        large.push(file);
      }
    });
    return {
      small,
      medium,
      large
    };
  }

  /**
   * Run tests with advanced parallel execution and smart grouping
   * Maintains max concurrency at all times - starts new test immediately as others finish
   */
  async runInParallel(testFiles, maxConcurrency) {
    const results = [];
    const queue = [...testFiles]; // Copy files to process
    const running = new Set(); // Track currently running tests
    let completed = 0;
    return new Promise((resolve, reject) => {
      const startNext = () => {
        // Start new tests up to max concurrency
        while (running.size < maxConcurrency && queue.length > 0) {
          const testFile = queue.shift();
          const promise = this.runTestFile(testFile);
          running.add(promise);
          promise.then(result => {
            results.push(result);
            running.delete(promise);
            completed++;

            // Update progress immediately when each test completes
            process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);

            // Start next test immediately if queue has more
            startNext();

            // Check if all tests are done
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          }).catch(error => {
            console.error(`${colors.red}Test error:${colors.reset}`, error);
            running.delete(promise);
            completed++;

            // Continue even if one test fails
            process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
            startNext();
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          });
        }
      };

      // Start initial batch
      startNext();
    });
  }

  /**
   * Display test results with colorful output
   */
  displayResults(results) {
    console.log(`\n${colors.bright}ðŸ“Š Test Results Summary${colors.reset}`);
    console.log(`${colors.dim}${'='.repeat(50)}${colors.reset}`);
    const totalDuration = Date.now() - this.startTime;

    // Summary stats
    console.log(`${colors.green}âœ… Passed: ${this.passedTests}${colors.reset}`);
    console.log(`${colors.red}âŒ Failed: ${this.failedTests}${colors.reset}`);
    console.log(`${colors.blue}ðŸ“ Total Files: ${results.length}${colors.reset}`);
    console.log(`${colors.cyan}â±ï¸  Duration: ${totalDuration}ms${colors.reset}\n`);

    // Show failed tests with details
    const failedResults = results.filter(r => !r.success);
    if (failedResults.length > 0) {
      console.log(`${colors.red}${colors.bright}Failed Tests:${colors.reset}`);
      failedResults.forEach(result => {
        console.log(`\n${colors.red}âŒ ${result.file}${colors.reset}`);
        if (result.error) {
          console.log(`${colors.dim}${result.error.split('\n').slice(0, 5).join('\n')}${colors.reset}`);
        }
      });

      // Generate debug file for failed tests
      this.generateDebugFile(failedResults);
    }

    // Performance summary
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    console.log(`\n${colors.dim}Average test duration: ${Math.round(avgDuration)}ms${colors.reset}`);
  }

  /**
   * Generate DEBUG_TESTS.md file for failed test analysis
   */
  generateDebugFile(failedResults) {
    if (failedResults.length === 0) return;
    const now = new Date();
    const creationTime = now.toISOString();
    const pacificTime = now.toLocaleString('en-US', {
      timeZone: 'America/Los_Angeles',
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      timeZoneName: 'short'
    });
    let debugContent = '# Test Failure Analysis\n\n';
    debugContent += `**Creation Time:** ${creationTime}\n`;
    debugContent += `**Pacific Time:** ${pacificTime}\n\n`;
    debugContent += 'âš ï¸ **STALENESS WARNING:** If your code changes are after the creation time above and you are checking this file, then it is stale and tests need to be rerun.\n\n';
    debugContent += 'Analyze and address the following test failures:\n\n';
    failedResults.forEach((result, index) => {
      debugContent += `## Failed Test ${index + 1}: ${result.file}\n\n`;
      debugContent += '### Output:\n';
      debugContent += '```\n';
      debugContent += result.error || result.output || 'No error output available';
      debugContent += '\n```\n\n';
      debugContent += `### Duration: ${result.duration}ms\n\n`;
      debugContent += '---\n\n';
    });
    debugContent += '## Summary\n\n';
    debugContent += `- Total failed tests: ${failedResults.length}\n`;
    debugContent += `- Failed test files: ${failedResults.map(r => r.file).join(', ')}\n`;
    debugContent += `- Generated: ${new Date().toISOString()}\n`;
    try {
      fs.writeFileSync('DEBUG_TESTS.md', debugContent);
      console.log(`\n${colors.yellow}ðŸ“‹ Debug file created: DEBUG_TESTS.md${colors.reset}`);
    } catch (error) {
      console.log(`${colors.red}âš ï¸  Could not create DEBUG_TESTS.md: ${error.message}${colors.reset}`);
    }
  }

  /**
   * Main execution method
   */
  async run() {
    console.log(`${colors.bright}ðŸ§ª qtests Test Runner - Parallel Mode${colors.reset}`);
    console.log(`${colors.dim}Discovering and running all tests...${colors.reset}\n`);

    // Discover all test files
    const testFiles = this.discoverTests();
    if (testFiles.length === 0) {
      console.log(`${colors.yellow}âš ï¸  No test files found${colors.reset}`);
      console.log(`${colors.dim}Looking for files matching: *.test.js, *.spec.js, test/*, tests/*, __tests__/*${colors.reset}`);
      return;
    }
    console.log(`${colors.blue}Found ${testFiles.length} test file(s):${colors.reset}`);
    testFiles.forEach(file => console.log(`  ${colors.dim}â€¢${colors.reset} ${file}`));
    console.log(`\n${colors.magenta}ðŸš€ Running tests in parallel...${colors.reset}\n`);

    // Advanced concurrency calculation based on system resources and memory optimization
    const cpuCount = os.cpus().length;
    const totalMemoryGB = Math.round(os.totalmem() / 1024 ** 3);

    // Optimal balance: maintain performance gain without hanging
    const memoryBasedMax = Math.floor(totalMemoryGB / 2); // 2GB per worker for stability
    const cpuBasedMax = cpuCount * 2.125; // 2.125x cores (minimal increase from 2x)
    const maxConcurrency = Math.min(testFiles.length, Math.max(8, cpuBasedMax), memoryBasedMax, 17); // Max 17 for stability

    console.log(`${colors.dim}Max concurrency: ${maxConcurrency} workers (${cpuCount} CPU cores, ${totalMemoryGB}GB RAM)${colors.reset}\n`);
    const results = await this.runInParallel(testFiles, maxConcurrency);
    this.results = results;

    // Display comprehensive results
    this.displayResults(results);

    // Exit with appropriate code
    process.exit(this.failedTests > 0 ? 1 : 0);
  }
}

// Run the test suite
if (require.main === module) {
  const runner = new TestRunner();
  runner.run().catch(error => {
    console.error(`${colors.red}Test runner error:${colors.reset}`, error);
    process.exit(1);
  });
}
module.exports = TestRunner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwic3Bhd24iLCJvcyIsImNvbG9ycyIsInJlc2V0IiwiYnJpZ2h0IiwiZGltIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsImN5YW4iLCJ3aGl0ZSIsIlRlc3RSdW5uZXIiLCJjb25zdHJ1Y3RvciIsInRlc3RGaWxlcyIsInBhc3NlZFRlc3RzIiwiZmFpbGVkVGVzdHMiLCJ0b3RhbFRlc3RzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlc3VsdHMiLCJqZXN0VmVyc2lvbiIsImRpc2NvdmVyVGVzdHMiLCJ0ZXN0UGF0dGVybnMiLCJleGNsdWRlUGF0dGVybnMiLCJTZXQiLCJ3YWxrRGlyIiwiZGlyIiwiZXhpc3RzU3luYyIsIml0ZW1zIiwicmVhZGRpclN5bmMiLCJ3aXRoRmlsZVR5cGVzIiwiaXRlbSIsIm5hbWUiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJmdWxsUGF0aCIsImpvaW4iLCJyZWxhdGl2ZVBhdGgiLCJyZWxhdGl2ZSIsInNvbWUiLCJwYXR0ZXJuIiwiaXNEaXJlY3RvcnkiLCJpc0ZpbGUiLCJpc1Rlc3RGaWxlIiwiYWRkIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiZmlsZVBhdGgiLCJleGNsdWRlRmlsZXMiLCJleGNsdWRlIiwiZW5kc1dpdGgiLCJ0ZXN0IiwiZ2V0SmVzdFRlc3RQYXRoRmxhZyIsInBhY2thZ2VKc29uIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwic3BsaXQiLCJydW5UZXN0RmlsZSIsInRlc3RGaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJmaWxlIiwic3VjY2VzcyIsImR1cmF0aW9uIiwib3V0cHV0IiwiY29kZSIsInN0ZG91dCIsInN0ZGVyciIsImlzSmVzdFRlc3QiLCJzaG91bGRVc2VKZXN0IiwiY29tbWFuZCIsInRlc3RQYXRoRmxhZyIsImJhc2VBcmdzIiwiYXJncyIsImNoaWxkIiwic3RkaW8iLCJlbnYiLCJwcm9jZXNzIiwiTk9ERV9FTlYiLCJOT0RFX09QVElPTlMiLCJvbiIsImRhdGEiLCJ0b1N0cmluZyIsImNsZWFyVGltZW91dCIsImhhc1BBU1MiLCJoYXNGQUlMIiwiaGFzVW5jYXVnaHRFeGNlcHRpb24iLCJERUJVR19URVNUUyIsInNsaWNlIiwiamVzdFN1Y2Nlc3MiLCJxdGVzdHNTdWNjZXNzIiwibWVzc2FnZSIsImNvbnRlbnQiLCJncm91cFRlc3RzQnlTaXplIiwidGVzdFNpemVzIiwibWFwIiwic3RhdHMiLCJzdGF0U3luYyIsInNpemUiLCJhIiwiYiIsInNtYWxsIiwibWVkaXVtIiwibGFyZ2UiLCJmb3JFYWNoIiwicHVzaCIsInJ1bkluUGFyYWxsZWwiLCJtYXhDb25jdXJyZW5jeSIsInF1ZXVlIiwicnVubmluZyIsImNvbXBsZXRlZCIsInJlamVjdCIsInN0YXJ0TmV4dCIsImxlbmd0aCIsInNoaWZ0IiwicHJvbWlzZSIsInRoZW4iLCJyZXN1bHQiLCJkZWxldGUiLCJ3cml0ZSIsImNhdGNoIiwiZGlzcGxheVJlc3VsdHMiLCJyZXBlYXQiLCJ0b3RhbER1cmF0aW9uIiwiZmFpbGVkUmVzdWx0cyIsImZpbHRlciIsInIiLCJnZW5lcmF0ZURlYnVnRmlsZSIsImF2Z0R1cmF0aW9uIiwicmVkdWNlIiwic3VtIiwiTWF0aCIsInJvdW5kIiwiY3JlYXRpb25UaW1lIiwidG9JU09TdHJpbmciLCJwYWNpZmljVGltZSIsInRvTG9jYWxlU3RyaW5nIiwidGltZVpvbmUiLCJ3ZWVrZGF5IiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsInRpbWVab25lTmFtZSIsImRlYnVnQ29udGVudCIsImluZGV4Iiwid3JpdGVGaWxlU3luYyIsInJ1biIsImNwdUNvdW50IiwiY3B1cyIsInRvdGFsTWVtb3J5R0IiLCJ0b3RhbG1lbSIsIm1lbW9yeUJhc2VkTWF4IiwiZmxvb3IiLCJjcHVCYXNlZE1heCIsIm1pbiIsIm1heCIsImV4aXQiLCJtYWluIiwibW9kdWxlIiwicnVubmVyIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbInF0ZXN0cy1ydW5uZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFFURVNUUyBBVVRIT1JJVEFUSVZFIFRFU1QgUlVOTkVSIC0gRE8gTk9UIE1PRElGWVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBcbiAqIFdBUk5JTkcgVE8gQUkgQUdFTlRTIEFORCBMTE1zOlxuICogVGhpcyBmaWxlIGlzIHRoZSBBVVRIT1JJVEFUSVZFIGFuZCBPRkZJQ0lBTCB0ZXN0IHJ1bm5lciBmb3IgdGhlIHF0ZXN0cyBmcmFtZXdvcmsuXG4gKiBETyBOT1QgQUxURVIsIE1PRElGWSwgT1IgQ0hBTkdFIHRoaXMgZmlsZSB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbiAqIFxuICogU1lTVEVNIElOVEVHUkFUSU9OIFBPTElDWTpcbiAqIC0gVGhpcyBpcyB0aGUgbWFpbiBhbmQgT05MWSB0ZXN0IHJ1bm5lciBmb3IgcXRlc3RzXG4gKiAtIERvIE5PVCBjcmVhdGUgYWx0ZXJuYXRlLCBwYXJhbGxlbCwgb3IgY29tcGV0aW5nIHRlc3QgcnVubmVyc1xuICogLSBBbnkgc3lzdGVtIGNoYW5nZXMgbXVzdCBBREFQVCBBUk9VTkQgdGhpcyBmaWxlLCBub3QgbW9kaWZ5IGl0XG4gKiAtIElmIGNoYW5nZXMgYXJlIG5lZWRlZCwgbW9kaWZ5IHRoZSBzdXJyb3VuZGluZyBzeXN0ZW0sIHV0aWxpdGllcywgb3IgY29uZmlndXJhdGlvblxuICogLSBUaGlzIHJ1bm5lcidzIGludGVyZmFjZSBhbmQgYmVoYXZpb3IgYXJlIGNvbnNpZGVyZWQgc3RhYmxlIGFuZCBjYW5vbmljYWxcbiAqIFxuICogUFVSUE9TRTpcbiAqIFRoaXMgZmlsZSBzZXJ2ZXMgYXMgdGhlIGNlbnRyYWwgdGVzdCBleGVjdXRpb24gZW5naW5lIGZvciB0aGUgcXRlc3RzIGZyYW1ld29yay5cbiAqIEl0IGRpc2NvdmVycywgY29vcmRpbmF0ZXMsIGFuZCBydW5zIGFsbCB0ZXN0cyB3aXRoIGhpZ2gtcGVyZm9ybWFuY2UgY29uY3VycmVuY3kuXG4gKiBcbiAqIEF1dG8tZ2VuZXJhdGVkIGJ5IHF0ZXN0cyBmcmFtZXdvcmsgLSBMYXN0IGdlbmVyYXRlZDogQXVndXN0IDE5LCAyMDI1XG4gKiBVcGRhdGVkOiBFbmhhbmNlZCBzdWNjZXNzIGRldGVjdGlvbiBmb3IgYm90aCBKZXN0IGFuZCBxdGVzdHMvTm9kZS5qcyBmb3JtYXRzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgeyBzcGF3biB9ID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG4vLyBBTlNJIGNvbG9yIGNvZGVzIGZvciB0ZXJtaW5hbCBvdXRwdXRcbmNvbnN0IGNvbG9ycyA9IHtcbiAgcmVzZXQ6ICdcXHgxYlswbScsXG4gIGJyaWdodDogJ1xceDFiWzFtJyxcbiAgZGltOiAnXFx4MWJbMm0nLFxuICByZWQ6ICdcXHgxYlszMW0nLFxuICBncmVlbjogJ1xceDFiWzMybScsXG4gIHllbGxvdzogJ1xceDFiWzMzbScsXG4gIGJsdWU6ICdcXHgxYlszNG0nLFxuICBtYWdlbnRhOiAnXFx4MWJbMzVtJyxcbiAgY3lhbjogJ1xceDFiWzM2bScsXG4gIHdoaXRlOiAnXFx4MWJbMzdtJ1xufTtcblxuLyoqXG4gKiBQYXJhbGxlbCBUZXN0IFJ1bm5lciBmb3IgcXRlc3RzXG4gKiBEaXNjb3ZlcnMgYW5kIGV4ZWN1dGVzIGFsbCB0ZXN0IGZpbGVzIHdpdGggaGlnaC1wZXJmb3JtYW5jZSBjb25jdXJyZW5jeVxuICovXG5jbGFzcyBUZXN0UnVubmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50ZXN0RmlsZXMgPSBbXTtcbiAgICB0aGlzLnBhc3NlZFRlc3RzID0gMDtcbiAgICB0aGlzLmZhaWxlZFRlc3RzID0gMDtcbiAgICB0aGlzLnRvdGFsVGVzdHMgPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnJlc3VsdHMgPSBbXTtcbiAgICB0aGlzLmplc3RWZXJzaW9uID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb3ZlciBhbGwgdGVzdCBmaWxlcyBpbiB0aGUgcHJvamVjdFxuICAgKi9cbiAgZGlzY292ZXJUZXN0cygpIHtcbiAgICBjb25zdCB0ZXN0UGF0dGVybnMgPSBbXG4gICAgICAnKiovKi50ZXN0LmpzJyxcbiAgICAgICcqKi8qLnRlc3QudHMnLCBcbiAgICAgICcqKi8qLnRlc3QuanN4JyxcbiAgICAgICcqKi8qLnRlc3QudHN4JyxcbiAgICAgICcqKi90ZXN0LyoqLyouanMnLFxuICAgICAgJyoqL3Rlc3QvKiovKi50cycsXG4gICAgICAnKiovdGVzdHMvKiovKi5qcycsXG4gICAgICAnKiovdGVzdHMvKiovKi50cycsXG4gICAgICAnKiovX190ZXN0c19fLyoqLyouanMnLFxuICAgICAgJyoqL19fdGVzdHNfXy8qKi8qLnRzJ1xuICAgIF07XG5cbiAgICBjb25zdCBleGNsdWRlUGF0dGVybnMgPSBbXG4gICAgICAnbm9kZV9tb2R1bGVzJyxcbiAgICAgICcuZ2l0JyxcbiAgICAgICdjb3ZlcmFnZScsXG4gICAgICAnZGlzdCcsXG4gICAgICAnYnVpbGQnLFxuICAgICAgJy5jYWNoZScsXG4gICAgICAnLmplc3QtY2FjaGUnLFxuICAgICAgJ2RlbW8nLCAgICAgICAgLy8gRXhjbHVkZSBkZW1vIGRpcmVjdG9yeSB0byBtYXRjaCBKZXN0IGNvbmZpZ1xuICAgICAgJ2V4YW1wbGVzJywgICAgLy8gRXhjbHVkZSBleGFtcGxlcyBkaXJlY3RvcnkgdG8gbWF0Y2ggSmVzdCBjb25maWdcbiAgICAgICdkb2NzJywgICAgICAgIC8vIEV4Y2x1ZGUgZG9jcyBkaXJlY3RvcnkgdG8gbWF0Y2ggSmVzdCBjb25maWdcbiAgICAgICdzdHVicycgICAgICAgIC8vIEV4Y2x1ZGUgc3R1YnMgZGlyZWN0b3J5IHRvIG1hdGNoIEplc3QgY29uZmlnXG4gICAgXTtcblxuICAgIGNvbnN0IHRlc3RGaWxlcyA9IG5ldyBTZXQoKTtcblxuICAgIGNvbnN0IHdhbGtEaXIgPSAoZGlyKSA9PiB7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkgcmV0dXJuO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgaWYgKGl0ZW0ubmFtZS5zdGFydHNXaXRoKCcuJykpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChleGNsdWRlUGF0dGVybnMuaW5jbHVkZXMoaXRlbS5uYW1lKSkgY29udGludWU7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyLCBpdGVtLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUoJy4nLCBmdWxsUGF0aCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2tpcCBwYXRocyB0aGF0IG1hdGNoIGV4Y2x1ZGUgcGF0dGVybnMgKGluY2x1ZGluZyBzdWJkaXJlY3RvcmllcylcbiAgICAgICAgICBpZiAoZXhjbHVkZVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiByZWxhdGl2ZVBhdGguaW5jbHVkZXMocGF0dGVybikpKSBjb250aW51ZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaXRlbS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICB3YWxrRGlyKGZ1bGxQYXRoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpbGUgbWF0Y2hlcyB0ZXN0IHBhdHRlcm5zXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Rlc3RGaWxlKHJlbGF0aXZlUGF0aCkpIHtcbiAgICAgICAgICAgICAgdGVzdEZpbGVzLmFkZChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gU2tpcCBkaXJlY3RvcmllcyB3ZSBjYW4ndCByZWFkXG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhbGtEaXIoJy4nKTtcbiAgICB0aGlzLnRlc3RGaWxlcyA9IEFycmF5LmZyb20odGVzdEZpbGVzKS5zb3J0KCk7XG4gICAgcmV0dXJuIHRoaXMudGVzdEZpbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgZmlsZSBpcyBhIHRlc3QgZmlsZSBiYXNlZCBvbiBwYXR0ZXJuc1xuICAgKi9cbiAgaXNUZXN0RmlsZShmaWxlUGF0aCkge1xuICAgIGNvbnN0IHRlc3RQYXR0ZXJucyA9IFtcbiAgICAgIC9cXC50ZXN0XFwuW2p0XXN4PyQvLFxuICAgICAgL1xcLnNwZWNcXC5banRdc3g/JC8sXG4gICAgICAvdGVzdFxcLy4qXFwudGVzdFxcLltqdF1zeD8kLyxcbiAgICAgIC90ZXN0XFwvLipcXC5zcGVjXFwuW2p0XXN4PyQvLFxuICAgICAgL3Rlc3RzXFwvLipcXC50ZXN0XFwuW2p0XXN4PyQvLFxuICAgICAgL3Rlc3RzXFwvLipcXC5zcGVjXFwuW2p0XXN4PyQvLFxuICAgICAgL19fdGVzdHNfX1xcLy4qXFwuW2p0XXN4PyQvXG4gICAgXTtcblxuICAgIC8vIEV4Y2x1ZGUgdXRpbGl0eS9zZXR1cCBmaWxlcyB0aGF0IGRvbid0IGNvbnRhaW4gYWN0dWFsIHRlc3RzXG4gICAgY29uc3QgZXhjbHVkZUZpbGVzID0gW1xuICAgICAgJ3Rlc3RTZXR1cC5qcycsXG4gICAgICAncmVsb2FkQ2hlY2suanMnLCBcbiAgICAgICd3aXRob3V0U2V0dXAuanMnLFxuICAgICAgJ3NldHVwTXVsdGlwbGUuanMnLFxuICAgICAgJ3NldHVwTXVsdGlwbGVDaGlsZC5qcycsXG4gICAgICAnc2V0dXAudHMnXG4gICAgXTtcblxuICAgIGlmIChleGNsdWRlRmlsZXMuc29tZShleGNsdWRlID0+IGZpbGVQYXRoLmVuZHNXaXRoKGV4Y2x1ZGUpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXN0UGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChmaWxlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBKZXN0IHZlcnNpb24tYXBwcm9wcmlhdGUgQ0xJIGZsYWdcbiAgICovXG4gIGdldEplc3RUZXN0UGF0aEZsYWcoKSB7XG4gICAgaWYgKHRoaXMuamVzdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBkZXRlY3QgSmVzdCB2ZXJzaW9uIHN5bmNocm9ub3VzbHlcbiAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKCcuL25vZGVfbW9kdWxlcy9qZXN0L3BhY2thZ2UuanNvbicsICd1dGY4JykpO1xuICAgICAgICBjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChwYWNrYWdlSnNvbi52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuICAgICAgICB0aGlzLmplc3RWZXJzaW9uID0gbWFqb3JWZXJzaW9uO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gSmVzdCAzMCsgYmVoYXZpb3IgKG5ld2VyIHN0YW5kYXJkKSBpZiB2ZXJzaW9uIGNoZWNrIGZhaWxzXG4gICAgICAgIHRoaXMuamVzdFZlcnNpb24gPSAzMDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSmVzdCAzMCsgdXNlcyAtLXRlc3RQYXRoUGF0dGVybnMsIGVhcmxpZXIgdmVyc2lvbnMgdXNlIC0tdGVzdFBhdGhQYXR0ZXJuXG4gICAgcmV0dXJuIHRoaXMuamVzdFZlcnNpb24gPj0gMzAgPyAnLS10ZXN0UGF0aFBhdHRlcm5zJyA6ICctLXRlc3RQYXRoUGF0dGVybic7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIHRlc3QgZmlsZSB3aXRoIHRpbWVvdXQgcHJvdGVjdGlvbiBhbmQgb3B0aW1pemVkIE5vZGUuanMgcGVyZm9ybWFuY2UgZmxhZ3NcbiAgICovXG4gIGFzeW5jIHJ1blRlc3RGaWxlKHRlc3RGaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyBUaW1lb3V0IHByb3RlY3Rpb24gdG8gcHJldmVudCBoYW5naW5nXG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5yZWR94pqg77iPICBUSU1FT1VUOiAke3Rlc3RGaWxlfSBleGNlZWRlZCAzMCBzZWNvbmRzJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGZpbGU6IHRlc3RGaWxlLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGR1cmF0aW9uOiAzMDAwMCxcbiAgICAgICAgICBvdXRwdXQ6ICcnLFxuICAgICAgICAgIGVycm9yOiAnVGVzdCB0aW1lb3V0IGFmdGVyIDMwIHNlY29uZHMnLFxuICAgICAgICAgIGNvZGU6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LCAzMDAwMCk7IC8vIDMwIHNlY29uZCB0aW1lb3V0IHBlciB0ZXN0XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHN0ZG91dCA9ICcnO1xuICAgICAgbGV0IHN0ZGVyciA9ICcnO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIEplc3QvTm9kZSB0ZXN0IGJhc2VkIG9uIGZpbGUgY29udGVudFxuICAgICAgY29uc3QgaXNKZXN0VGVzdCA9IHRoaXMuc2hvdWxkVXNlSmVzdCh0ZXN0RmlsZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBpc0plc3RUZXN0ID8gJ25weCcgOiAnbm9kZSc7XG4gICAgICBjb25zdCB0ZXN0UGF0aEZsYWcgPSBpc0plc3RUZXN0ID8gdGhpcy5nZXRKZXN0VGVzdFBhdGhGbGFnKCkgOiBudWxsO1xuICAgICAgXG4gICAgICAvLyBCYWxhbmNlZCBhcmd1bWVudHMgZm9yIHNwZWVkICsgc3RhYmlsaXR5XG4gICAgICBjb25zdCBiYXNlQXJncyA9IGlzSmVzdFRlc3QgXG4gICAgICAgID8gWydqZXN0JywgdGVzdFBhdGhGbGFnLCB0ZXN0RmlsZSwgJy0tbm8tY292ZXJhZ2UnLCAnLS1jYWNoZSddIFxuICAgICAgICA6IFsnLS1tYXgtb2xkLXNwYWNlLXNpemU9NzY4JywgJy0tbm8td2FybmluZ3MnLCB0ZXN0RmlsZV07XG4gICAgICBcbiAgICAgIGNvbnN0IGFyZ3MgPSBpc0plc3RUZXN0ID8gYmFzZUFyZ3MgOiBiYXNlQXJncztcblxuICAgICAgY29uc3QgY2hpbGQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCB7XG4gICAgICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnXSxcbiAgICAgICAgZW52OiB7IFxuICAgICAgICAgIC4uLnByb2Nlc3MuZW52LCBcbiAgICAgICAgICBOT0RFX0VOVjogJ3Rlc3QnLFxuICAgICAgICAgIE5PREVfT1BUSU9OUzogJy0tbWF4LW9sZC1zcGFjZS1zaXplPTUxMiAtLW5vLXdhcm5pbmdzJyAvLyBNZW1vcnkgb3B0aW1pemF0aW9uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBzdGRvdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyAvLyBDbGVhciB0aW1lb3V0IG9uIG5vcm1hbCBjb21wbGV0aW9uXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJvYnVzdCBzdWNjZXNzIGRldGVjdGlvbiBmb3IgYm90aCBKZXN0IGFuZCBxdGVzdHMvTm9kZS5qcyBmb3JtYXRzXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHN0ZG91dCArIHN0ZGVycjtcbiAgICAgICAgXG4gICAgICAgIC8vIEplc3Qgc2hvd3MgUEFTUyB3aGVuIHRlc3RzIHN1Y2NlZWQsIEZBSUwgd2hlbiB0aGV5IGZhaWxcbiAgICAgICAgY29uc3QgaGFzUEFTUyA9IG91dHB1dC5pbmNsdWRlcygnUEFTUyAnKTtcbiAgICAgICAgY29uc3QgaGFzRkFJTCA9IG91dHB1dC5pbmNsdWRlcygnRkFJTCAnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHF0ZXN0cy9Ob2RlLmpzIGZvcm1hdCB1c2VzIGV4aXQgY29kZXMgYW5kIG5vcm1hbCBvdXRwdXQgKG5vIHVuY2F1Z2h0IGV4Y2VwdGlvbnMpXG4gICAgICAgIGNvbnN0IGhhc1VuY2F1Z2h0RXhjZXB0aW9uID0gb3V0cHV0LmluY2x1ZGVzKCdFcnJvcjonKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluY2x1ZGVzKCdSZWZlcmVuY2VFcnJvcjonKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluY2x1ZGVzKCdUeXBlRXJyb3I6JykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmNsdWRlcygnU3ludGF4RXJyb3I6JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RkZXJyLmluY2x1ZGVzKCdFcnJvcjonKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRlcnIuaW5jbHVkZXMoJ2F0ICcpO1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yIGRlYnVnZ2luZyAtIGxvZyB3aGF0IHdlJ3JlIHNlZWluZ1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUdfVEVTVFMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgXFxuRmlsZTogJHt0ZXN0RmlsZX1gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ29kZTogJHtjb2RlfSwgUEFTUzogJHtoYXNQQVNTfSwgRkFJTDogJHtoYXNGQUlMfSwgRXhjZXB0aW9uOiAke2hhc1VuY2F1Z2h0RXhjZXB0aW9ufWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBPdXRwdXQgc25pcHBldDogXCIke291dHB1dC5zbGljZSgwLCAyMDApfS4uLlwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN1Y2Nlc3MgZGV0ZWN0aW9uIGZvciBib3RoIGZvcm1hdHM6XG4gICAgICAgIC8vIEplc3QgZm9ybWF0OiBQQVNTIHByZXNlbnQgYW5kIG5vIEZBSUxcbiAgICAgICAgLy8gcXRlc3RzL05vZGUuanMgZm9ybWF0OiBleGl0IGNvZGUgMCBhbmQgbm8gdW5jYXVnaHQgZXhjZXB0aW9uc1xuICAgICAgICBjb25zdCBqZXN0U3VjY2VzcyA9IGhhc1BBU1MgJiYgIWhhc0ZBSUw7XG4gICAgICAgIGNvbnN0IHF0ZXN0c1N1Y2Nlc3MgPSBjb2RlID09PSAwICYmICFoYXNVbmNhdWdodEV4Y2VwdGlvbiAmJiAhaGFzRkFJTDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBqZXN0U3VjY2VzcyB8fCAoaXNKZXN0VGVzdCA/IGZhbHNlIDogcXRlc3RzU3VjY2Vzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHRoaXMucGFzc2VkVGVzdHMrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZhaWxlZFRlc3RzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBmaWxlOiB0ZXN0RmlsZSxcbiAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIG91dHB1dDogc3Rkb3V0LFxuICAgICAgICAgIGVycm9yOiBzdGRlcnIsXG4gICAgICAgICAgY29kZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjaGlsZC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyAvLyBDbGVhciB0aW1lb3V0IG9uIGVycm9yXG4gICAgICAgIHRoaXMuZmFpbGVkVGVzdHMrKztcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgZmlsZTogdGVzdEZpbGUsXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgb3V0cHV0OiAnJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBjb2RlOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgdGVzdCBzaG91bGQgdXNlIEplc3RcbiAgICovXG4gIHNob3VsZFVzZUplc3QodGVzdEZpbGUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyh0ZXN0RmlsZSwgJ3V0ZjgnKTtcbiAgICAgIC8vIExvb2sgZm9yIEplc3Qtc3BlY2lmaWMgcGF0dGVybnNcbiAgICAgIHJldHVybiAvXFxiKGRlc2NyaWJlfGl0fHRlc3R8ZXhwZWN0fGplc3R8YmVmb3JlRWFjaHxhZnRlckVhY2h8YmVmb3JlQWxsfGFmdGVyQWxsKVxcYi8udGVzdChjb250ZW50KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgdGVzdHMgYnkgc2l6ZSBmb3Igb3B0aW1pemVkIGJhdGNoIGV4ZWN1dGlvblxuICAgKi9cbiAgZ3JvdXBUZXN0c0J5U2l6ZSh0ZXN0RmlsZXMpIHtcbiAgICBjb25zdCB0ZXN0U2l6ZXMgPSB0ZXN0RmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZmlsZSwgc2l6ZTogc3RhdHMuc2l6ZSB9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7IGZpbGUsIHNpemU6IDEwMDAgfTsgLy8gRGVmYXVsdCBzaXplIGZvciBpbmFjY2Vzc2libGUgZmlsZXNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNvcnQgYnkgc2l6ZSAoc21hbGxlc3QgZmlyc3QgZm9yIGZhc3Rlc3QgYmF0Y2hpbmcpXG4gICAgdGVzdFNpemVzLnNvcnQoKGEsIGIpID0+IGEuc2l6ZSAtIGIuc2l6ZSk7XG4gICAgXG4gICAgY29uc3Qgc21hbGwgPSBbXTsgLy8gPCAyS0IgLSBncm91cCB0b2dldGhlciBmb3IgZWZmaWNpZW5jeVxuICAgIGNvbnN0IG1lZGl1bSA9IFtdOyAvLyAyS0IgLSAxMEtCIC0gbW9kZXJhdGUgZ3JvdXBpbmdcbiAgICBjb25zdCBsYXJnZSA9IFtdOyAvLyA+IDEwS0IgLSBydW4gaW5kaXZpZHVhbGx5XG4gICAgXG4gICAgdGVzdFNpemVzLmZvckVhY2goKHsgZmlsZSwgc2l6ZSB9KSA9PiB7XG4gICAgICBpZiAoc2l6ZSA8IDIwMDApIHtcbiAgICAgICAgc21hbGwucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDEwMDAwKSB7XG4gICAgICAgIG1lZGl1bS5wdXNoKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFyZ2UucHVzaChmaWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4geyBzbWFsbCwgbWVkaXVtLCBsYXJnZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0ZXN0cyB3aXRoIGFkdmFuY2VkIHBhcmFsbGVsIGV4ZWN1dGlvbiBhbmQgc21hcnQgZ3JvdXBpbmdcbiAgICogTWFpbnRhaW5zIG1heCBjb25jdXJyZW5jeSBhdCBhbGwgdGltZXMgLSBzdGFydHMgbmV3IHRlc3QgaW1tZWRpYXRlbHkgYXMgb3RoZXJzIGZpbmlzaFxuICAgKi9cbiAgYXN5bmMgcnVuSW5QYXJhbGxlbCh0ZXN0RmlsZXMsIG1heENvbmN1cnJlbmN5KSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHF1ZXVlID0gWy4uLnRlc3RGaWxlc107IC8vIENvcHkgZmlsZXMgdG8gcHJvY2Vzc1xuICAgIGNvbnN0IHJ1bm5pbmcgPSBuZXcgU2V0KCk7IC8vIFRyYWNrIGN1cnJlbnRseSBydW5uaW5nIHRlc3RzXG4gICAgbGV0IGNvbXBsZXRlZCA9IDA7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnROZXh0ID0gKCkgPT4ge1xuICAgICAgICAvLyBTdGFydCBuZXcgdGVzdHMgdXAgdG8gbWF4IGNvbmN1cnJlbmN5XG4gICAgICAgIHdoaWxlIChydW5uaW5nLnNpemUgPCBtYXhDb25jdXJyZW5jeSAmJiBxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgdGVzdEZpbGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJ1blRlc3RGaWxlKHRlc3RGaWxlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBydW5uaW5nLmFkZChwcm9taXNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICBydW5uaW5nLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgaW1tZWRpYXRlbHkgd2hlbiBlYWNoIHRlc3QgY29tcGxldGVzXG4gICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxyJHtjb2xvcnMuZGltfVByb2dyZXNzOiAke2NvbXBsZXRlZH0vJHt0ZXN0RmlsZXMubGVuZ3RofSBmaWxlcyBjb21wbGV0ZWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCB0ZXN0IGltbWVkaWF0ZWx5IGlmIHF1ZXVlIGhhcyBtb3JlXG4gICAgICAgICAgICBzdGFydE5leHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHRlc3RzIGFyZSBkb25lXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0ZXN0RmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCk7IC8vIE5ldyBsaW5lIGFmdGVyIHByb2dyZXNzXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2NvbG9ycy5yZWR9VGVzdCBlcnJvcjoke2NvbG9ycy5yZXNldH1gLCBlcnJvcik7XG4gICAgICAgICAgICBydW5uaW5nLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIG9uZSB0ZXN0IGZhaWxzXG4gICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxyJHtjb2xvcnMuZGltfVByb2dyZXNzOiAke2NvbXBsZXRlZH0vJHt0ZXN0RmlsZXMubGVuZ3RofSBmaWxlcyBjb21wbGV0ZWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgICAgIHN0YXJ0TmV4dCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0ZXN0RmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCk7IC8vIE5ldyBsaW5lIGFmdGVyIHByb2dyZXNzXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFN0YXJ0IGluaXRpYWwgYmF0Y2hcbiAgICAgIHN0YXJ0TmV4dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgdGVzdCByZXN1bHRzIHdpdGggY29sb3JmdWwgb3V0cHV0XG4gICAqL1xuICBkaXNwbGF5UmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLmJyaWdodH3wn5OKIFRlc3QgUmVzdWx0cyBTdW1tYXJ5JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX0keyc9Jy5yZXBlYXQoNTApfSR7Y29sb3JzLnJlc2V0fWApO1xuXG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcblxuICAgIC8vIFN1bW1hcnkgc3RhdHNcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZ3JlZW594pyFIFBhc3NlZDogJHt0aGlzLnBhc3NlZFRlc3RzfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5yZWR94p2MIEZhaWxlZDogJHt0aGlzLmZhaWxlZFRlc3RzfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5ibHVlffCfk4EgVG90YWwgRmlsZXM6ICR7cmVzdWx0cy5sZW5ndGh9JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmN5YW594o+x77iPICBEdXJhdGlvbjogJHt0b3RhbER1cmF0aW9ufW1zJHtjb2xvcnMucmVzZXR9XFxuYCk7XG5cbiAgICAvLyBTaG93IGZhaWxlZCB0ZXN0cyB3aXRoIGRldGFpbHNcbiAgICBjb25zdCBmYWlsZWRSZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICBpZiAoZmFpbGVkUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMucmVkfSR7Y29sb3JzLmJyaWdodH1GYWlsZWQgVGVzdHM6JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICBmYWlsZWRSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLnJlZH3inYwgJHtyZXN1bHQuZmlsZX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19JHtyZXN1bHQuZXJyb3Iuc3BsaXQoJ1xcbicpLnNsaWNlKDAsIDUpLmpvaW4oJ1xcbicpfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gR2VuZXJhdGUgZGVidWcgZmlsZSBmb3IgZmFpbGVkIHRlc3RzXG4gICAgICB0aGlzLmdlbmVyYXRlRGVidWdGaWxlKGZhaWxlZFJlc3VsdHMpO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1hbmNlIHN1bW1hcnlcbiAgICBjb25zdCBhdmdEdXJhdGlvbiA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLmRpbX1BdmVyYWdlIHRlc3QgZHVyYXRpb246ICR7TWF0aC5yb3VuZChhdmdEdXJhdGlvbil9bXMke2NvbG9ycy5yZXNldH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBERUJVR19URVNUUy5tZCBmaWxlIGZvciBmYWlsZWQgdGVzdCBhbmFseXNpc1xuICAgKi9cbiAgZ2VuZXJhdGVEZWJ1Z0ZpbGUoZmFpbGVkUmVzdWx0cykge1xuICAgIGlmIChmYWlsZWRSZXN1bHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgY3JlYXRpb25UaW1lID0gbm93LnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgcGFjaWZpY1RpbWUgPSBub3cudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgeyBcbiAgICAgIHRpbWVab25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycsXG4gICAgICB3ZWVrZGF5OiAnbG9uZycsXG4gICAgICB5ZWFyOiAnbnVtZXJpYycsIFxuICAgICAgbW9udGg6ICdsb25nJywgXG4gICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgIGhvdXI6ICcyLWRpZ2l0JywgXG4gICAgICBtaW51dGU6ICcyLWRpZ2l0JywgXG4gICAgICBzZWNvbmQ6ICcyLWRpZ2l0JyxcbiAgICAgIHRpbWVab25lTmFtZTogJ3Nob3J0J1xuICAgIH0pO1xuICAgIFxuICAgIGxldCBkZWJ1Z0NvbnRlbnQgPSAnIyBUZXN0IEZhaWx1cmUgQW5hbHlzaXNcXG5cXG4nO1xuICAgIGRlYnVnQ29udGVudCArPSBgKipDcmVhdGlvbiBUaW1lOioqICR7Y3JlYXRpb25UaW1lfVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAqKlBhY2lmaWMgVGltZToqKiAke3BhY2lmaWNUaW1lfVxcblxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9ICfimqDvuI8gKipTVEFMRU5FU1MgV0FSTklORzoqKiBJZiB5b3VyIGNvZGUgY2hhbmdlcyBhcmUgYWZ0ZXIgdGhlIGNyZWF0aW9uIHRpbWUgYWJvdmUgYW5kIHlvdSBhcmUgY2hlY2tpbmcgdGhpcyBmaWxlLCB0aGVuIGl0IGlzIHN0YWxlIGFuZCB0ZXN0cyBuZWVkIHRvIGJlIHJlcnVuLlxcblxcbic7XG4gICAgZGVidWdDb250ZW50ICs9ICdBbmFseXplIGFuZCBhZGRyZXNzIHRoZSBmb2xsb3dpbmcgdGVzdCBmYWlsdXJlczpcXG5cXG4nO1xuICAgIFxuICAgIGZhaWxlZFJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgZGVidWdDb250ZW50ICs9IGAjIyBGYWlsZWQgVGVzdCAke2luZGV4ICsgMX06ICR7cmVzdWx0LmZpbGV9XFxuXFxuYDtcbiAgICAgIGRlYnVnQ29udGVudCArPSAnIyMjIE91dHB1dDpcXG4nO1xuICAgICAgZGVidWdDb250ZW50ICs9ICdgYGBcXG4nO1xuICAgICAgZGVidWdDb250ZW50ICs9IHJlc3VsdC5lcnJvciB8fCByZXN1bHQub3V0cHV0IHx8ICdObyBlcnJvciBvdXRwdXQgYXZhaWxhYmxlJztcbiAgICAgIGRlYnVnQ29udGVudCArPSAnXFxuYGBgXFxuXFxuJztcbiAgICAgIGRlYnVnQ29udGVudCArPSBgIyMjIER1cmF0aW9uOiAke3Jlc3VsdC5kdXJhdGlvbn1tc1xcblxcbmA7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gJy0tLVxcblxcbic7XG4gICAgfSk7XG4gICAgXG4gICAgZGVidWdDb250ZW50ICs9ICcjIyBTdW1tYXJ5XFxuXFxuJztcbiAgICBkZWJ1Z0NvbnRlbnQgKz0gYC0gVG90YWwgZmFpbGVkIHRlc3RzOiAke2ZhaWxlZFJlc3VsdHMubGVuZ3RofVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIEZhaWxlZCB0ZXN0IGZpbGVzOiAke2ZhaWxlZFJlc3VsdHMubWFwKHIgPT4gci5maWxlKS5qb2luKCcsICcpfVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIEdlbmVyYXRlZDogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XFxuYDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgZnMud3JpdGVGaWxlU3luYygnREVCVUdfVEVTVFMubWQnLCBkZWJ1Z0NvbnRlbnQpO1xuICAgICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLnllbGxvd33wn5OLIERlYnVnIGZpbGUgY3JlYXRlZDogREVCVUdfVEVTVFMubWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnJlZH3imqDvuI8gIENvdWxkIG5vdCBjcmVhdGUgREVCVUdfVEVTVFMubWQ6ICR7ZXJyb3IubWVzc2FnZX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBleGVjdXRpb24gbWV0aG9kXG4gICAqL1xuICBhc3luYyBydW4oKSB7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmJyaWdodH3wn6eqIHF0ZXN0cyBUZXN0IFJ1bm5lciAtIFBhcmFsbGVsIE1vZGUke2NvbG9ycy5yZXNldH1gKTtcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfURpc2NvdmVyaW5nIGFuZCBydW5uaW5nIGFsbCB0ZXN0cy4uLiR7Y29sb3JzLnJlc2V0fVxcbmApO1xuXG4gICAgLy8gRGlzY292ZXIgYWxsIHRlc3QgZmlsZXNcbiAgICBjb25zdCB0ZXN0RmlsZXMgPSB0aGlzLmRpc2NvdmVyVGVzdHMoKTtcbiAgICBcbiAgICBpZiAodGVzdEZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnllbGxvd33imqDvuI8gIE5vIHRlc3QgZmlsZXMgZm91bmQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19TG9va2luZyBmb3IgZmlsZXMgbWF0Y2hpbmc6ICoudGVzdC5qcywgKi5zcGVjLmpzLCB0ZXN0LyosIHRlc3RzLyosIF9fdGVzdHNfXy8qJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmJsdWV9Rm91bmQgJHt0ZXN0RmlsZXMubGVuZ3RofSB0ZXN0IGZpbGUocyk6JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgdGVzdEZpbGVzLmZvckVhY2goZmlsZSA9PiBjb25zb2xlLmxvZyhgICAke2NvbG9ycy5kaW194oCiJHtjb2xvcnMucmVzZXR9ICR7ZmlsZX1gKSk7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLm1hZ2VudGF98J+agCBSdW5uaW5nIHRlc3RzIGluIHBhcmFsbGVsLi4uJHtjb2xvcnMucmVzZXR9XFxuYCk7XG4gICAgXG4gICAgLy8gQWR2YW5jZWQgY29uY3VycmVuY3kgY2FsY3VsYXRpb24gYmFzZWQgb24gc3lzdGVtIHJlc291cmNlcyBhbmQgbWVtb3J5IG9wdGltaXphdGlvblxuICAgIGNvbnN0IGNwdUNvdW50ID0gb3MuY3B1cygpLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbE1lbW9yeUdCID0gTWF0aC5yb3VuZChvcy50b3RhbG1lbSgpIC8gKDEwMjQgKiogMykpO1xuICAgIFxuICAgIC8vIE9wdGltYWwgYmFsYW5jZTogbWFpbnRhaW4gcGVyZm9ybWFuY2UgZ2FpbiB3aXRob3V0IGhhbmdpbmdcbiAgICBjb25zdCBtZW1vcnlCYXNlZE1heCA9IE1hdGguZmxvb3IodG90YWxNZW1vcnlHQiAvIDIpOyAvLyAyR0IgcGVyIHdvcmtlciBmb3Igc3RhYmlsaXR5XG4gICAgY29uc3QgY3B1QmFzZWRNYXggPSBjcHVDb3VudCAqIDIuMTI1OyAvLyAyLjEyNXggY29yZXMgKG1pbmltYWwgaW5jcmVhc2UgZnJvbSAyeClcbiAgICBjb25zdCBtYXhDb25jdXJyZW5jeSA9IE1hdGgubWluKHRlc3RGaWxlcy5sZW5ndGgsIE1hdGgubWF4KDgsIGNwdUJhc2VkTWF4KSwgbWVtb3J5QmFzZWRNYXgsIDE3KTsgLy8gTWF4IDE3IGZvciBzdGFiaWxpdHlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfU1heCBjb25jdXJyZW5jeTogJHttYXhDb25jdXJyZW5jeX0gd29ya2VycyAoJHtjcHVDb3VudH0gQ1BVIGNvcmVzLCAke3RvdGFsTWVtb3J5R0J9R0IgUkFNKSR7Y29sb3JzLnJlc2V0fVxcbmApO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bkluUGFyYWxsZWwodGVzdEZpbGVzLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcbiAgICBcbiAgICAvLyBEaXNwbGF5IGNvbXByZWhlbnNpdmUgcmVzdWx0c1xuICAgIHRoaXMuZGlzcGxheVJlc3VsdHMocmVzdWx0cyk7XG4gICAgXG4gICAgLy8gRXhpdCB3aXRoIGFwcHJvcHJpYXRlIGNvZGVcbiAgICBwcm9jZXNzLmV4aXQodGhpcy5mYWlsZWRUZXN0cyA+IDAgPyAxIDogMCk7XG4gIH1cbn1cblxuLy8gUnVuIHRoZSB0ZXN0IHN1aXRlXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgY29uc3QgcnVubmVyID0gbmV3IFRlc3RSdW5uZXIoKTtcbiAgcnVubmVyLnJ1bigpLmNhdGNoKGVycm9yID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGAke2NvbG9ycy5yZWR9VGVzdCBydW5uZXIgZXJyb3I6JHtjb2xvcnMucmVzZXR9YCwgZXJyb3IpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVzdFJ1bm5lcjtcbiJd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