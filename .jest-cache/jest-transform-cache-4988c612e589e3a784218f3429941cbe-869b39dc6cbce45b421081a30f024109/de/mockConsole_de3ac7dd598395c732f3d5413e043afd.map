{"version":3,"names":["mockConsole","method","console","log","jest","fn","jestSpy","spyOn","mockImplementation","originalMethod","calls","args","push","mockObject","mock","mockRestore","length","error","message","module","exports"],"sources":["mockConsole.js"],"sourcesContent":["\n/**\n * Console Mocking Utilities\n * \n * This module provides console output capture functionality for testing\n * code that logs to the console without polluting test output.\n * \n * Core purpose:\n * When testing functions that log information, errors, or debug output,\n * we need to verify the logging behavior without cluttering the test\n * runner's console. This utility captures console calls while providing\n * access to verify what was logged.\n * \n * Design philosophy:\n * - Clean test output by preventing unwanted console pollution\n * - Full capture and verification capabilities for logged content\n * - Framework compatibility (works with Jest, Mocha, etc.)\n * - Simple restoration to prevent test interference\n * \n * Implementation approach:\n * Uses the same stubbing pattern as stubMethod but specialized for console\n * methods with additional mock call tracking for test verification.\n */\n\n/**\n * Create a mock console method that captures calls without output\n * \n * This function replaces a console method (log, error, warn, etc.) with\n * a mock implementation that captures all calls and arguments while\n * preventing actual console output during testing.\n * \n * Mock implementation strategy:\n * 1. Check if Jest is available and use its mocking capabilities\n * 2. Fall back to manual mock implementation for non-Jest environments\n * 3. Provide consistent API regardless of underlying implementation\n * 4. Capture all arguments passed to console method for verification\n * \n * Why Jest detection:\n * - Jest provides superior mock functionality with built-in call tracking\n * - Jest mocks have additional features like call count, arguments history\n * - Fallback ensures compatibility with other test frameworks\n * - Consistent API means tests work regardless of framework choice\n * \n * @param {string} method - Console method name to mock ('log', 'error', 'warn', etc.)\n * @returns {Object} Mock object with call tracking and restoration capabilities\n * \n * @example\n * const spy = mockConsole('log');\n * console.log('test message');\n * console.log(spy.mock.calls.length); // 1\n * spy.mockRestore();\n */\nfunction mockConsole(method) {\n  console.log(`mockConsole is running with ${method}`); // logging function start per requirements\n  \n  try {\n    // Check for Jest availability and prefer Jest spies when available\n    // Jest spies provide superior debugging tools, call introspection, and integration with Jest ecosystem\n    // typeof check ensures we don't throw errors in non-Jest environments\n    // jest.fn check ensures Jest mocking functionality is actually available, not just Jest test runner\n    if (typeof jest !== `undefined` && jest.fn) {\n      // Use Jest's built-in spying mechanism for enhanced debugging and integration\n      // jest.spyOn preserves original method while adding spy capabilities\n      // mockImplementation(() => {}) creates silent mock that captures calls without output\n      // Jest spies automatically integrate with Jest's assertion and debugging tools\n      const jestSpy = jest.spyOn(console, method).mockImplementation(() => {});\n      console.log(`mockConsole is returning ${jestSpy}`); // logging return value per requirements\n      return jestSpy;\n    }\n    \n    // Fallback implementation for non-Jest environments (Mocha, AVA, vanilla Node.js)\n    // Manual implementation ensures qtests works regardless of testing framework choice\n    // This approach maintains Jest-compatible API for consistent developer experience\n    let originalMethod = console[method]; // preserve original for restoration\n    let calls = []; // array to capture all method invocations with arguments\n    \n    // Replace console method with capturing function that stores calls but produces no output\n    // Spread operator (...args) captures all arguments regardless of method signature\n    // Anonymous function used to avoid name conflicts and ensure proper 'this' binding\n    console[method] = function(...args) {\n      // Store complete argument list for each invocation\n      // Arguments stored as arrays to match Jest's spy.mock.calls format\n      // This enables tests to verify exactly what was logged during execution\n      calls.push(args);\n    };\n    \n    // Create Jest-compatible mock object for consistent API across environments\n    // Object structure matches Jest spy interface to minimize learning curve for developers\n    // Provides same call tracking and restoration capabilities as Jest spies\n    const mockObject = {\n      mock: {\n        // Expose calls array with same structure as Jest spies\n        // Each element is an array of arguments passed to that invocation\n        calls: calls\n      },\n      mockRestore: function() {\n        // Restore original console method to prevent test pollution\n        // Simple assignment ensures reliable restoration and avoids memory leaks\n        console[method] = originalMethod; // reinstate saved method for other tests\n        if (calls) { calls.length = 0; } // clear captured calls for GC\n        this.mock.calls = null; // remove reference from mock object for GC\n        originalMethod = null; // drop reference to allow garbage collection\n        calls = null; // drop call history reference enabling GC\n      }\n    };\n    \n    console.log(`mockConsole is returning ${mockObject}`); // logging return value per requirements\n    return mockObject;\n  } catch (error) {\n    // Provide context for debugging console mocking failures\n    // Common issues include invalid method names or console object modification conflicts\n    // Error re-throwing maintains proper error handling while adding diagnostic information\n    console.log(`mockConsole error: ${error.message}`);\n    throw error;\n  }\n}\n\n// export mockConsole utilities at bottom per requirements\nmodule.exports = {\n  mockConsole // primary console mocking function\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAWA,CAACC,MAAM,EAAE;EAC3BC,OAAO,CAACC,GAAG,CAAC,+BAA+BF,MAAM,EAAE,CAAC,CAAC,CAAC;;EAEtD,IAAI;IACF;IACA;IACA;IACA;IACA,IAAI,OAAOG,IAAI,KAAK,WAAW,IAAIA,IAAI,CAACC,EAAE,EAAE;MAC1C;MACA;MACA;MACA;MACA,MAAMC,OAAO,GAAGF,IAAI,CAACG,KAAK,CAACL,OAAO,EAAED,MAAM,CAAC,CAACO,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC;MACxEN,OAAO,CAACC,GAAG,CAAC,4BAA4BG,OAAO,EAAE,CAAC,CAAC,CAAC;MACpD,OAAOA,OAAO;IAChB;;IAEA;IACA;IACA;IACA,IAAIG,cAAc,GAAGP,OAAO,CAACD,MAAM,CAAC,CAAC,CAAC;IACtC,IAAIS,KAAK,GAAG,EAAE,CAAC,CAAC;;IAEhB;IACA;IACA;IACAR,OAAO,CAACD,MAAM,CAAC,GAAG,UAAS,GAAGU,IAAI,EAAE;MAClC;MACA;MACA;MACAD,KAAK,CAACE,IAAI,CAACD,IAAI,CAAC;IAClB,CAAC;;IAED;IACA;IACA;IACA,MAAME,UAAU,GAAG;MACjBC,IAAI,EAAE;QACJ;QACA;QACAJ,KAAK,EAAEA;MACT,CAAC;MACDK,WAAW,EAAE,SAAAA,CAAA,EAAW;QACtB;QACA;QACAb,OAAO,CAACD,MAAM,CAAC,GAAGQ,cAAc,CAAC,CAAC;QAClC,IAAIC,KAAK,EAAE;UAAEA,KAAK,CAACM,MAAM,GAAG,CAAC;QAAE,CAAC,CAAC;QACjC,IAAI,CAACF,IAAI,CAACJ,KAAK,GAAG,IAAI,CAAC,CAAC;QACxBD,cAAc,GAAG,IAAI,CAAC,CAAC;QACvBC,KAAK,GAAG,IAAI,CAAC,CAAC;MAChB;IACF,CAAC;IAEDR,OAAO,CAACC,GAAG,CAAC,4BAA4BU,UAAU,EAAE,CAAC,CAAC,CAAC;IACvD,OAAOA,UAAU;EACnB,CAAC,CAAC,OAAOI,KAAK,EAAE;IACd;IACA;IACA;IACAf,OAAO,CAACC,GAAG,CAAC,sBAAsBc,KAAK,CAACC,OAAO,EAAE,CAAC;IAClD,MAAMD,KAAK;EACb;AACF;;AAEA;AACAE,MAAM,CAACC,OAAO,GAAG;EACfpB,WAAW,CAAC;AACd,CAAC","ignoreList":[]}