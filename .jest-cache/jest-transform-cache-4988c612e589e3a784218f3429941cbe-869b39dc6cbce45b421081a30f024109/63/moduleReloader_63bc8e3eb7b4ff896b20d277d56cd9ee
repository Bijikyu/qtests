7c2ec1fd88d0d5ce1127b9c55b9c0389
"use strict";
/**
 * Module Reloading Utility - TypeScript Implementation
 *
 * This module provides functionality for reloading modules from Node.js cache
 * for isolated testing scenarios. It focuses solely on module cache management.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.moduleReloadLock = void 0;
exports.reload = reload;
const path_1 = __importDefault(require("path"));
const esm_globals_js_1 = require("../esm-globals.js");
// For ES modules, we need to get __dirname equivalent
const __dirname = (0, esm_globals_js_1.getModuleDirname)(import.meta.url);
// Thread-safe module reloading lock to prevent race conditions
const moduleReloadLock = new Set();
exports.moduleReloadLock = moduleReloadLock;
/**
 * Reload a module from cache for isolated testing
 *
 * This function clears a module from Node.js require cache and reloads it,
 * enabling tests to verify module loading behavior and ensure fresh module
 * state between tests.
 *
 * Note: In ES modules, dynamic imports don't have the same caching behavior as CommonJS require.
 * This function provides a compatibility layer for testing scenarios.
 *
 * @param relPath - Relative path to module that should be reloaded
 * @returns The freshly loaded module object
 * @throws Error if module cannot be found or loaded
 */
async function reload(relPath) {
    console.log(`reload is running with ${relPath}`);
    // Resolve relative to the utils directory (parent of helpers)
    const fullPath = path_1.default.resolve(__dirname, '..', relPath);
    if (moduleReloadLock.has(fullPath)) {
        console.log(`reload has run resulting in skip`);
        try {
            return await Promise.resolve(`${fullPath}`).then(s => __importStar(require(s)));
        }
        catch (error) {
            console.log(`reload error during skip: ${error.message}`);
            throw error;
        }
    }
    try {
        moduleReloadLock.add(fullPath);
        // For ES modules, we use dynamic import with cache busting
        const cacheBuster = `?t=${Date.now()}`;
        const moduleUrl = `${fullPath}${cacheBuster}`;
        const mod = await Promise.resolve(`${moduleUrl}`).then(s => __importStar(require(s)));
        moduleReloadLock.delete(fullPath);
        console.log(`reload is returning module`);
        return mod;
    }
    catch (err) {
        moduleReloadLock.delete(fullPath);
        console.log(`reload error ${err.message}`);
        throw err;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS91dGlscy9oZWxwZXJzL21vZHVsZVJlbG9hZGVyLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7R0FLRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkRELHdCQUFNO0FBM0RSLGdEQUF3QjtBQUN4QixzREFBcUQ7QUFFckQsc0RBQXNEO0FBQ3RELE1BQU0sU0FBUyxHQUFHLElBQUEsaUNBQWdCLEVBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVwRCwrREFBK0Q7QUFDL0QsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO0FBcUR6Qyw0Q0FBZ0I7QUFuRGxCOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxLQUFLLFVBQVUsTUFBTSxDQUFDLE9BQWU7SUFDbkMsT0FBTyxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUVqRCw4REFBOEQ7SUFDOUQsTUFBTSxRQUFRLEdBQUcsY0FBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXhELElBQUksZ0JBQWdCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDbkMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQztZQUNILE9BQU8seUJBQWEsUUFBUSx1Q0FBQyxDQUFDO1FBQ2hDLENBQUM7UUFBQyxPQUFPLEtBQVUsRUFBRSxDQUFDO1lBQ3BCLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkJBQTZCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQzFELE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7SUFFRCxJQUFJLENBQUM7UUFDSCxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFL0IsMkRBQTJEO1FBQzNELE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7UUFDdkMsTUFBTSxTQUFTLEdBQUcsR0FBRyxRQUFRLEdBQUcsV0FBVyxFQUFFLENBQUM7UUFDOUMsTUFBTSxHQUFHLEdBQUcseUJBQWEsU0FBUyx1Q0FBQyxDQUFDO1FBRXBDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNsQyxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFDMUMsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBQUMsT0FBTyxHQUFRLEVBQUUsQ0FBQztRQUNsQixnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDM0MsTUFBTSxHQUFHLENBQUM7SUFDWixDQUFDO0FBQ0gsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL3V0aWxzL2hlbHBlcnMvbW9kdWxlUmVsb2FkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgUmVsb2FkaW5nIFV0aWxpdHkgLSBUeXBlU2NyaXB0IEltcGxlbWVudGF0aW9uXG4gKiBcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHJlbG9hZGluZyBtb2R1bGVzIGZyb20gTm9kZS5qcyBjYWNoZVxuICogZm9yIGlzb2xhdGVkIHRlc3Rpbmcgc2NlbmFyaW9zLiBJdCBmb2N1c2VzIHNvbGVseSBvbiBtb2R1bGUgY2FjaGUgbWFuYWdlbWVudC5cbiAqL1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGdldE1vZHVsZURpcm5hbWUgfSBmcm9tICcuLi9lc20tZ2xvYmFscy5qcyc7XG5cbi8vIEZvciBFUyBtb2R1bGVzLCB3ZSBuZWVkIHRvIGdldCBfX2Rpcm5hbWUgZXF1aXZhbGVudFxuY29uc3QgX19kaXJuYW1lID0gZ2V0TW9kdWxlRGlybmFtZShpbXBvcnQubWV0YS51cmwpO1xuXG4vLyBUaHJlYWQtc2FmZSBtb2R1bGUgcmVsb2FkaW5nIGxvY2sgdG8gcHJldmVudCByYWNlIGNvbmRpdGlvbnNcbmNvbnN0IG1vZHVsZVJlbG9hZExvY2sgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuLyoqXG4gKiBSZWxvYWQgYSBtb2R1bGUgZnJvbSBjYWNoZSBmb3IgaXNvbGF0ZWQgdGVzdGluZ1xuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGNsZWFycyBhIG1vZHVsZSBmcm9tIE5vZGUuanMgcmVxdWlyZSBjYWNoZSBhbmQgcmVsb2FkcyBpdCxcbiAqIGVuYWJsaW5nIHRlc3RzIHRvIHZlcmlmeSBtb2R1bGUgbG9hZGluZyBiZWhhdmlvciBhbmQgZW5zdXJlIGZyZXNoIG1vZHVsZVxuICogc3RhdGUgYmV0d2VlbiB0ZXN0cy5cbiAqIFxuICogTm90ZTogSW4gRVMgbW9kdWxlcywgZHluYW1pYyBpbXBvcnRzIGRvbid0IGhhdmUgdGhlIHNhbWUgY2FjaGluZyBiZWhhdmlvciBhcyBDb21tb25KUyByZXF1aXJlLlxuICogVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICogXG4gKiBAcGFyYW0gcmVsUGF0aCAtIFJlbGF0aXZlIHBhdGggdG8gbW9kdWxlIHRoYXQgc2hvdWxkIGJlIHJlbG9hZGVkXG4gKiBAcmV0dXJucyBUaGUgZnJlc2hseSBsb2FkZWQgbW9kdWxlIG9iamVjdFxuICogQHRocm93cyBFcnJvciBpZiBtb2R1bGUgY2Fubm90IGJlIGZvdW5kIG9yIGxvYWRlZFxuICovXG5hc3luYyBmdW5jdGlvbiByZWxvYWQocmVsUGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc29sZS5sb2coYHJlbG9hZCBpcyBydW5uaW5nIHdpdGggJHtyZWxQYXRofWApO1xuXG4gIC8vIFJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHV0aWxzIGRpcmVjdG9yeSAocGFyZW50IG9mIGhlbHBlcnMpXG4gIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgcmVsUGF0aCk7XG5cbiAgaWYgKG1vZHVsZVJlbG9hZExvY2suaGFzKGZ1bGxQYXRoKSkge1xuICAgIGNvbnNvbGUubG9nKGByZWxvYWQgaGFzIHJ1biByZXN1bHRpbmcgaW4gc2tpcGApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaW1wb3J0KGZ1bGxQYXRoKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmxvZyhgcmVsb2FkIGVycm9yIGR1cmluZyBza2lwOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIG1vZHVsZVJlbG9hZExvY2suYWRkKGZ1bGxQYXRoKTtcbiAgICBcbiAgICAvLyBGb3IgRVMgbW9kdWxlcywgd2UgdXNlIGR5bmFtaWMgaW1wb3J0IHdpdGggY2FjaGUgYnVzdGluZ1xuICAgIGNvbnN0IGNhY2hlQnVzdGVyID0gYD90PSR7RGF0ZS5ub3coKX1gO1xuICAgIGNvbnN0IG1vZHVsZVVybCA9IGAke2Z1bGxQYXRofSR7Y2FjaGVCdXN0ZXJ9YDtcbiAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQobW9kdWxlVXJsKTtcbiAgICBcbiAgICBtb2R1bGVSZWxvYWRMb2NrLmRlbGV0ZShmdWxsUGF0aCk7XG4gICAgY29uc29sZS5sb2coYHJlbG9hZCBpcyByZXR1cm5pbmcgbW9kdWxlYCk7XG4gICAgcmV0dXJuIG1vZDtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBtb2R1bGVSZWxvYWRMb2NrLmRlbGV0ZShmdWxsUGF0aCk7XG4gICAgY29uc29sZS5sb2coYHJlbG9hZCBlcnJvciAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBFeHBvcnQgbW9kdWxlIHJlbG9hZGluZyB1dGlsaXRpZXMgdXNpbmcgRVMgbW9kdWxlIHN5bnRheFxuZXhwb3J0IHtcbiAgcmVsb2FkLFxuICBtb2R1bGVSZWxvYWRMb2NrXG59OyJdLCJ2ZXJzaW9uIjozfQ==