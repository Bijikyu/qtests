{"file":"/home/runner/workspace/utils/helpers/moduleReloader.ts","mappings":";AAAA;;;;;GAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DD,wBAAM;AA5DR,gDAAwB;AACxB,6BAAoC;AAEpC,sDAAsD;AACtD,MAAM,UAAU,GAAG,IAAA,mBAAa,EAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAClD,MAAM,SAAS,GAAG,cAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;AAE3C,+DAA+D;AAC/D,MAAM,gBAAgB,GAAG,IAAI,GAAG,EAAU,CAAC;AAqDzC,4CAAgB;AAnDlB;;;;;;;;;;;;;GAaG;AACH,KAAK,UAAU,MAAM,CAAC,OAAe;IACnC,OAAO,CAAC,GAAG,CAAC,0BAA0B,OAAO,EAAE,CAAC,CAAC;IAEjD,8DAA8D;IAC9D,MAAM,QAAQ,GAAG,cAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;IAExD,IAAI,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;QACnC,OAAO,CAAC,GAAG,CAAC,kCAAkC,CAAC,CAAC;QAChD,IAAI,CAAC;YACH,OAAO,yBAAa,QAAQ,uCAAC,CAAC;QAChC,CAAC;QAAC,OAAO,KAAU,EAAE,CAAC;YACpB,OAAO,CAAC,GAAG,CAAC,6BAA6B,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;YAC1D,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAED,IAAI,CAAC;QACH,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAE/B,2DAA2D;QAC3D,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;QACvC,MAAM,SAAS,GAAG,GAAG,QAAQ,GAAG,WAAW,EAAE,CAAC;QAC9C,MAAM,GAAG,GAAG,yBAAa,SAAS,uCAAC,CAAC;QAEpC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAClC,OAAO,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC;QAC1C,OAAO,GAAG,CAAC;IACb,CAAC;IAAC,OAAO,GAAQ,EAAE,CAAC;QAClB,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAClC,OAAO,CAAC,GAAG,CAAC,gBAAgB,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;QAC3C,MAAM,GAAG,CAAC;IACZ,CAAC;AACH,CAAC","names":[],"sources":["/home/runner/workspace/utils/helpers/moduleReloader.ts"],"sourcesContent":["/**\n * Module Reloading Utility - TypeScript Implementation\n * \n * This module provides functionality for reloading modules from Node.js cache\n * for isolated testing scenarios. It focuses solely on module cache management.\n */\n\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n// For ES modules, we need to get __dirname equivalent\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Thread-safe module reloading lock to prevent race conditions\nconst moduleReloadLock = new Set<string>();\n\n/**\n * Reload a module from cache for isolated testing\n * \n * This function clears a module from Node.js require cache and reloads it,\n * enabling tests to verify module loading behavior and ensure fresh module\n * state between tests.\n * \n * Note: In ES modules, dynamic imports don't have the same caching behavior as CommonJS require.\n * This function provides a compatibility layer for testing scenarios.\n * \n * @param relPath - Relative path to module that should be reloaded\n * @returns The freshly loaded module object\n * @throws Error if module cannot be found or loaded\n */\nasync function reload(relPath: string): Promise<any> {\n  console.log(`reload is running with ${relPath}`);\n\n  // Resolve relative to the utils directory (parent of helpers)\n  const fullPath = path.resolve(__dirname, '..', relPath);\n\n  if (moduleReloadLock.has(fullPath)) {\n    console.log(`reload has run resulting in skip`);\n    try {\n      return await import(fullPath);\n    } catch (error: any) {\n      console.log(`reload error during skip: ${error.message}`);\n      throw error;\n    }\n  }\n\n  try {\n    moduleReloadLock.add(fullPath);\n    \n    // For ES modules, we use dynamic import with cache busting\n    const cacheBuster = `?t=${Date.now()}`;\n    const moduleUrl = `${fullPath}${cacheBuster}`;\n    const mod = await import(moduleUrl);\n    \n    moduleReloadLock.delete(fullPath);\n    console.log(`reload is returning module`);\n    return mod;\n  } catch (err: any) {\n    moduleReloadLock.delete(fullPath);\n    console.log(`reload error ${err.message}`);\n    throw err;\n  }\n}\n\n// Export module reloading utilities using ES module syntax\nexport {\n  reload,\n  moduleReloadLock\n};"],"version":3}