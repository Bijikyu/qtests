51c85418420b73cb0c0d09b8c78e8d04
"use strict";
/**
 * Logging Utilities for Function Call Tracing
 *
 * Provides standardized logging for function entry and exit points throughout
 * the qtests module. This is essential for debugging test setup issues and
 * understanding the flow of mock creation and cleanup.
 *
 * Design philosophy:
 * - Consistent format: all logs follow the same pattern for easy parsing
 * - Minimal overhead: simple console output without external dependencies
 * - Debugging focus: optimized for troubleshooting rather than production
 * - JSON serialization: handles complex arguments safely
 *
 * Why dedicated logging utilities:
 * - Consistent formatting across all qtests functions
 * - Easy to disable by modifying this single file
 * - Helps users understand what qtests is doing during test setup
 * - Essential for debugging complex test environment issues
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logStart = logStart;
exports.logReturn = logReturn;
exports.executeWithLogs = executeWithLogs;
exports.safeSerialize = safeSerialize;
exports.setLogging = setLogging;
// Import util for safe inspection fallback
const util_1 = __importDefault(require("util"));
let LOG_ENABLED = true; // global log flag default true
function setLogging(enabled) {
    LOG_ENABLED = enabled; // update flag state
}
/**
 * Safely converts values to strings for logging
 *
 * Attempts JSON serialization first, then falls back to util.inspect.
 * Returns '[unserializable]' if both methods fail.
 *
 * @param value - Value to serialize for log output
 * @returns Serialized representation
 */
function safeSerialize(value) {
    if (value === undefined)
        return 'undefined'; // handle undefined explicitly for clarity
    try {
        // Attempt JSON serialization as primary strategy for most values
        // JSON.stringify chosen first because it produces clean, readable output
        // Handles primitive types, arrays, and plain objects efficiently
        // Fails gracefully on circular references, functions, symbols
        const serialized = JSON.stringify(value);
        if (serialized !== undefined)
            return serialized; // check for unsupported types
        const inspected = util_1.default.inspect(value, { depth: null }); // fallback for functions or symbols
        return inspected;
    }
    catch (error) {
        // Handle JSON serialization failures with util.inspect fallback
        // Common failures: circular references, BigInt
        try {
            // Use util.inspect for complex objects that JSON.stringify cannot handle
            const inspected = util_1.default.inspect(value, {
                depth: null,
                showHidden: false,
                colors: false,
                customInspect: true,
                showProxy: true,
                maxArrayLength: 100,
                maxStringLength: 100,
                breakLength: 80,
                compact: true,
                sorted: false,
                getters: false
            });
            return inspected;
        }
        catch (inspectError) {
            // Final fallback when both JSON and util.inspect fail
            // This should be extremely rare but provides safety
            return '[unserializable]';
        }
    }
}
/**
 * Logs function entry with name and arguments
 *
 * @param name - Function name for identification
 * @param args - Function arguments to serialize and log
 */
function logStart(name, ...args) {
    if (!LOG_ENABLED)
        return; // respect global log flag
    const serializedArgs = args.map(arg => safeSerialize(arg)).join(', ');
    console.log(`${name}(${serializedArgs})`);
}
/**
 * Logs function return value
 *
 * @param name - Function name for identification
 * @param value - Return value to serialize and log
 */
function logReturn(name, value) {
    if (!LOG_ENABLED)
        return; // respect global log flag
    const serializedValue = safeSerialize(value);
    console.log(`${name} -> ${serializedValue}`);
}
/**
 * Executes a function with entry/exit logging
 *
 * Provides automatic logging wrapper for functions that need
 * detailed execution tracing for debugging purposes.
 *
 * @param name - Function name for log identification
 * @param fn - Function to execute with logging
 * @param args - Arguments to pass to the function
 * @returns The result of the function execution
 */
function executeWithLogs(name, fn, ...args) {
    try {
        // Log function entry with arguments for debugging visibility
        // This helps track the sequence of function calls during test setup
        logStart(name, ...args);
        // Execute the wrapped function with provided arguments
        // Function execution is not modified, only instrumented with logging
        const result = fn(...args);
        // Log function exit with return value for completeness
        // Return value logging helps verify expected function behavior
        logReturn(name, result);
        return result;
    }
    catch (error) {
        // Log errors for debugging while preserving original error handling
        // Error message logging helps identify issues in wrapped function execution
        // Re-throwing maintains original error handling contract while adding diagnostics
        if (LOG_ENABLED)
            console.log(`${name} encountered ${error.message}`);
        console.log(`executeWithLogs error: ${error.message}`);
        throw error;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvbG9nVXRpbHMudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkc7Ozs7O0FBdUhNLDRCQUFRO0FBQUUsOEJBQVM7QUFBRSwwQ0FBZTtBQUFFLHNDQUFhO0FBQUUsZ0NBQVU7QUFySHhFLDJDQUEyQztBQUMzQyxnREFBd0I7QUFFeEIsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUMsK0JBQStCO0FBRXZELFNBQVMsVUFBVSxDQUFDLE9BQWdCO0lBQ2xDLFdBQVcsR0FBRyxPQUFPLENBQUMsQ0FBQyxvQkFBb0I7QUFDN0MsQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsU0FBUyxhQUFhLENBQUMsS0FBVTtJQUMvQixJQUFJLEtBQUssS0FBSyxTQUFTO1FBQUUsT0FBTyxXQUFXLENBQUMsQ0FBQywwQ0FBMEM7SUFDdkYsSUFBSSxDQUFDO1FBQ0gsaUVBQWlFO1FBQ2pFLHlFQUF5RTtRQUN6RSxpRUFBaUU7UUFDakUsOERBQThEO1FBQzlELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekMsSUFBSSxVQUFVLEtBQUssU0FBUztZQUFFLE9BQU8sVUFBVSxDQUFDLENBQUMsOEJBQThCO1FBQy9FLE1BQU0sU0FBUyxHQUFHLGNBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxvQ0FBb0M7UUFDNUYsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDZixnRUFBZ0U7UUFDaEUsK0NBQStDO1FBQy9DLElBQUksQ0FBQztZQUNILHlFQUF5RTtZQUN6RSxNQUFNLFNBQVMsR0FBRyxjQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRTtnQkFDcEMsS0FBSyxFQUFFLElBQUk7Z0JBQ1gsVUFBVSxFQUFFLEtBQUs7Z0JBQ2pCLE1BQU0sRUFBRSxLQUFLO2dCQUNiLGFBQWEsRUFBRSxJQUFJO2dCQUNuQixTQUFTLEVBQUUsSUFBSTtnQkFDZixjQUFjLEVBQUUsR0FBRztnQkFDbkIsZUFBZSxFQUFFLEdBQUc7Z0JBQ3BCLFdBQVcsRUFBRSxFQUFFO2dCQUNmLE9BQU8sRUFBRSxJQUFJO2dCQUNiLE1BQU0sRUFBRSxLQUFLO2dCQUNiLE9BQU8sRUFBRSxLQUFLO2FBQ2YsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQztRQUFDLE9BQU8sWUFBWSxFQUFFLENBQUM7WUFDdEIsc0RBQXNEO1lBQ3RELG9EQUFvRDtZQUNwRCxPQUFPLGtCQUFrQixDQUFDO1FBQzVCLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxRQUFRLENBQUMsSUFBWSxFQUFFLEdBQUcsSUFBVztJQUM1QyxJQUFJLENBQUMsV0FBVztRQUFFLE9BQU8sQ0FBQywwQkFBMEI7SUFDcEQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN0RSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxJQUFJLGNBQWMsR0FBRyxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxTQUFTLENBQUMsSUFBWSxFQUFFLEtBQVU7SUFDekMsSUFBSSxDQUFDLFdBQVc7UUFBRSxPQUFPLENBQUMsMEJBQTBCO0lBQ3BELE1BQU0sZUFBZSxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxPQUFPLGVBQWUsRUFBRSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFTLGVBQWUsQ0FBSSxJQUFZLEVBQUUsRUFBeUIsRUFBRSxHQUFHLElBQVc7SUFDakYsSUFBSSxDQUFDO1FBQ0gsNkRBQTZEO1FBQzdELG9FQUFvRTtRQUNwRSxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFFeEIsdURBQXVEO1FBQ3ZELHFFQUFxRTtRQUNyRSxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUUzQix1REFBdUQ7UUFDdkQsK0RBQStEO1FBQy9ELFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFeEIsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUFDLE9BQU8sS0FBVSxFQUFFLENBQUM7UUFDcEIsb0VBQW9FO1FBQ3BFLDRFQUE0RTtRQUM1RSxrRkFBa0Y7UUFDbEYsSUFBSSxXQUFXO1lBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksZ0JBQWdCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3JFLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZELE1BQU0sS0FBSyxDQUFDO0lBQ2QsQ0FBQztBQUNILENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvbG9nVXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2dnaW5nIFV0aWxpdGllcyBmb3IgRnVuY3Rpb24gQ2FsbCBUcmFjaW5nXG4gKiBcbiAqIFByb3ZpZGVzIHN0YW5kYXJkaXplZCBsb2dnaW5nIGZvciBmdW5jdGlvbiBlbnRyeSBhbmQgZXhpdCBwb2ludHMgdGhyb3VnaG91dFxuICogdGhlIHF0ZXN0cyBtb2R1bGUuIFRoaXMgaXMgZXNzZW50aWFsIGZvciBkZWJ1Z2dpbmcgdGVzdCBzZXR1cCBpc3N1ZXMgYW5kXG4gKiB1bmRlcnN0YW5kaW5nIHRoZSBmbG93IG9mIG1vY2sgY3JlYXRpb24gYW5kIGNsZWFudXAuXG4gKiBcbiAqIERlc2lnbiBwaGlsb3NvcGh5OlxuICogLSBDb25zaXN0ZW50IGZvcm1hdDogYWxsIGxvZ3MgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm4gZm9yIGVhc3kgcGFyc2luZ1xuICogLSBNaW5pbWFsIG92ZXJoZWFkOiBzaW1wbGUgY29uc29sZSBvdXRwdXQgd2l0aG91dCBleHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqIC0gRGVidWdnaW5nIGZvY3VzOiBvcHRpbWl6ZWQgZm9yIHRyb3VibGVzaG9vdGluZyByYXRoZXIgdGhhbiBwcm9kdWN0aW9uXG4gKiAtIEpTT04gc2VyaWFsaXphdGlvbjogaGFuZGxlcyBjb21wbGV4IGFyZ3VtZW50cyBzYWZlbHlcbiAqIFxuICogV2h5IGRlZGljYXRlZCBsb2dnaW5nIHV0aWxpdGllczpcbiAqIC0gQ29uc2lzdGVudCBmb3JtYXR0aW5nIGFjcm9zcyBhbGwgcXRlc3RzIGZ1bmN0aW9uc1xuICogLSBFYXN5IHRvIGRpc2FibGUgYnkgbW9kaWZ5aW5nIHRoaXMgc2luZ2xlIGZpbGVcbiAqIC0gSGVscHMgdXNlcnMgdW5kZXJzdGFuZCB3aGF0IHF0ZXN0cyBpcyBkb2luZyBkdXJpbmcgdGVzdCBzZXR1cFxuICogLSBFc3NlbnRpYWwgZm9yIGRlYnVnZ2luZyBjb21wbGV4IHRlc3QgZW52aXJvbm1lbnQgaXNzdWVzXG4gKi9cblxuLy8gSW1wb3J0IHV0aWwgZm9yIHNhZmUgaW5zcGVjdGlvbiBmYWxsYmFja1xuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCc7XG5cbmxldCBMT0dfRU5BQkxFRCA9IHRydWU7IC8vIGdsb2JhbCBsb2cgZmxhZyBkZWZhdWx0IHRydWVcblxuZnVuY3Rpb24gc2V0TG9nZ2luZyhlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gIExPR19FTkFCTEVEID0gZW5hYmxlZDsgLy8gdXBkYXRlIGZsYWcgc3RhdGVcbn1cblxuLyoqXG4gKiBTYWZlbHkgY29udmVydHMgdmFsdWVzIHRvIHN0cmluZ3MgZm9yIGxvZ2dpbmdcbiAqXG4gKiBBdHRlbXB0cyBKU09OIHNlcmlhbGl6YXRpb24gZmlyc3QsIHRoZW4gZmFsbHMgYmFjayB0byB1dGlsLmluc3BlY3QuXG4gKiBSZXR1cm5zICdbdW5zZXJpYWxpemFibGVdJyBpZiBib3RoIG1ldGhvZHMgZmFpbC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBzZXJpYWxpemUgZm9yIGxvZyBvdXRwdXRcbiAqIEByZXR1cm5zIFNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gc2FmZVNlcmlhbGl6ZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJzsgLy8gaGFuZGxlIHVuZGVmaW5lZCBleHBsaWNpdGx5IGZvciBjbGFyaXR5XG4gIHRyeSB7XG4gICAgLy8gQXR0ZW1wdCBKU09OIHNlcmlhbGl6YXRpb24gYXMgcHJpbWFyeSBzdHJhdGVneSBmb3IgbW9zdCB2YWx1ZXNcbiAgICAvLyBKU09OLnN0cmluZ2lmeSBjaG9zZW4gZmlyc3QgYmVjYXVzZSBpdCBwcm9kdWNlcyBjbGVhbiwgcmVhZGFibGUgb3V0cHV0XG4gICAgLy8gSGFuZGxlcyBwcmltaXRpdmUgdHlwZXMsIGFycmF5cywgYW5kIHBsYWluIG9iamVjdHMgZWZmaWNpZW50bHlcbiAgICAvLyBGYWlscyBncmFjZWZ1bGx5IG9uIGNpcmN1bGFyIHJlZmVyZW5jZXMsIGZ1bmN0aW9ucywgc3ltYm9sc1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKHNlcmlhbGl6ZWQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHNlcmlhbGl6ZWQ7IC8vIGNoZWNrIGZvciB1bnN1cHBvcnRlZCB0eXBlc1xuICAgIGNvbnN0IGluc3BlY3RlZCA9IHV0aWwuaW5zcGVjdCh2YWx1ZSwgeyBkZXB0aDogbnVsbCB9KTsgLy8gZmFsbGJhY2sgZm9yIGZ1bmN0aW9ucyBvciBzeW1ib2xzXG4gICAgcmV0dXJuIGluc3BlY3RlZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBIYW5kbGUgSlNPTiBzZXJpYWxpemF0aW9uIGZhaWx1cmVzIHdpdGggdXRpbC5pbnNwZWN0IGZhbGxiYWNrXG4gICAgLy8gQ29tbW9uIGZhaWx1cmVzOiBjaXJjdWxhciByZWZlcmVuY2VzLCBCaWdJbnRcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIHV0aWwuaW5zcGVjdCBmb3IgY29tcGxleCBvYmplY3RzIHRoYXQgSlNPTi5zdHJpbmdpZnkgY2Fubm90IGhhbmRsZVxuICAgICAgY29uc3QgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlLCB7IFxuICAgICAgICBkZXB0aDogbnVsbCxcbiAgICAgICAgc2hvd0hpZGRlbjogZmFsc2UsXG4gICAgICAgIGNvbG9yczogZmFsc2UsXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IHRydWUsXG4gICAgICAgIHNob3dQcm94eTogdHJ1ZSxcbiAgICAgICAgbWF4QXJyYXlMZW5ndGg6IDEwMCxcbiAgICAgICAgbWF4U3RyaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgIGJyZWFrTGVuZ3RoOiA4MCxcbiAgICAgICAgY29tcGFjdDogdHJ1ZSxcbiAgICAgICAgc29ydGVkOiBmYWxzZSxcbiAgICAgICAgZ2V0dGVyczogZmFsc2UgXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbnNwZWN0ZWQ7XG4gICAgfSBjYXRjaCAoaW5zcGVjdEVycm9yKSB7XG4gICAgICAvLyBGaW5hbCBmYWxsYmFjayB3aGVuIGJvdGggSlNPTiBhbmQgdXRpbC5pbnNwZWN0IGZhaWxcbiAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGV4dHJlbWVseSByYXJlIGJ1dCBwcm92aWRlcyBzYWZldHlcbiAgICAgIHJldHVybiAnW3Vuc2VyaWFsaXphYmxlXSc7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTG9ncyBmdW5jdGlvbiBlbnRyeSB3aXRoIG5hbWUgYW5kIGFyZ3VtZW50c1xuICpcbiAqIEBwYXJhbSBuYW1lIC0gRnVuY3Rpb24gbmFtZSBmb3IgaWRlbnRpZmljYXRpb25cbiAqIEBwYXJhbSBhcmdzIC0gRnVuY3Rpb24gYXJndW1lbnRzIHRvIHNlcmlhbGl6ZSBhbmQgbG9nXG4gKi9cbmZ1bmN0aW9uIGxvZ1N0YXJ0KG5hbWU6IHN0cmluZywgLi4uYXJnczogYW55W10pOiB2b2lkIHtcbiAgaWYgKCFMT0dfRU5BQkxFRCkgcmV0dXJuOyAvLyByZXNwZWN0IGdsb2JhbCBsb2cgZmxhZ1xuICBjb25zdCBzZXJpYWxpemVkQXJncyA9IGFyZ3MubWFwKGFyZyA9PiBzYWZlU2VyaWFsaXplKGFyZykpLmpvaW4oJywgJyk7XG4gIGNvbnNvbGUubG9nKGAke25hbWV9KCR7c2VyaWFsaXplZEFyZ3N9KWApO1xufVxuXG4vKipcbiAqIExvZ3MgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gKlxuICogQHBhcmFtIG5hbWUgLSBGdW5jdGlvbiBuYW1lIGZvciBpZGVudGlmaWNhdGlvbiAgXG4gKiBAcGFyYW0gdmFsdWUgLSBSZXR1cm4gdmFsdWUgdG8gc2VyaWFsaXplIGFuZCBsb2dcbiAqL1xuZnVuY3Rpb24gbG9nUmV0dXJuKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSk6IHZvaWQge1xuICBpZiAoIUxPR19FTkFCTEVEKSByZXR1cm47IC8vIHJlc3BlY3QgZ2xvYmFsIGxvZyBmbGFnXG4gIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IHNhZmVTZXJpYWxpemUodmFsdWUpO1xuICBjb25zb2xlLmxvZyhgJHtuYW1lfSAtPiAke3NlcmlhbGl6ZWRWYWx1ZX1gKTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIHdpdGggZW50cnkvZXhpdCBsb2dnaW5nXG4gKlxuICogUHJvdmlkZXMgYXV0b21hdGljIGxvZ2dpbmcgd3JhcHBlciBmb3IgZnVuY3Rpb25zIHRoYXQgbmVlZFxuICogZGV0YWlsZWQgZXhlY3V0aW9uIHRyYWNpbmcgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIEZ1bmN0aW9uIG5hbWUgZm9yIGxvZyBpZGVudGlmaWNhdGlvblxuICogQHBhcmFtIGZuIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoIGxvZ2dpbmdcbiAqIEBwYXJhbSBhcmdzIC0gQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBleGVjdXRpb25cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZVdpdGhMb2dzPFQ+KG5hbWU6IHN0cmluZywgZm46ICguLi5hcmdzOiBhbnlbXSkgPT4gVCwgLi4uYXJnczogYW55W10pOiBUIHtcbiAgdHJ5IHtcbiAgICAvLyBMb2cgZnVuY3Rpb24gZW50cnkgd2l0aCBhcmd1bWVudHMgZm9yIGRlYnVnZ2luZyB2aXNpYmlsaXR5XG4gICAgLy8gVGhpcyBoZWxwcyB0cmFjayB0aGUgc2VxdWVuY2Ugb2YgZnVuY3Rpb24gY2FsbHMgZHVyaW5nIHRlc3Qgc2V0dXBcbiAgICBsb2dTdGFydChuYW1lLCAuLi5hcmdzKTtcbiAgICBcbiAgICAvLyBFeGVjdXRlIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHdpdGggcHJvdmlkZWQgYXJndW1lbnRzXG4gICAgLy8gRnVuY3Rpb24gZXhlY3V0aW9uIGlzIG5vdCBtb2RpZmllZCwgb25seSBpbnN0cnVtZW50ZWQgd2l0aCBsb2dnaW5nXG4gICAgY29uc3QgcmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgXG4gICAgLy8gTG9nIGZ1bmN0aW9uIGV4aXQgd2l0aCByZXR1cm4gdmFsdWUgZm9yIGNvbXBsZXRlbmVzc1xuICAgIC8vIFJldHVybiB2YWx1ZSBsb2dnaW5nIGhlbHBzIHZlcmlmeSBleHBlY3RlZCBmdW5jdGlvbiBiZWhhdmlvclxuICAgIGxvZ1JldHVybihuYW1lLCByZXN1bHQpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBMb2cgZXJyb3JzIGZvciBkZWJ1Z2dpbmcgd2hpbGUgcHJlc2VydmluZyBvcmlnaW5hbCBlcnJvciBoYW5kbGluZ1xuICAgIC8vIEVycm9yIG1lc3NhZ2UgbG9nZ2luZyBoZWxwcyBpZGVudGlmeSBpc3N1ZXMgaW4gd3JhcHBlZCBmdW5jdGlvbiBleGVjdXRpb25cbiAgICAvLyBSZS10aHJvd2luZyBtYWludGFpbnMgb3JpZ2luYWwgZXJyb3IgaGFuZGxpbmcgY29udHJhY3Qgd2hpbGUgYWRkaW5nIGRpYWdub3N0aWNzXG4gICAgaWYgKExPR19FTkFCTEVEKSBjb25zb2xlLmxvZyhgJHtuYW1lfSBlbmNvdW50ZXJlZCAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgY29uc29sZS5sb2coYGV4ZWN1dGVXaXRoTG9ncyBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIEV4cG9ydCBhbGwgbG9nZ2luZyB1dGlsaXRpZXMgdXNpbmcgRVMgbW9kdWxlIHN5bnRheFxuZXhwb3J0IHsgbG9nU3RhcnQsIGxvZ1JldHVybiwgZXhlY3V0ZVdpdGhMb2dzLCBzYWZlU2VyaWFsaXplLCBzZXRMb2dnaW5nIH07Il0sInZlcnNpb24iOjN9