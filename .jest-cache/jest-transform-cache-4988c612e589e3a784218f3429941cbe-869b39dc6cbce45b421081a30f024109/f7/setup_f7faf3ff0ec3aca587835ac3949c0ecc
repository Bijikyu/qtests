82998f8c8946681a6005dfb457308014
"use strict";
/**
 * qtests Setup Module - Global Node.js Module Resolution Modification - TypeScript Implementation
 *
 * This module modifies Node.js's global module resolution behavior to automatically
 * substitute stub implementations for real modules during testing. It's a critical
 * piece of the qtests framework that enables seamless testing without changing
 * application code.
 *
 * Core functionality:
 * When this module is required, it patches Node.js's Module._resolveFilename method
 * to intercept require() calls and redirect them to stub implementations when
 * appropriate. This allows test code to use the same require() statements as
 * production code while getting test-appropriate implementations.
 *
 * Design philosophy:
 * - Transparent operation: Application code doesn't need to change
 * - Automatic stub resolution: No manual require() path changes needed
 * - Safe operation: Only affects specific modules, others work normally
 * - Performance conscious: Minimal overhead on module resolution
 *
 * Security and safety considerations:
 * - Only affects modules in the predefined stub registry
 * - Original Node.js behavior preserved for unlisted modules
 * - Changes are temporary and isolated to test execution
 * - No permanent modifications to Node.js installation
 * - Easy to disable by not requiring this module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupComplete = void 0;
// Import Node.js Module constructor for accessing module resolution internals
// This gives us access to the private _resolveFilename method that controls
// how Node.js resolves module names to file paths
const module_1 = require("module");
const path_1 = __importDefault(require("path"));
const url_1 = require("url");
const require = (0, module_1.createRequire)(import.meta.url);
const Module = require('module');
// Get current directory for ES modules
const __dirname = path_1.default.dirname((0, url_1.fileURLToPath)(import.meta.url));
const stubsPath = path_1.default.join(__dirname, 'stubs');
const STUB_REGISTRY = {
    axios: 'axios.js', // HTTP client library stub file name for quick lookup
    winston: 'winston.js' // logging library stub file name for quick lookup
};
// Preserve existing NODE_PATH if it exists
const currentNodePath = process.env.NODE_PATH || '';
// Determine correct path separator for current platform
const separator = process.platform === 'win32' ? ';' : ':';
// Prepend our stubs directory to NODE_PATH
process.env.NODE_PATH = stubsPath + (currentNodePath ? separator + currentNodePath : '');
// Force Node.js to recognize the updated NODE_PATH for dynamic module resolution
require('module')._initPaths();
// Store original Module._load function for delegation to maintain normal module loading behavior
const origLoad = Module._load;
/**
 * Enhanced Module._load replacement that handles stub substitution
 *
 * This function intercepts all module loading requests and redirects known
 * modules to their stub implementations when appropriate.
 */
Module._load = function (id, parent, isMain) {
    // Check if this module should be stubbed
    if (STUB_REGISTRY[id]) {
        const stubPath = path_1.default.join(stubsPath, STUB_REGISTRY[id]);
        try {
            // Load the stub module instead of the real one
            return origLoad.call(this, stubPath, parent, isMain);
        }
        catch (error) {
            console.log(`qtests: Failed to load stub for ${id} from ${stubPath}, falling back to original`);
            // Fall back to original module if stub loading fails
            return origLoad.call(this, id, parent, isMain);
        }
    }
    // For non-stubbed modules, use original behavior
    return origLoad.call(this, id, parent, isMain);
};
console.log('qtests: Global module resolution patching activated');
console.log(`qtests: Stub registry contains: ${Object.keys(STUB_REGISTRY).join(', ')}`);
console.log(`qtests: Stubs directory: ${stubsPath}`);
// Export setup completion indicator
exports.setupComplete = true;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxDQUFDO0FBRXJELG9DQUFvQztBQUN2QixRQUFBLGFBQWEsR0FBRyxJQUFJLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9zZXR1cC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHF0ZXN0cyBTZXR1cCBNb2R1bGUgLSBHbG9iYWwgTm9kZS5qcyBNb2R1bGUgUmVzb2x1dGlvbiBNb2RpZmljYXRpb24gLSBUeXBlU2NyaXB0IEltcGxlbWVudGF0aW9uXG4gKiBcbiAqIFRoaXMgbW9kdWxlIG1vZGlmaWVzIE5vZGUuanMncyBnbG9iYWwgbW9kdWxlIHJlc29sdXRpb24gYmVoYXZpb3IgdG8gYXV0b21hdGljYWxseVxuICogc3Vic3RpdHV0ZSBzdHViIGltcGxlbWVudGF0aW9ucyBmb3IgcmVhbCBtb2R1bGVzIGR1cmluZyB0ZXN0aW5nLiBJdCdzIGEgY3JpdGljYWxcbiAqIHBpZWNlIG9mIHRoZSBxdGVzdHMgZnJhbWV3b3JrIHRoYXQgZW5hYmxlcyBzZWFtbGVzcyB0ZXN0aW5nIHdpdGhvdXQgY2hhbmdpbmdcbiAqIGFwcGxpY2F0aW9uIGNvZGUuXG4gKiBcbiAqIENvcmUgZnVuY3Rpb25hbGl0eTpcbiAqIFdoZW4gdGhpcyBtb2R1bGUgaXMgcmVxdWlyZWQsIGl0IHBhdGNoZXMgTm9kZS5qcydzIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lIG1ldGhvZFxuICogdG8gaW50ZXJjZXB0IHJlcXVpcmUoKSBjYWxscyBhbmQgcmVkaXJlY3QgdGhlbSB0byBzdHViIGltcGxlbWVudGF0aW9ucyB3aGVuXG4gKiBhcHByb3ByaWF0ZS4gVGhpcyBhbGxvd3MgdGVzdCBjb2RlIHRvIHVzZSB0aGUgc2FtZSByZXF1aXJlKCkgc3RhdGVtZW50cyBhc1xuICogcHJvZHVjdGlvbiBjb2RlIHdoaWxlIGdldHRpbmcgdGVzdC1hcHByb3ByaWF0ZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBcbiAqIERlc2lnbiBwaGlsb3NvcGh5OlxuICogLSBUcmFuc3BhcmVudCBvcGVyYXRpb246IEFwcGxpY2F0aW9uIGNvZGUgZG9lc24ndCBuZWVkIHRvIGNoYW5nZVxuICogLSBBdXRvbWF0aWMgc3R1YiByZXNvbHV0aW9uOiBObyBtYW51YWwgcmVxdWlyZSgpIHBhdGggY2hhbmdlcyBuZWVkZWRcbiAqIC0gU2FmZSBvcGVyYXRpb246IE9ubHkgYWZmZWN0cyBzcGVjaWZpYyBtb2R1bGVzLCBvdGhlcnMgd29yayBub3JtYWxseVxuICogLSBQZXJmb3JtYW5jZSBjb25zY2lvdXM6IE1pbmltYWwgb3ZlcmhlYWQgb24gbW9kdWxlIHJlc29sdXRpb25cbiAqIFxuICogU2VjdXJpdHkgYW5kIHNhZmV0eSBjb25zaWRlcmF0aW9uczpcbiAqIC0gT25seSBhZmZlY3RzIG1vZHVsZXMgaW4gdGhlIHByZWRlZmluZWQgc3R1YiByZWdpc3RyeVxuICogLSBPcmlnaW5hbCBOb2RlLmpzIGJlaGF2aW9yIHByZXNlcnZlZCBmb3IgdW5saXN0ZWQgbW9kdWxlc1xuICogLSBDaGFuZ2VzIGFyZSB0ZW1wb3JhcnkgYW5kIGlzb2xhdGVkIHRvIHRlc3QgZXhlY3V0aW9uXG4gKiAtIE5vIHBlcm1hbmVudCBtb2RpZmljYXRpb25zIHRvIE5vZGUuanMgaW5zdGFsbGF0aW9uXG4gKiAtIEVhc3kgdG8gZGlzYWJsZSBieSBub3QgcmVxdWlyaW5nIHRoaXMgbW9kdWxlXG4gKi9cblxuLy8gSW1wb3J0IE5vZGUuanMgTW9kdWxlIGNvbnN0cnVjdG9yIGZvciBhY2Nlc3NpbmcgbW9kdWxlIHJlc29sdXRpb24gaW50ZXJuYWxzXG4vLyBUaGlzIGdpdmVzIHVzIGFjY2VzcyB0byB0aGUgcHJpdmF0ZSBfcmVzb2x2ZUZpbGVuYW1lIG1ldGhvZCB0aGF0IGNvbnRyb2xzXG4vLyBob3cgTm9kZS5qcyByZXNvbHZlcyBtb2R1bGUgbmFtZXMgdG8gZmlsZSBwYXRoc1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ21vZHVsZSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICd1cmwnO1xuXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuY29uc3QgTW9kdWxlID0gcmVxdWlyZSgnbW9kdWxlJyk7XG5cbi8vIEdldCBjdXJyZW50IGRpcmVjdG9yeSBmb3IgRVMgbW9kdWxlc1xuY29uc3QgX19kaXJuYW1lID0gcGF0aC5kaXJuYW1lKGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKSk7XG5jb25zdCBzdHVic1BhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnc3R1YnMnKTtcblxuLyoqXG4gKiBNb2R1bGUgc3R1YiByZWdpc3RyeSAtIGRlZmluZXMgd2hpY2ggbW9kdWxlcyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBzdHVic1xuICogXG4gKiBUaGlzIG9iamVjdCBtYXBzIHJlYWwgbW9kdWxlIG5hbWVzIHRvIHRoZWlyIHN0dWIgaW1wbGVtZW50YXRpb24gcGF0aHMuXG4gKiBXaGVuIE5vZGUuanMgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBhIG1vZHVsZSBsaXN0ZWQgaW4gdGhpcyByZWdpc3RyeSxcbiAqIHRoZSBzdHViIHBhdGggd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIHRoZSByZWFsIG1vZHVsZSBwYXRoLlxuICovXG5pbnRlcmZhY2UgU3R1YlJlZ2lzdHJ5IHtcbiAgW21vZHVsZU5hbWU6IHN0cmluZ106IHN0cmluZztcbn1cblxuY29uc3QgU1RVQl9SRUdJU1RSWTogU3R1YlJlZ2lzdHJ5ID0ge1xuICBheGlvczogJ2F4aW9zLmpzJywgLy8gSFRUUCBjbGllbnQgbGlicmFyeSBzdHViIGZpbGUgbmFtZSBmb3IgcXVpY2sgbG9va3VwXG4gIHdpbnN0b246ICd3aW5zdG9uLmpzJyAvLyBsb2dnaW5nIGxpYnJhcnkgc3R1YiBmaWxlIG5hbWUgZm9yIHF1aWNrIGxvb2t1cFxufTtcblxuLy8gUHJlc2VydmUgZXhpc3RpbmcgTk9ERV9QQVRIIGlmIGl0IGV4aXN0c1xuY29uc3QgY3VycmVudE5vZGVQYXRoID0gcHJvY2Vzcy5lbnYuTk9ERV9QQVRIIHx8ICcnO1xuXG4vLyBEZXRlcm1pbmUgY29ycmVjdCBwYXRoIHNlcGFyYXRvciBmb3IgY3VycmVudCBwbGF0Zm9ybVxuY29uc3Qgc2VwYXJhdG9yID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6JztcblxuLy8gUHJlcGVuZCBvdXIgc3R1YnMgZGlyZWN0b3J5IHRvIE5PREVfUEFUSFxucHJvY2Vzcy5lbnYuTk9ERV9QQVRIID0gc3R1YnNQYXRoICsgKGN1cnJlbnROb2RlUGF0aCA/IHNlcGFyYXRvciArIGN1cnJlbnROb2RlUGF0aCA6ICcnKTtcblxuLy8gRm9yY2UgTm9kZS5qcyB0byByZWNvZ25pemUgdGhlIHVwZGF0ZWQgTk9ERV9QQVRIIGZvciBkeW5hbWljIG1vZHVsZSByZXNvbHV0aW9uXG5yZXF1aXJlKCdtb2R1bGUnKS5faW5pdFBhdGhzKCk7XG5cbi8vIFN0b3JlIG9yaWdpbmFsIE1vZHVsZS5fbG9hZCBmdW5jdGlvbiBmb3IgZGVsZWdhdGlvbiB0byBtYWludGFpbiBub3JtYWwgbW9kdWxlIGxvYWRpbmcgYmVoYXZpb3JcbmNvbnN0IG9yaWdMb2FkID0gTW9kdWxlLl9sb2FkO1xuXG4vKipcbiAqIEVuaGFuY2VkIE1vZHVsZS5fbG9hZCByZXBsYWNlbWVudCB0aGF0IGhhbmRsZXMgc3R1YiBzdWJzdGl0dXRpb25cbiAqIFxuICogVGhpcyBmdW5jdGlvbiBpbnRlcmNlcHRzIGFsbCBtb2R1bGUgbG9hZGluZyByZXF1ZXN0cyBhbmQgcmVkaXJlY3RzIGtub3duXG4gKiBtb2R1bGVzIHRvIHRoZWlyIHN0dWIgaW1wbGVtZW50YXRpb25zIHdoZW4gYXBwcm9wcmlhdGUuXG4gKi9cbk1vZHVsZS5fbG9hZCA9IGZ1bmN0aW9uKGlkOiBzdHJpbmcsIHBhcmVudDogYW55LCBpc01haW4/OiBib29sZWFuKTogYW55IHtcbiAgLy8gQ2hlY2sgaWYgdGhpcyBtb2R1bGUgc2hvdWxkIGJlIHN0dWJiZWRcbiAgaWYgKFNUVUJfUkVHSVNUUllbaWRdKSB7XG4gICAgY29uc3Qgc3R1YlBhdGggPSBwYXRoLmpvaW4oc3R1YnNQYXRoLCBTVFVCX1JFR0lTVFJZW2lkXSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgdGhlIHN0dWIgbW9kdWxlIGluc3RlYWQgb2YgdGhlIHJlYWwgb25lXG4gICAgICByZXR1cm4gb3JpZ0xvYWQuY2FsbCh0aGlzLCBzdHViUGF0aCwgcGFyZW50LCBpc01haW4pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhgcXRlc3RzOiBGYWlsZWQgdG8gbG9hZCBzdHViIGZvciAke2lkfSBmcm9tICR7c3R1YlBhdGh9LCBmYWxsaW5nIGJhY2sgdG8gb3JpZ2luYWxgKTtcbiAgICAgIC8vIEZhbGwgYmFjayB0byBvcmlnaW5hbCBtb2R1bGUgaWYgc3R1YiBsb2FkaW5nIGZhaWxzXG4gICAgICByZXR1cm4gb3JpZ0xvYWQuY2FsbCh0aGlzLCBpZCwgcGFyZW50LCBpc01haW4pO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRm9yIG5vbi1zdHViYmVkIG1vZHVsZXMsIHVzZSBvcmlnaW5hbCBiZWhhdmlvclxuICByZXR1cm4gb3JpZ0xvYWQuY2FsbCh0aGlzLCBpZCwgcGFyZW50LCBpc01haW4pO1xufTtcblxuY29uc29sZS5sb2coJ3F0ZXN0czogR2xvYmFsIG1vZHVsZSByZXNvbHV0aW9uIHBhdGNoaW5nIGFjdGl2YXRlZCcpO1xuY29uc29sZS5sb2coYHF0ZXN0czogU3R1YiByZWdpc3RyeSBjb250YWluczogJHtPYmplY3Qua2V5cyhTVFVCX1JFR0lTVFJZKS5qb2luKCcsICcpfWApO1xuY29uc29sZS5sb2coYHF0ZXN0czogU3R1YnMgZGlyZWN0b3J5OiAke3N0dWJzUGF0aH1gKTtcblxuLy8gRXhwb3J0IHNldHVwIGNvbXBsZXRpb24gaW5kaWNhdG9yXG5leHBvcnQgY29uc3Qgc2V0dXBDb21wbGV0ZSA9IHRydWU7Il0sInZlcnNpb24iOjN9