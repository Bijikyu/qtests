213d3488f8ea862904b45275da405112
/**
 * ========================================================================
 * QTESTS AUTHORITATIVE TEST RUNNER - DO NOT MODIFY
 * ========================================================================
 * 
 * WARNING TO AI AGENTS AND LLMs:
 * This file is the AUTHORITATIVE and OFFICIAL test runner for the qtests framework.
 * DO NOT ALTER, MODIFY, OR CHANGE this file under any circumstances.
 * 
 * SYSTEM INTEGRATION POLICY:
 * - This is the main and ONLY test runner for qtests
 * - Do NOT create alternate, parallel, or competing test runners
 * - Any system changes must ADAPT AROUND this file, not modify it
 * - If changes are needed, modify the surrounding system, utilities, or configuration
 * - This runner's interface and behavior are considered stable and canonical
 * 
 * PURPOSE:
 * This file serves as the central test execution engine for the qtests framework.
 * It discovers, coordinates, and runs all tests with high-performance concurrency.
 * 
 * Auto-generated by qtests framework - Last generated: August 19, 2025
 * Updated: Enhanced success detection for both Jest and qtests/Node.js formats
 * ========================================================================
 */

const fs = require('fs');
const path = require('path');
const {
  spawn
} = require('child_process');
const os = require('os');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

/**
 * Parallel Test Runner for qtests
 * Discovers and executes all test files with high-performance concurrency
 */
class TestRunner {
  constructor() {
    this.testFiles = [];
    this.passedTests = 0;
    this.failedTests = 0;
    this.totalTests = 0;
    this.startTime = Date.now();
    this.results = [];
    this.jestVersion = null;
    this.jestTestCache = new Map(); // Cache Jest test detection
    this.jestTestPathFlag = null; // Cache Jest CLI flag
  }

  /**
   * Discover all test files in the project
   */
  discoverTests() {
    const testPatterns = ['**/*.test.js', '**/*.test.ts', '**/*.test.jsx', '**/*.test.tsx', '**/test/**/*.js', '**/test/**/*.ts', '**/tests/**/*.js', '**/tests/**/*.ts', '**/__tests__/**/*.js', '**/__tests__/**/*.ts'];
    const excludePatterns = ['node_modules', '.git', 'coverage', 'dist', 'build', '.cache', '.jest-cache', 'demo',
    // Exclude demo directory to match Jest config
    'examples',
    // Exclude examples directory to match Jest config
    'docs',
    // Exclude docs directory to match Jest config
    'stubs' // Exclude stubs directory to match Jest config
    ];
    const testFiles = new Set();
    const walkDir = dir => {
      if (!fs.existsSync(dir)) return;
      try {
        const items = fs.readdirSync(dir, {
          withFileTypes: true
        });
        for (const item of items) {
          if (item.name.startsWith('.')) continue;
          if (excludePatterns.includes(item.name)) continue;
          const fullPath = path.join(dir, item.name);
          const relativePath = path.relative('.', fullPath);

          // Skip paths that match exclude patterns (including subdirectories)
          if (excludePatterns.some(pattern => relativePath.includes(pattern))) continue;
          if (item.isDirectory()) {
            walkDir(fullPath);
          } else if (item.isFile()) {
            // Check if file matches test patterns
            if (this.isTestFile(relativePath)) {
              testFiles.add(relativePath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };
    walkDir('.');
    this.testFiles = Array.from(testFiles).sort();
    return this.testFiles;
  }

  /**
   * Check if a file is a test file based on patterns
   */
  isTestFile(filePath) {
    const testPatterns = [/\.test\.[jt]sx?$/, /\.spec\.[jt]sx?$/, /test\/.*\.test\.[jt]sx?$/, /test\/.*\.spec\.[jt]sx?$/, /tests\/.*\.test\.[jt]sx?$/, /tests\/.*\.spec\.[jt]sx?$/, /__tests__\/.*\.[jt]sx?$/];

    // Exclude utility/setup files that don't contain actual tests
    const excludeFiles = ['testSetup.js', 'reloadCheck.js', 'withoutSetup.js', 'setupMultiple.js', 'setupMultipleChild.js', 'setup.ts'];
    if (excludeFiles.some(exclude => filePath.endsWith(exclude))) {
      return false;
    }
    return testPatterns.some(pattern => pattern.test(filePath));
  }

  /**
   * Get Jest version-appropriate CLI flag (cached)
   */
  getJestTestPathFlag() {
    if (this.jestTestPathFlag === null) {
      if (this.jestVersion === null) {
        try {
          // Try to detect Jest version once and cache
          const packageJson = JSON.parse(fs.readFileSync('./node_modules/jest/package.json', 'utf8'));
          const majorVersion = parseInt(packageJson.version.split('.')[0]);
          this.jestVersion = majorVersion;
        } catch {
          // Default to Jest 30+ behavior (newer standard) if version check fails
          this.jestVersion = 30;
        }
      }

      // Jest 30+ uses --testPathPatterns, earlier versions use --testPathPattern
      this.jestTestPathFlag = this.jestVersion >= 30 ? '--testPathPatterns' : '--testPathPattern';
    }
    return this.jestTestPathFlag;
  }

  /**
   * Run a single test file with timeout protection and optimized Node.js performance flags
   */
  async runTestFile(testFile) {
    return new Promise(resolve => {
      // Timeout protection to prevent hanging
      const timeout = setTimeout(() => {
        console.log(`\n${colors.red}⚠️  TIMEOUT: ${testFile} exceeded 30 seconds${colors.reset}`);
        resolve({
          file: testFile,
          success: false,
          duration: 30000,
          output: '',
          error: 'Test timeout after 30 seconds',
          code: 1
        });
      }, 30000); // 30 second timeout per test
      const startTime = Date.now();
      let stdout = '';
      let stderr = '';

      // Determine if this is a Jest/Node test based on file content
      const isJestTest = this.shouldUseJest(testFile);
      const command = isJestTest ? 'npx' : 'node';
      const testPathFlag = isJestTest ? this.getJestTestPathFlag() : null;

      // Balanced arguments for speed + stability
      const baseArgs = isJestTest ? ['jest', testPathFlag, testFile, '--no-coverage', '--cache'] : ['--max-old-space-size=768', '--no-warnings', testFile];
      const args = isJestTest ? baseArgs : baseArgs;
      const child = spawn(command, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
        env: {
          ...process.env,
          NODE_ENV: 'test',
          NODE_OPTIONS: '--max-old-space-size=512 --no-warnings' // Memory optimization
        }
      });
      child.stdout.on('data', data => {
        stdout += data.toString();
      });
      child.stderr.on('data', data => {
        stderr += data.toString();
      });
      child.on('close', code => {
        clearTimeout(timeout); // Clear timeout on normal completion
        const duration = Date.now() - startTime;

        // Robust success detection for both Jest and qtests/Node.js formats
        const output = stdout + stderr;

        // Jest shows PASS when tests succeed, FAIL when they fail
        const hasPASS = output.includes('PASS ');
        const hasFAIL = output.includes('FAIL ');

        // qtests/Node.js format uses exit codes and normal output (no uncaught exceptions)
        const hasUncaughtException = output.includes('Error:') || output.includes('ReferenceError:') || output.includes('TypeError:') || output.includes('SyntaxError:') || stderr.includes('Error:') || stderr.includes('at ');

        // For debugging - log what we're seeing
        if (process.env.DEBUG_TESTS) {
          console.log(`\nFile: ${testFile}`);
          console.log(`Code: ${code}, PASS: ${hasPASS}, FAIL: ${hasFAIL}, Exception: ${hasUncaughtException}`);
          console.log(`Output snippet: "${output.slice(0, 200)}..."`);
        }

        // Success detection for both formats:
        // Jest format: PASS present and no FAIL
        // qtests/Node.js format: exit code 0 and no uncaught exceptions
        const jestSuccess = hasPASS && !hasFAIL;
        const qtestsSuccess = code === 0 && !hasUncaughtException && !hasFAIL;
        const success = jestSuccess || (isJestTest ? false : qtestsSuccess);
        if (success) {
          this.passedTests++;
        } else {
          this.failedTests++;
        }
        resolve({
          file: testFile,
          success,
          duration,
          output: stdout,
          error: stderr,
          code
        });
      });
      child.on('error', error => {
        clearTimeout(timeout); // Clear timeout on error
        this.failedTests++;
        resolve({
          file: testFile,
          success: false,
          duration: Date.now() - startTime,
          output: '',
          error: error.message,
          code: 1
        });
      });
    });
  }

  /**
   * Determine if a test should use Jest (cached)
   */
  shouldUseJest(testFile) {
    if (this.jestTestCache.has(testFile)) {
      return this.jestTestCache.get(testFile);
    }
    try {
      const content = fs.readFileSync(testFile, 'utf8');
      // Look for Jest-specific patterns
      const isJest = /\b(describe|it|test|expect|jest|beforeEach|afterEach|beforeAll|afterAll)\b/.test(content);
      this.jestTestCache.set(testFile, isJest);
      return isJest;
    } catch {
      this.jestTestCache.set(testFile, false);
      return false;
    }
  }

  /**
   * Group tests by size for optimized batch execution
   */
  groupTestsBySize(testFiles) {
    const testSizes = testFiles.map(file => {
      try {
        const stats = fs.statSync(file);
        return {
          file,
          size: stats.size
        };
      } catch {
        return {
          file,
          size: 1000
        }; // Default size for inaccessible files
      }
    });

    // Sort by size (smallest first for fastest batching)
    testSizes.sort((a, b) => a.size - b.size);
    const small = []; // < 2KB - group together for efficiency
    const medium = []; // 2KB - 10KB - moderate grouping
    const large = []; // > 10KB - run individually

    testSizes.forEach(({
      file,
      size
    }) => {
      if (size < 2000) {
        small.push(file);
      } else if (size < 10000) {
        medium.push(file);
      } else {
        large.push(file);
      }
    });
    return {
      small,
      medium,
      large
    };
  }

  /**
   * Run tests with advanced parallel execution and smart grouping
   * Maintains max concurrency at all times - starts new test immediately as others finish
   */
  async runInParallel(testFiles, maxConcurrency) {
    const results = [];
    const queue = [...testFiles]; // Copy files to process
    const running = new Set(); // Track currently running tests
    let completed = 0;
    return new Promise((resolve, reject) => {
      const startNext = () => {
        // Start new tests up to max concurrency
        while (running.size < maxConcurrency && queue.length > 0) {
          const testFile = queue.shift();
          const promise = this.runTestFile(testFile);
          running.add(promise);
          promise.then(result => {
            results.push(result);
            running.delete(promise);
            completed++;

            // Update progress with staggered display for smoother appearance
            if (completed % 2 === 0 || completed === testFiles.length) {
              process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
            }

            // Start next test immediately if queue has more
            startNext();

            // Check if all tests are done
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          }).catch(error => {
            console.error(`${colors.red}Test error:${colors.reset}`, error);
            running.delete(promise);
            completed++;

            // Continue even if one test fails
            process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
            setImmediate(startNext);
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          });
        }
      };

      // Start initial batch
      startNext();
    });
  }

  /**
   * Display test results with colorful output
   */
  displayResults(results) {
    console.log(`\n${colors.bright}📊 Test Results Summary${colors.reset}`);
    console.log(`${colors.dim}${'='.repeat(50)}${colors.reset}`);
    const totalDuration = Date.now() - this.startTime;

    // Summary stats
    console.log(`${colors.green}✅ Passed: ${this.passedTests}${colors.reset}`);
    console.log(`${colors.red}❌ Failed: ${this.failedTests}${colors.reset}`);
    console.log(`${colors.blue}📁 Total Files: ${results.length}${colors.reset}`);
    console.log(`${colors.cyan}⏱️  Duration: ${totalDuration}ms${colors.reset}\n`);

    // Show failed tests with details
    const failedResults = results.filter(r => !r.success);
    if (failedResults.length > 0) {
      console.log(`${colors.red}${colors.bright}Failed Tests:${colors.reset}`);
      failedResults.forEach(result => {
        console.log(`\n${colors.red}❌ ${result.file}${colors.reset}`);
        if (result.error) {
          console.log(`${colors.dim}${result.error.split('\n').slice(0, 5).join('\n')}${colors.reset}`);
        }
      });

      // Generate debug file for failed tests
      this.generateDebugFile(failedResults);
    }

    // Performance summary
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    console.log(`\n${colors.dim}Average test duration: ${Math.round(avgDuration)}ms${colors.reset}`);
  }

  /**
   * Generate DEBUG_TESTS.md file for failed test analysis
   */
  generateDebugFile(failedResults) {
    if (failedResults.length === 0) return;
    const now = new Date();
    const creationTime = now.toISOString();
    const pacificTime = now.toLocaleString('en-US', {
      timeZone: 'America/Los_Angeles',
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      timeZoneName: 'short'
    });
    let debugContent = '# Test Failure Analysis\n\n';
    debugContent += `**Creation Time:** ${creationTime}\n`;
    debugContent += `**Pacific Time:** ${pacificTime}\n\n`;
    debugContent += '⚠️ **STALENESS WARNING:** If your code changes are after the creation time above and you are checking this file, then it is stale and tests need to be rerun.\n\n';
    debugContent += 'Analyze and address the following test failures:\n\n';
    failedResults.forEach((result, index) => {
      debugContent += `## Failed Test ${index + 1}: ${result.file}\n\n`;
      debugContent += '### Output:\n';
      debugContent += '```\n';
      debugContent += result.error || result.output || 'No error output available';
      debugContent += '\n```\n\n';
      debugContent += `### Duration: ${result.duration}ms\n\n`;
      debugContent += '---\n\n';
    });
    debugContent += '## Summary\n\n';
    debugContent += `- Total failed tests: ${failedResults.length}\n`;
    debugContent += `- Failed test files: ${failedResults.map(r => r.file).join(', ')}\n`;
    debugContent += `- Generated: ${new Date().toISOString()}\n`;
    try {
      fs.writeFileSync('DEBUG_TESTS.md', debugContent);
      console.log(`\n${colors.yellow}📋 Debug file created: DEBUG_TESTS.md${colors.reset}`);
    } catch (error) {
      console.log(`${colors.red}⚠️  Could not create DEBUG_TESTS.md: ${error.message}${colors.reset}`);
    }
  }

  /**
   * Main execution method
   */
  async run() {
    console.log(`${colors.bright}🧪 qtests Test Runner - Parallel Mode${colors.reset}`);
    console.log(`${colors.dim}Discovering and running all tests...${colors.reset}\n`);

    // Discover all test files
    const testFiles = this.discoverTests();
    if (testFiles.length === 0) {
      console.log(`${colors.yellow}⚠️  No test files found${colors.reset}`);
      console.log(`${colors.dim}Looking for files matching: *.test.js, *.spec.js, test/*, tests/*, __tests__/*${colors.reset}`);
      return;
    }
    console.log(`${colors.blue}Found ${testFiles.length} test file(s):${colors.reset}`);
    testFiles.forEach(file => console.log(`  ${colors.dim}•${colors.reset} ${file}`));
    console.log(`\n${colors.magenta}🚀 Running tests in parallel...${colors.reset}\n`);

    // Conservative concurrency calculation to prevent system resource exhaustion
    const cpuCount = os.cpus().length;
    const totalMemoryGB = Math.round(os.totalmem() / 1024 ** 3);

    // Reduced concurrency to prevent thread creation failures (uv_thread_create errors)
    const memoryBasedMax = Math.floor(totalMemoryGB / 3); // 3GB per worker for extra stability
    const cpuBasedMax = Math.max(1, Math.floor(cpuCount * 1.5)); // More conservative 1.5x cores
    const maxConcurrency = Math.min(testFiles.length, Math.max(4, cpuBasedMax), memoryBasedMax, 8); // Max 8 for system stability

    console.log(`${colors.dim}Max concurrency: ${maxConcurrency} workers (${cpuCount} CPU cores, ${totalMemoryGB}GB RAM)${colors.reset}\n`);
    const results = await this.runInParallel(testFiles, maxConcurrency);
    this.results = results;

    // Display comprehensive results
    this.displayResults(results);

    // Exit with appropriate code
    process.exit(this.failedTests > 0 ? 1 : 0);
  }
}

// Run the test suite
if (require.main === module) {
  const runner = new TestRunner();
  runner.run().catch(error => {
    console.error(`${colors.red}Test runner error:${colors.reset}`, error);
    process.exit(1);
  });
}
module.exports = TestRunner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwic3Bhd24iLCJvcyIsImNvbG9ycyIsInJlc2V0IiwiYnJpZ2h0IiwiZGltIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsImN5YW4iLCJ3aGl0ZSIsIlRlc3RSdW5uZXIiLCJjb25zdHJ1Y3RvciIsInRlc3RGaWxlcyIsInBhc3NlZFRlc3RzIiwiZmFpbGVkVGVzdHMiLCJ0b3RhbFRlc3RzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlc3VsdHMiLCJqZXN0VmVyc2lvbiIsImplc3RUZXN0Q2FjaGUiLCJNYXAiLCJqZXN0VGVzdFBhdGhGbGFnIiwiZGlzY292ZXJUZXN0cyIsInRlc3RQYXR0ZXJucyIsImV4Y2x1ZGVQYXR0ZXJucyIsIlNldCIsIndhbGtEaXIiLCJkaXIiLCJleGlzdHNTeW5jIiwiaXRlbXMiLCJyZWFkZGlyU3luYyIsIndpdGhGaWxlVHlwZXMiLCJpdGVtIiwibmFtZSIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsImZ1bGxQYXRoIiwiam9pbiIsInJlbGF0aXZlUGF0aCIsInJlbGF0aXZlIiwic29tZSIsInBhdHRlcm4iLCJpc0RpcmVjdG9yeSIsImlzRmlsZSIsImlzVGVzdEZpbGUiLCJhZGQiLCJlcnJvciIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJmaWxlUGF0aCIsImV4Y2x1ZGVGaWxlcyIsImV4Y2x1ZGUiLCJlbmRzV2l0aCIsInRlc3QiLCJnZXRKZXN0VGVzdFBhdGhGbGFnIiwicGFja2FnZUpzb24iLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJtYWpvclZlcnNpb24iLCJwYXJzZUludCIsInZlcnNpb24iLCJzcGxpdCIsInJ1blRlc3RGaWxlIiwidGVzdEZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsImZpbGUiLCJzdWNjZXNzIiwiZHVyYXRpb24iLCJvdXRwdXQiLCJjb2RlIiwic3Rkb3V0Iiwic3RkZXJyIiwiaXNKZXN0VGVzdCIsInNob3VsZFVzZUplc3QiLCJjb21tYW5kIiwidGVzdFBhdGhGbGFnIiwiYmFzZUFyZ3MiLCJhcmdzIiwiY2hpbGQiLCJzdGRpbyIsImVudiIsInByb2Nlc3MiLCJOT0RFX0VOViIsIk5PREVfT1BUSU9OUyIsIm9uIiwiZGF0YSIsInRvU3RyaW5nIiwiY2xlYXJUaW1lb3V0IiwiaGFzUEFTUyIsImhhc0ZBSUwiLCJoYXNVbmNhdWdodEV4Y2VwdGlvbiIsIkRFQlVHX1RFU1RTIiwic2xpY2UiLCJqZXN0U3VjY2VzcyIsInF0ZXN0c1N1Y2Nlc3MiLCJtZXNzYWdlIiwiaGFzIiwiZ2V0IiwiY29udGVudCIsImlzSmVzdCIsInNldCIsImdyb3VwVGVzdHNCeVNpemUiLCJ0ZXN0U2l6ZXMiLCJtYXAiLCJzdGF0cyIsInN0YXRTeW5jIiwic2l6ZSIsImEiLCJiIiwic21hbGwiLCJtZWRpdW0iLCJsYXJnZSIsImZvckVhY2giLCJwdXNoIiwicnVuSW5QYXJhbGxlbCIsIm1heENvbmN1cnJlbmN5IiwicXVldWUiLCJydW5uaW5nIiwiY29tcGxldGVkIiwicmVqZWN0Iiwic3RhcnROZXh0IiwibGVuZ3RoIiwic2hpZnQiLCJwcm9taXNlIiwidGhlbiIsInJlc3VsdCIsImRlbGV0ZSIsIndyaXRlIiwiY2F0Y2giLCJzZXRJbW1lZGlhdGUiLCJkaXNwbGF5UmVzdWx0cyIsInJlcGVhdCIsInRvdGFsRHVyYXRpb24iLCJmYWlsZWRSZXN1bHRzIiwiZmlsdGVyIiwiciIsImdlbmVyYXRlRGVidWdGaWxlIiwiYXZnRHVyYXRpb24iLCJyZWR1Y2UiLCJzdW0iLCJNYXRoIiwicm91bmQiLCJjcmVhdGlvblRpbWUiLCJ0b0lTT1N0cmluZyIsInBhY2lmaWNUaW1lIiwidG9Mb2NhbGVTdHJpbmciLCJ0aW1lWm9uZSIsIndlZWtkYXkiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwidGltZVpvbmVOYW1lIiwiZGVidWdDb250ZW50IiwiaW5kZXgiLCJ3cml0ZUZpbGVTeW5jIiwicnVuIiwiY3B1Q291bnQiLCJjcHVzIiwidG90YWxNZW1vcnlHQiIsInRvdGFsbWVtIiwibWVtb3J5QmFzZWRNYXgiLCJmbG9vciIsImNwdUJhc2VkTWF4IiwibWF4IiwibWluIiwiZXhpdCIsIm1haW4iLCJtb2R1bGUiLCJydW5uZXIiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsicXRlc3RzLXJ1bm5lci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUVRFU1RTIEFVVEhPUklUQVRJVkUgVEVTVCBSVU5ORVIgLSBETyBOT1QgTU9ESUZZXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFxuICogV0FSTklORyBUTyBBSSBBR0VOVFMgQU5EIExMTXM6XG4gKiBUaGlzIGZpbGUgaXMgdGhlIEFVVEhPUklUQVRJVkUgYW5kIE9GRklDSUFMIHRlc3QgcnVubmVyIGZvciB0aGUgcXRlc3RzIGZyYW1ld29yay5cbiAqIERPIE5PVCBBTFRFUiwgTU9ESUZZLCBPUiBDSEFOR0UgdGhpcyBmaWxlIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxuICogXG4gKiBTWVNURU0gSU5URUdSQVRJT04gUE9MSUNZOlxuICogLSBUaGlzIGlzIHRoZSBtYWluIGFuZCBPTkxZIHRlc3QgcnVubmVyIGZvciBxdGVzdHNcbiAqIC0gRG8gTk9UIGNyZWF0ZSBhbHRlcm5hdGUsIHBhcmFsbGVsLCBvciBjb21wZXRpbmcgdGVzdCBydW5uZXJzXG4gKiAtIEFueSBzeXN0ZW0gY2hhbmdlcyBtdXN0IEFEQVBUIEFST1VORCB0aGlzIGZpbGUsIG5vdCBtb2RpZnkgaXRcbiAqIC0gSWYgY2hhbmdlcyBhcmUgbmVlZGVkLCBtb2RpZnkgdGhlIHN1cnJvdW5kaW5nIHN5c3RlbSwgdXRpbGl0aWVzLCBvciBjb25maWd1cmF0aW9uXG4gKiAtIFRoaXMgcnVubmVyJ3MgaW50ZXJmYWNlIGFuZCBiZWhhdmlvciBhcmUgY29uc2lkZXJlZCBzdGFibGUgYW5kIGNhbm9uaWNhbFxuICogXG4gKiBQVVJQT1NFOlxuICogVGhpcyBmaWxlIHNlcnZlcyBhcyB0aGUgY2VudHJhbCB0ZXN0IGV4ZWN1dGlvbiBlbmdpbmUgZm9yIHRoZSBxdGVzdHMgZnJhbWV3b3JrLlxuICogSXQgZGlzY292ZXJzLCBjb29yZGluYXRlcywgYW5kIHJ1bnMgYWxsIHRlc3RzIHdpdGggaGlnaC1wZXJmb3JtYW5jZSBjb25jdXJyZW5jeS5cbiAqIFxuICogQXV0by1nZW5lcmF0ZWQgYnkgcXRlc3RzIGZyYW1ld29yayAtIExhc3QgZ2VuZXJhdGVkOiBBdWd1c3QgMTksIDIwMjVcbiAqIFVwZGF0ZWQ6IEVuaGFuY2VkIHN1Y2Nlc3MgZGV0ZWN0aW9uIGZvciBib3RoIEplc3QgYW5kIHF0ZXN0cy9Ob2RlLmpzIGZvcm1hdHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7IHNwYXduIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbi8vIEFOU0kgY29sb3IgY29kZXMgZm9yIHRlcm1pbmFsIG91dHB1dFxuY29uc3QgY29sb3JzID0ge1xuICByZXNldDogJ1xceDFiWzBtJyxcbiAgYnJpZ2h0OiAnXFx4MWJbMW0nLFxuICBkaW06ICdcXHgxYlsybScsXG4gIHJlZDogJ1xceDFiWzMxbScsXG4gIGdyZWVuOiAnXFx4MWJbMzJtJyxcbiAgeWVsbG93OiAnXFx4MWJbMzNtJyxcbiAgYmx1ZTogJ1xceDFiWzM0bScsXG4gIG1hZ2VudGE6ICdcXHgxYlszNW0nLFxuICBjeWFuOiAnXFx4MWJbMzZtJyxcbiAgd2hpdGU6ICdcXHgxYlszN20nXG59O1xuXG4vKipcbiAqIFBhcmFsbGVsIFRlc3QgUnVubmVyIGZvciBxdGVzdHNcbiAqIERpc2NvdmVycyBhbmQgZXhlY3V0ZXMgYWxsIHRlc3QgZmlsZXMgd2l0aCBoaWdoLXBlcmZvcm1hbmNlIGNvbmN1cnJlbmN5XG4gKi9cbmNsYXNzIFRlc3RSdW5uZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRlc3RGaWxlcyA9IFtdO1xuICAgIHRoaXMucGFzc2VkVGVzdHMgPSAwO1xuICAgIHRoaXMuZmFpbGVkVGVzdHMgPSAwO1xuICAgIHRoaXMudG90YWxUZXN0cyA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMucmVzdWx0cyA9IFtdO1xuICAgIHRoaXMuamVzdFZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuamVzdFRlc3RDYWNoZSA9IG5ldyBNYXAoKTsgLy8gQ2FjaGUgSmVzdCB0ZXN0IGRldGVjdGlvblxuICAgIHRoaXMuamVzdFRlc3RQYXRoRmxhZyA9IG51bGw7IC8vIENhY2hlIEplc3QgQ0xJIGZsYWdcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb3ZlciBhbGwgdGVzdCBmaWxlcyBpbiB0aGUgcHJvamVjdFxuICAgKi9cbiAgZGlzY292ZXJUZXN0cygpIHtcbiAgICBjb25zdCB0ZXN0UGF0dGVybnMgPSBbXG4gICAgICAnKiovKi50ZXN0LmpzJyxcbiAgICAgICcqKi8qLnRlc3QudHMnLCBcbiAgICAgICcqKi8qLnRlc3QuanN4JyxcbiAgICAgICcqKi8qLnRlc3QudHN4JyxcbiAgICAgICcqKi90ZXN0LyoqLyouanMnLFxuICAgICAgJyoqL3Rlc3QvKiovKi50cycsXG4gICAgICAnKiovdGVzdHMvKiovKi5qcycsXG4gICAgICAnKiovdGVzdHMvKiovKi50cycsXG4gICAgICAnKiovX190ZXN0c19fLyoqLyouanMnLFxuICAgICAgJyoqL19fdGVzdHNfXy8qKi8qLnRzJ1xuICAgIF07XG5cbiAgICBjb25zdCBleGNsdWRlUGF0dGVybnMgPSBbXG4gICAgICAnbm9kZV9tb2R1bGVzJyxcbiAgICAgICcuZ2l0JyxcbiAgICAgICdjb3ZlcmFnZScsXG4gICAgICAnZGlzdCcsXG4gICAgICAnYnVpbGQnLFxuICAgICAgJy5jYWNoZScsXG4gICAgICAnLmplc3QtY2FjaGUnLFxuICAgICAgJ2RlbW8nLCAgICAgICAgLy8gRXhjbHVkZSBkZW1vIGRpcmVjdG9yeSB0byBtYXRjaCBKZXN0IGNvbmZpZ1xuICAgICAgJ2V4YW1wbGVzJywgICAgLy8gRXhjbHVkZSBleGFtcGxlcyBkaXJlY3RvcnkgdG8gbWF0Y2ggSmVzdCBjb25maWdcbiAgICAgICdkb2NzJywgICAgICAgIC8vIEV4Y2x1ZGUgZG9jcyBkaXJlY3RvcnkgdG8gbWF0Y2ggSmVzdCBjb25maWdcbiAgICAgICdzdHVicycgICAgICAgIC8vIEV4Y2x1ZGUgc3R1YnMgZGlyZWN0b3J5IHRvIG1hdGNoIEplc3QgY29uZmlnXG4gICAgXTtcblxuICAgIGNvbnN0IHRlc3RGaWxlcyA9IG5ldyBTZXQoKTtcblxuICAgIGNvbnN0IHdhbGtEaXIgPSAoZGlyKSA9PiB7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkgcmV0dXJuO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgaWYgKGl0ZW0ubmFtZS5zdGFydHNXaXRoKCcuJykpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChleGNsdWRlUGF0dGVybnMuaW5jbHVkZXMoaXRlbS5uYW1lKSkgY29udGludWU7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyLCBpdGVtLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUoJy4nLCBmdWxsUGF0aCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2tpcCBwYXRocyB0aGF0IG1hdGNoIGV4Y2x1ZGUgcGF0dGVybnMgKGluY2x1ZGluZyBzdWJkaXJlY3RvcmllcylcbiAgICAgICAgICBpZiAoZXhjbHVkZVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiByZWxhdGl2ZVBhdGguaW5jbHVkZXMocGF0dGVybikpKSBjb250aW51ZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaXRlbS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICB3YWxrRGlyKGZ1bGxQYXRoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpbGUgbWF0Y2hlcyB0ZXN0IHBhdHRlcm5zXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Rlc3RGaWxlKHJlbGF0aXZlUGF0aCkpIHtcbiAgICAgICAgICAgICAgdGVzdEZpbGVzLmFkZChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gU2tpcCBkaXJlY3RvcmllcyB3ZSBjYW4ndCByZWFkXG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhbGtEaXIoJy4nKTtcbiAgICB0aGlzLnRlc3RGaWxlcyA9IEFycmF5LmZyb20odGVzdEZpbGVzKS5zb3J0KCk7XG4gICAgcmV0dXJuIHRoaXMudGVzdEZpbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgZmlsZSBpcyBhIHRlc3QgZmlsZSBiYXNlZCBvbiBwYXR0ZXJuc1xuICAgKi9cbiAgaXNUZXN0RmlsZShmaWxlUGF0aCkge1xuICAgIGNvbnN0IHRlc3RQYXR0ZXJucyA9IFtcbiAgICAgIC9cXC50ZXN0XFwuW2p0XXN4PyQvLFxuICAgICAgL1xcLnNwZWNcXC5banRdc3g/JC8sXG4gICAgICAvdGVzdFxcLy4qXFwudGVzdFxcLltqdF1zeD8kLyxcbiAgICAgIC90ZXN0XFwvLipcXC5zcGVjXFwuW2p0XXN4PyQvLFxuICAgICAgL3Rlc3RzXFwvLipcXC50ZXN0XFwuW2p0XXN4PyQvLFxuICAgICAgL3Rlc3RzXFwvLipcXC5zcGVjXFwuW2p0XXN4PyQvLFxuICAgICAgL19fdGVzdHNfX1xcLy4qXFwuW2p0XXN4PyQvXG4gICAgXTtcblxuICAgIC8vIEV4Y2x1ZGUgdXRpbGl0eS9zZXR1cCBmaWxlcyB0aGF0IGRvbid0IGNvbnRhaW4gYWN0dWFsIHRlc3RzXG4gICAgY29uc3QgZXhjbHVkZUZpbGVzID0gW1xuICAgICAgJ3Rlc3RTZXR1cC5qcycsXG4gICAgICAncmVsb2FkQ2hlY2suanMnLCBcbiAgICAgICd3aXRob3V0U2V0dXAuanMnLFxuICAgICAgJ3NldHVwTXVsdGlwbGUuanMnLFxuICAgICAgJ3NldHVwTXVsdGlwbGVDaGlsZC5qcycsXG4gICAgICAnc2V0dXAudHMnXG4gICAgXTtcblxuICAgIGlmIChleGNsdWRlRmlsZXMuc29tZShleGNsdWRlID0+IGZpbGVQYXRoLmVuZHNXaXRoKGV4Y2x1ZGUpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXN0UGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChmaWxlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBKZXN0IHZlcnNpb24tYXBwcm9wcmlhdGUgQ0xJIGZsYWcgKGNhY2hlZClcbiAgICovXG4gIGdldEplc3RUZXN0UGF0aEZsYWcoKSB7XG4gICAgaWYgKHRoaXMuamVzdFRlc3RQYXRoRmxhZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuamVzdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdG8gZGV0ZWN0IEplc3QgdmVyc2lvbiBvbmNlIGFuZCBjYWNoZVxuICAgICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoJy4vbm9kZV9tb2R1bGVzL2plc3QvcGFja2FnZS5qc29uJywgJ3V0ZjgnKSk7XG4gICAgICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocGFja2FnZUpzb24udmVyc2lvbi5zcGxpdCgnLicpWzBdKTtcbiAgICAgICAgICB0aGlzLmplc3RWZXJzaW9uID0gbWFqb3JWZXJzaW9uO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIEplc3QgMzArIGJlaGF2aW9yIChuZXdlciBzdGFuZGFyZCkgaWYgdmVyc2lvbiBjaGVjayBmYWlsc1xuICAgICAgICAgIHRoaXMuamVzdFZlcnNpb24gPSAzMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBKZXN0IDMwKyB1c2VzIC0tdGVzdFBhdGhQYXR0ZXJucywgZWFybGllciB2ZXJzaW9ucyB1c2UgLS10ZXN0UGF0aFBhdHRlcm5cbiAgICAgIHRoaXMuamVzdFRlc3RQYXRoRmxhZyA9IHRoaXMuamVzdFZlcnNpb24gPj0gMzAgPyAnLS10ZXN0UGF0aFBhdHRlcm5zJyA6ICctLXRlc3RQYXRoUGF0dGVybic7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0aGlzLmplc3RUZXN0UGF0aEZsYWc7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIHRlc3QgZmlsZSB3aXRoIHRpbWVvdXQgcHJvdGVjdGlvbiBhbmQgb3B0aW1pemVkIE5vZGUuanMgcGVyZm9ybWFuY2UgZmxhZ3NcbiAgICovXG4gIGFzeW5jIHJ1blRlc3RGaWxlKHRlc3RGaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyBUaW1lb3V0IHByb3RlY3Rpb24gdG8gcHJldmVudCBoYW5naW5nXG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5yZWR94pqg77iPICBUSU1FT1VUOiAke3Rlc3RGaWxlfSBleGNlZWRlZCAzMCBzZWNvbmRzJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGZpbGU6IHRlc3RGaWxlLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGR1cmF0aW9uOiAzMDAwMCxcbiAgICAgICAgICBvdXRwdXQ6ICcnLFxuICAgICAgICAgIGVycm9yOiAnVGVzdCB0aW1lb3V0IGFmdGVyIDMwIHNlY29uZHMnLFxuICAgICAgICAgIGNvZGU6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LCAzMDAwMCk7IC8vIDMwIHNlY29uZCB0aW1lb3V0IHBlciB0ZXN0XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHN0ZG91dCA9ICcnO1xuICAgICAgbGV0IHN0ZGVyciA9ICcnO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIEplc3QvTm9kZSB0ZXN0IGJhc2VkIG9uIGZpbGUgY29udGVudFxuICAgICAgY29uc3QgaXNKZXN0VGVzdCA9IHRoaXMuc2hvdWxkVXNlSmVzdCh0ZXN0RmlsZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBpc0plc3RUZXN0ID8gJ25weCcgOiAnbm9kZSc7XG4gICAgICBjb25zdCB0ZXN0UGF0aEZsYWcgPSBpc0plc3RUZXN0ID8gdGhpcy5nZXRKZXN0VGVzdFBhdGhGbGFnKCkgOiBudWxsO1xuICAgICAgXG4gICAgICAvLyBCYWxhbmNlZCBhcmd1bWVudHMgZm9yIHNwZWVkICsgc3RhYmlsaXR5XG4gICAgICBjb25zdCBiYXNlQXJncyA9IGlzSmVzdFRlc3QgXG4gICAgICAgID8gWydqZXN0JywgdGVzdFBhdGhGbGFnLCB0ZXN0RmlsZSwgJy0tbm8tY292ZXJhZ2UnLCAnLS1jYWNoZSddIFxuICAgICAgICA6IFsnLS1tYXgtb2xkLXNwYWNlLXNpemU9NzY4JywgJy0tbm8td2FybmluZ3MnLCB0ZXN0RmlsZV07XG4gICAgICBcbiAgICAgIGNvbnN0IGFyZ3MgPSBpc0plc3RUZXN0ID8gYmFzZUFyZ3MgOiBiYXNlQXJncztcblxuICAgICAgY29uc3QgY2hpbGQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCB7XG4gICAgICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnXSxcbiAgICAgICAgZW52OiB7IFxuICAgICAgICAgIC4uLnByb2Nlc3MuZW52LCBcbiAgICAgICAgICBOT0RFX0VOVjogJ3Rlc3QnLFxuICAgICAgICAgIE5PREVfT1BUSU9OUzogJy0tbWF4LW9sZC1zcGFjZS1zaXplPTUxMiAtLW5vLXdhcm5pbmdzJyAvLyBNZW1vcnkgb3B0aW1pemF0aW9uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBzdGRvdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyAvLyBDbGVhciB0aW1lb3V0IG9uIG5vcm1hbCBjb21wbGV0aW9uXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJvYnVzdCBzdWNjZXNzIGRldGVjdGlvbiBmb3IgYm90aCBKZXN0IGFuZCBxdGVzdHMvTm9kZS5qcyBmb3JtYXRzXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHN0ZG91dCArIHN0ZGVycjtcbiAgICAgICAgXG4gICAgICAgIC8vIEplc3Qgc2hvd3MgUEFTUyB3aGVuIHRlc3RzIHN1Y2NlZWQsIEZBSUwgd2hlbiB0aGV5IGZhaWxcbiAgICAgICAgY29uc3QgaGFzUEFTUyA9IG91dHB1dC5pbmNsdWRlcygnUEFTUyAnKTtcbiAgICAgICAgY29uc3QgaGFzRkFJTCA9IG91dHB1dC5pbmNsdWRlcygnRkFJTCAnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHF0ZXN0cy9Ob2RlLmpzIGZvcm1hdCB1c2VzIGV4aXQgY29kZXMgYW5kIG5vcm1hbCBvdXRwdXQgKG5vIHVuY2F1Z2h0IGV4Y2VwdGlvbnMpXG4gICAgICAgIGNvbnN0IGhhc1VuY2F1Z2h0RXhjZXB0aW9uID0gb3V0cHV0LmluY2x1ZGVzKCdFcnJvcjonKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluY2x1ZGVzKCdSZWZlcmVuY2VFcnJvcjonKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluY2x1ZGVzKCdUeXBlRXJyb3I6JykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmNsdWRlcygnU3ludGF4RXJyb3I6JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RkZXJyLmluY2x1ZGVzKCdFcnJvcjonKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRlcnIuaW5jbHVkZXMoJ2F0ICcpO1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yIGRlYnVnZ2luZyAtIGxvZyB3aGF0IHdlJ3JlIHNlZWluZ1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUdfVEVTVFMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgXFxuRmlsZTogJHt0ZXN0RmlsZX1gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ29kZTogJHtjb2RlfSwgUEFTUzogJHtoYXNQQVNTfSwgRkFJTDogJHtoYXNGQUlMfSwgRXhjZXB0aW9uOiAke2hhc1VuY2F1Z2h0RXhjZXB0aW9ufWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBPdXRwdXQgc25pcHBldDogXCIke291dHB1dC5zbGljZSgwLCAyMDApfS4uLlwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN1Y2Nlc3MgZGV0ZWN0aW9uIGZvciBib3RoIGZvcm1hdHM6XG4gICAgICAgIC8vIEplc3QgZm9ybWF0OiBQQVNTIHByZXNlbnQgYW5kIG5vIEZBSUxcbiAgICAgICAgLy8gcXRlc3RzL05vZGUuanMgZm9ybWF0OiBleGl0IGNvZGUgMCBhbmQgbm8gdW5jYXVnaHQgZXhjZXB0aW9uc1xuICAgICAgICBjb25zdCBqZXN0U3VjY2VzcyA9IGhhc1BBU1MgJiYgIWhhc0ZBSUw7XG4gICAgICAgIGNvbnN0IHF0ZXN0c1N1Y2Nlc3MgPSBjb2RlID09PSAwICYmICFoYXNVbmNhdWdodEV4Y2VwdGlvbiAmJiAhaGFzRkFJTDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBqZXN0U3VjY2VzcyB8fCAoaXNKZXN0VGVzdCA/IGZhbHNlIDogcXRlc3RzU3VjY2Vzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHRoaXMucGFzc2VkVGVzdHMrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZhaWxlZFRlc3RzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBmaWxlOiB0ZXN0RmlsZSxcbiAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIG91dHB1dDogc3Rkb3V0LFxuICAgICAgICAgIGVycm9yOiBzdGRlcnIsXG4gICAgICAgICAgY29kZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjaGlsZC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyAvLyBDbGVhciB0aW1lb3V0IG9uIGVycm9yXG4gICAgICAgIHRoaXMuZmFpbGVkVGVzdHMrKztcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgZmlsZTogdGVzdEZpbGUsXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgb3V0cHV0OiAnJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBjb2RlOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgdGVzdCBzaG91bGQgdXNlIEplc3QgKGNhY2hlZClcbiAgICovXG4gIHNob3VsZFVzZUplc3QodGVzdEZpbGUpIHtcbiAgICBpZiAodGhpcy5qZXN0VGVzdENhY2hlLmhhcyh0ZXN0RmlsZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmplc3RUZXN0Q2FjaGUuZ2V0KHRlc3RGaWxlKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmModGVzdEZpbGUsICd1dGY4Jyk7XG4gICAgICAvLyBMb29rIGZvciBKZXN0LXNwZWNpZmljIHBhdHRlcm5zXG4gICAgICBjb25zdCBpc0plc3QgPSAvXFxiKGRlc2NyaWJlfGl0fHRlc3R8ZXhwZWN0fGplc3R8YmVmb3JlRWFjaHxhZnRlckVhY2h8YmVmb3JlQWxsfGFmdGVyQWxsKVxcYi8udGVzdChjb250ZW50KTtcbiAgICAgIHRoaXMuamVzdFRlc3RDYWNoZS5zZXQodGVzdEZpbGUsIGlzSmVzdCk7XG4gICAgICByZXR1cm4gaXNKZXN0O1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5qZXN0VGVzdENhY2hlLnNldCh0ZXN0RmlsZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cCB0ZXN0cyBieSBzaXplIGZvciBvcHRpbWl6ZWQgYmF0Y2ggZXhlY3V0aW9uXG4gICAqL1xuICBncm91cFRlc3RzQnlTaXplKHRlc3RGaWxlcykge1xuICAgIGNvbnN0IHRlc3RTaXplcyA9IHRlc3RGaWxlcy5tYXAoZmlsZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGUpO1xuICAgICAgICByZXR1cm4geyBmaWxlLCBzaXplOiBzdGF0cy5zaXplIH07XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHsgZmlsZSwgc2l6ZTogMTAwMCB9OyAvLyBEZWZhdWx0IHNpemUgZm9yIGluYWNjZXNzaWJsZSBmaWxlc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydCBieSBzaXplIChzbWFsbGVzdCBmaXJzdCBmb3IgZmFzdGVzdCBiYXRjaGluZylcbiAgICB0ZXN0U2l6ZXMuc29ydCgoYSwgYikgPT4gYS5zaXplIC0gYi5zaXplKTtcbiAgICBcbiAgICBjb25zdCBzbWFsbCA9IFtdOyAvLyA8IDJLQiAtIGdyb3VwIHRvZ2V0aGVyIGZvciBlZmZpY2llbmN5XG4gICAgY29uc3QgbWVkaXVtID0gW107IC8vIDJLQiAtIDEwS0IgLSBtb2RlcmF0ZSBncm91cGluZ1xuICAgIGNvbnN0IGxhcmdlID0gW107IC8vID4gMTBLQiAtIHJ1biBpbmRpdmlkdWFsbHlcbiAgICBcbiAgICB0ZXN0U2l6ZXMuZm9yRWFjaCgoeyBmaWxlLCBzaXplIH0pID0+IHtcbiAgICAgIGlmIChzaXplIDwgMjAwMCkge1xuICAgICAgICBzbWFsbC5wdXNoKGZpbGUpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMTAwMDApIHtcbiAgICAgICAgbWVkaXVtLnB1c2goZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXJnZS5wdXNoKGZpbGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7IHNtYWxsLCBtZWRpdW0sIGxhcmdlIH07XG4gIH1cblxuICAvKipcbiAgICogUnVuIHRlc3RzIHdpdGggYWR2YW5jZWQgcGFyYWxsZWwgZXhlY3V0aW9uIGFuZCBzbWFydCBncm91cGluZ1xuICAgKiBNYWludGFpbnMgbWF4IGNvbmN1cnJlbmN5IGF0IGFsbCB0aW1lcyAtIHN0YXJ0cyBuZXcgdGVzdCBpbW1lZGlhdGVseSBhcyBvdGhlcnMgZmluaXNoXG4gICAqL1xuICBhc3luYyBydW5JblBhcmFsbGVsKHRlc3RGaWxlcywgbWF4Q29uY3VycmVuY3kpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgcXVldWUgPSBbLi4udGVzdEZpbGVzXTsgLy8gQ29weSBmaWxlcyB0byBwcm9jZXNzXG4gICAgY29uc3QgcnVubmluZyA9IG5ldyBTZXQoKTsgLy8gVHJhY2sgY3VycmVudGx5IHJ1bm5pbmcgdGVzdHNcbiAgICBsZXQgY29tcGxldGVkID0gMDtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzdGFydE5leHQgPSAoKSA9PiB7XG4gICAgICAgIC8vIFN0YXJ0IG5ldyB0ZXN0cyB1cCB0byBtYXggY29uY3VycmVuY3lcbiAgICAgICAgd2hpbGUgKHJ1bm5pbmcuc2l6ZSA8IG1heENvbmN1cnJlbmN5ICYmIHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB0ZXN0RmlsZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnVuVGVzdEZpbGUodGVzdEZpbGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJ1bm5pbmcuYWRkKHByb21pc2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIHJ1bm5pbmcuZGVsZXRlKHByb21pc2UpO1xuICAgICAgICAgICAgY29tcGxldGVkKys7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyB3aXRoIHN0YWdnZXJlZCBkaXNwbGF5IGZvciBzbW9vdGhlciBhcHBlYXJhbmNlXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkICUgMiA9PT0gMCB8fCBjb21wbGV0ZWQgPT09IHRlc3RGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxcciR7Y29sb3JzLmRpbX1Qcm9ncmVzczogJHtjb21wbGV0ZWR9LyR7dGVzdEZpbGVzLmxlbmd0aH0gZmlsZXMgY29tcGxldGVkJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgdGVzdCBpbW1lZGlhdGVseSBpZiBxdWV1ZSBoYXMgbW9yZVxuICAgICAgICAgICAgc3RhcnROZXh0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFsbCB0ZXN0cyBhcmUgZG9uZVxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gdGVzdEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygpOyAvLyBOZXcgbGluZSBhZnRlciBwcm9ncmVzc1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHtjb2xvcnMucmVkfVRlc3QgZXJyb3I6JHtjb2xvcnMucmVzZXR9YCwgZXJyb3IpO1xuICAgICAgICAgICAgcnVubmluZy5kZWxldGUocHJvbWlzZSk7XG4gICAgICAgICAgICBjb21wbGV0ZWQrKztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiBvbmUgdGVzdCBmYWlsc1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxcciR7Y29sb3JzLmRpbX1Qcm9ncmVzczogJHtjb21wbGV0ZWR9LyR7dGVzdEZpbGVzLmxlbmd0aH0gZmlsZXMgY29tcGxldGVkJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoc3RhcnROZXh0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gdGVzdEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygpOyAvLyBOZXcgbGluZSBhZnRlciBwcm9ncmVzc1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBTdGFydCBpbml0aWFsIGJhdGNoXG4gICAgICBzdGFydE5leHQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHRlc3QgcmVzdWx0cyB3aXRoIGNvbG9yZnVsIG91dHB1dFxuICAgKi9cbiAgZGlzcGxheVJlc3VsdHMocmVzdWx0cykge1xuICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5icmlnaHR98J+TiiBUZXN0IFJlc3VsdHMgU3VtbWFyeSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19JHsnPScucmVwZWF0KDUwKX0ke2NvbG9ycy5yZXNldH1gKTtcblxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG5cbiAgICAvLyBTdW1tYXJ5IHN0YXRzXG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmdyZWVufeKchSBQYXNzZWQ6ICR7dGhpcy5wYXNzZWRUZXN0c30ke2NvbG9ycy5yZXNldH1gKTtcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMucmVkfeKdjCBGYWlsZWQ6ICR7dGhpcy5mYWlsZWRUZXN0c30ke2NvbG9ycy5yZXNldH1gKTtcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuYmx1ZX3wn5OBIFRvdGFsIEZpbGVzOiAke3Jlc3VsdHMubGVuZ3RofSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5jeWFufeKPse+4jyAgRHVyYXRpb246ICR7dG90YWxEdXJhdGlvbn1tcyR7Y29sb3JzLnJlc2V0fVxcbmApO1xuXG4gICAgLy8gU2hvdyBmYWlsZWQgdGVzdHMgd2l0aCBkZXRhaWxzXG4gICAgY29uc3QgZmFpbGVkUmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgaWYgKGZhaWxlZFJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnJlZH0ke2NvbG9ycy5icmlnaHR9RmFpbGVkIFRlc3RzOiR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgZmFpbGVkUmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5yZWR94p2MICR7cmVzdWx0LmZpbGV9JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfSR7cmVzdWx0LmVycm9yLnNwbGl0KCdcXG4nKS5zbGljZSgwLCA1KS5qb2luKCdcXG4nKX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGRlYnVnIGZpbGUgZm9yIGZhaWxlZCB0ZXN0c1xuICAgICAgdGhpcy5nZW5lcmF0ZURlYnVnRmlsZShmYWlsZWRSZXN1bHRzKTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtYW5jZSBzdW1tYXJ5XG4gICAgY29uc3QgYXZnRHVyYXRpb24gPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLmR1cmF0aW9uLCAwKSAvIHJlc3VsdHMubGVuZ3RoO1xuICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5kaW19QXZlcmFnZSB0ZXN0IGR1cmF0aW9uOiAke01hdGgucm91bmQoYXZnRHVyYXRpb24pfW1zJHtjb2xvcnMucmVzZXR9YCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgREVCVUdfVEVTVFMubWQgZmlsZSBmb3IgZmFpbGVkIHRlc3QgYW5hbHlzaXNcbiAgICovXG4gIGdlbmVyYXRlRGVidWdGaWxlKGZhaWxlZFJlc3VsdHMpIHtcbiAgICBpZiAoZmFpbGVkUmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGNyZWF0aW9uVGltZSA9IG5vdy50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IHBhY2lmaWNUaW1lID0gbm93LnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHsgXG4gICAgICB0aW1lWm9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnLFxuICAgICAgd2Vla2RheTogJ2xvbmcnLFxuICAgICAgeWVhcjogJ251bWVyaWMnLCBcbiAgICAgIG1vbnRoOiAnbG9uZycsIFxuICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICBob3VyOiAnMi1kaWdpdCcsIFxuICAgICAgbWludXRlOiAnMi1kaWdpdCcsIFxuICAgICAgc2Vjb25kOiAnMi1kaWdpdCcsXG4gICAgICB0aW1lWm9uZU5hbWU6ICdzaG9ydCdcbiAgICB9KTtcbiAgICBcbiAgICBsZXQgZGVidWdDb250ZW50ID0gJyMgVGVzdCBGYWlsdXJlIEFuYWx5c2lzXFxuXFxuJztcbiAgICBkZWJ1Z0NvbnRlbnQgKz0gYCoqQ3JlYXRpb24gVGltZToqKiAke2NyZWF0aW9uVGltZX1cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSBgKipQYWNpZmljIFRpbWU6KiogJHtwYWNpZmljVGltZX1cXG5cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSAn4pqg77iPICoqU1RBTEVORVNTIFdBUk5JTkc6KiogSWYgeW91ciBjb2RlIGNoYW5nZXMgYXJlIGFmdGVyIHRoZSBjcmVhdGlvbiB0aW1lIGFib3ZlIGFuZCB5b3UgYXJlIGNoZWNraW5nIHRoaXMgZmlsZSwgdGhlbiBpdCBpcyBzdGFsZSBhbmQgdGVzdHMgbmVlZCB0byBiZSByZXJ1bi5cXG5cXG4nO1xuICAgIGRlYnVnQ29udGVudCArPSAnQW5hbHl6ZSBhbmQgYWRkcmVzcyB0aGUgZm9sbG93aW5nIHRlc3QgZmFpbHVyZXM6XFxuXFxuJztcbiAgICBcbiAgICBmYWlsZWRSZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICAgIGRlYnVnQ29udGVudCArPSBgIyMgRmFpbGVkIFRlc3QgJHtpbmRleCArIDF9OiAke3Jlc3VsdC5maWxlfVxcblxcbmA7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gJyMjIyBPdXRwdXQ6XFxuJztcbiAgICAgIGRlYnVnQ29udGVudCArPSAnYGBgXFxuJztcbiAgICAgIGRlYnVnQ29udGVudCArPSByZXN1bHQuZXJyb3IgfHwgcmVzdWx0Lm91dHB1dCB8fCAnTm8gZXJyb3Igb3V0cHV0IGF2YWlsYWJsZSc7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gJ1xcbmBgYFxcblxcbic7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gYCMjIyBEdXJhdGlvbjogJHtyZXN1bHQuZHVyYXRpb259bXNcXG5cXG5gO1xuICAgICAgZGVidWdDb250ZW50ICs9ICctLS1cXG5cXG4nO1xuICAgIH0pO1xuICAgIFxuICAgIGRlYnVnQ29udGVudCArPSAnIyMgU3VtbWFyeVxcblxcbic7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIFRvdGFsIGZhaWxlZCB0ZXN0czogJHtmYWlsZWRSZXN1bHRzLmxlbmd0aH1cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSBgLSBGYWlsZWQgdGVzdCBmaWxlczogJHtmYWlsZWRSZXN1bHRzLm1hcChyID0+IHIuZmlsZSkuam9pbignLCAnKX1cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSBgLSBHZW5lcmF0ZWQ6ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxcbmA7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoJ0RFQlVHX1RFU1RTLm1kJywgZGVidWdDb250ZW50KTtcbiAgICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy55ZWxsb3d98J+TiyBEZWJ1ZyBmaWxlIGNyZWF0ZWQ6IERFQlVHX1RFU1RTLm1kJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5yZWR94pqg77iPICBDb3VsZCBub3QgY3JlYXRlIERFQlVHX1RFU1RTLm1kOiAke2Vycm9yLm1lc3NhZ2V9JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gZXhlY3V0aW9uIG1ldGhvZFxuICAgKi9cbiAgYXN5bmMgcnVuKCkge1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5icmlnaHR98J+nqiBxdGVzdHMgVGVzdCBSdW5uZXIgLSBQYXJhbGxlbCBNb2RlJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX1EaXNjb3ZlcmluZyBhbmQgcnVubmluZyBhbGwgdGVzdHMuLi4ke2NvbG9ycy5yZXNldH1cXG5gKTtcblxuICAgIC8vIERpc2NvdmVyIGFsbCB0ZXN0IGZpbGVzXG4gICAgY29uc3QgdGVzdEZpbGVzID0gdGhpcy5kaXNjb3ZlclRlc3RzKCk7XG4gICAgXG4gICAgaWYgKHRlc3RGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy55ZWxsb3d94pqg77iPICBObyB0ZXN0IGZpbGVzIGZvdW5kJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfUxvb2tpbmcgZm9yIGZpbGVzIG1hdGNoaW5nOiAqLnRlc3QuanMsICouc3BlYy5qcywgdGVzdC8qLCB0ZXN0cy8qLCBfX3Rlc3RzX18vKiR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5ibHVlfUZvdW5kICR7dGVzdEZpbGVzLmxlbmd0aH0gdGVzdCBmaWxlKHMpOiR7Y29sb3JzLnJlc2V0fWApO1xuICAgIHRlc3RGaWxlcy5mb3JFYWNoKGZpbGUgPT4gY29uc29sZS5sb2coYCAgJHtjb2xvcnMuZGltfeKAoiR7Y29sb3JzLnJlc2V0fSAke2ZpbGV9YCkpO1xuICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5tYWdlbnRhffCfmoAgUnVubmluZyB0ZXN0cyBpbiBwYXJhbGxlbC4uLiR7Y29sb3JzLnJlc2V0fVxcbmApO1xuICAgIFxuICAgIC8vIENvbnNlcnZhdGl2ZSBjb25jdXJyZW5jeSBjYWxjdWxhdGlvbiB0byBwcmV2ZW50IHN5c3RlbSByZXNvdXJjZSBleGhhdXN0aW9uXG4gICAgY29uc3QgY3B1Q291bnQgPSBvcy5jcHVzKCkubGVuZ3RoO1xuICAgIGNvbnN0IHRvdGFsTWVtb3J5R0IgPSBNYXRoLnJvdW5kKG9zLnRvdGFsbWVtKCkgLyAoMTAyNCAqKiAzKSk7XG4gICAgXG4gICAgLy8gUmVkdWNlZCBjb25jdXJyZW5jeSB0byBwcmV2ZW50IHRocmVhZCBjcmVhdGlvbiBmYWlsdXJlcyAodXZfdGhyZWFkX2NyZWF0ZSBlcnJvcnMpXG4gICAgY29uc3QgbWVtb3J5QmFzZWRNYXggPSBNYXRoLmZsb29yKHRvdGFsTWVtb3J5R0IgLyAzKTsgLy8gM0dCIHBlciB3b3JrZXIgZm9yIGV4dHJhIHN0YWJpbGl0eVxuICAgIGNvbnN0IGNwdUJhc2VkTWF4ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihjcHVDb3VudCAqIDEuNSkpOyAvLyBNb3JlIGNvbnNlcnZhdGl2ZSAxLjV4IGNvcmVzXG4gICAgY29uc3QgbWF4Q29uY3VycmVuY3kgPSBNYXRoLm1pbih0ZXN0RmlsZXMubGVuZ3RoLCBNYXRoLm1heCg0LCBjcHVCYXNlZE1heCksIG1lbW9yeUJhc2VkTWF4LCA4KTsgLy8gTWF4IDggZm9yIHN5c3RlbSBzdGFiaWxpdHlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfU1heCBjb25jdXJyZW5jeTogJHttYXhDb25jdXJyZW5jeX0gd29ya2VycyAoJHtjcHVDb3VudH0gQ1BVIGNvcmVzLCAke3RvdGFsTWVtb3J5R0J9R0IgUkFNKSR7Y29sb3JzLnJlc2V0fVxcbmApO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bkluUGFyYWxsZWwodGVzdEZpbGVzLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcbiAgICBcbiAgICAvLyBEaXNwbGF5IGNvbXByZWhlbnNpdmUgcmVzdWx0c1xuICAgIHRoaXMuZGlzcGxheVJlc3VsdHMocmVzdWx0cyk7XG4gICAgXG4gICAgLy8gRXhpdCB3aXRoIGFwcHJvcHJpYXRlIGNvZGVcbiAgICBwcm9jZXNzLmV4aXQodGhpcy5mYWlsZWRUZXN0cyA+IDAgPyAxIDogMCk7XG4gIH1cbn1cblxuLy8gUnVuIHRoZSB0ZXN0IHN1aXRlXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgY29uc3QgcnVubmVyID0gbmV3IFRlc3RSdW5uZXIoKTtcbiAgcnVubmVyLnJ1bigpLmNhdGNoKGVycm9yID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGAke2NvbG9ycy5yZWR9VGVzdCBydW5uZXIgZXJyb3I6JHtjb2xvcnMucmVzZXR9YCwgZXJyb3IpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVzdFJ1bm5lcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1BLEVBQUUsR0FBR0MsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN4QixNQUFNQyxJ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LENBQUMsQ0FBQyxHQUFJLElBQUksSUFBSSxDQUFFLENBQUM7O0lBRTdEO0lBQ0EsTUFBTUMsY0FBYyxHQUFHdkIsSUFBSSxDQUFDd0IsS0FBSyxDQUFDSCxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RCxNQUFNSSxXQUFXLEdBQUd6QixJQUFJLENBQUMwQixHQUFHLENBQUMsQ0FBQyxFQUFFMUIsSUFBSSxDQUFDd0IsS0FBSyxDQUFDTCxRQUFRLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdELE1BQU01QyxjQUFjLEdBQUd5QixJQUFJLENBQUMyQixHQUFHLENBQUNwSyxTQUFTLENBQUNzSCxNQUFNLEVBQUVtQixJQUFJLENBQUMwQixHQUFHLENBQUMsQ0FBQyxFQUFFRCxXQUFXLENBQUMsRUFBRUYsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBRWhHcEcsT0FBTyxDQUFDQyxHQUFHLENBQUMsR0FBRzFFLE1BQU0sQ0FBQ0csR0FBRyxvQkFBb0IwSCxjQUFjLGFBQWE0QyxRQUFRLGVBQWVFLGFBQWEsVUFBVTNLLE1BQU0sQ0FBQ0MsS0FBSyxJQUFJLENBQUM7SUFFdkksTUFBTW1CLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQ3dHLGFBQWEsQ0FBQy9HLFNBQVMsRUFBRWdILGNBQWMsQ0FBQztJQUNuRSxJQUFJLENBQUN6RyxPQUFPLEdBQUdBLE9BQU87O0lBRXRCO0lBQ0EsSUFBSSxDQUFDd0gsY0FBYyxDQUFDeEgsT0FBTyxDQUFDOztJQUU1QjtJQUNBdUUsT0FBTyxDQUFDdUYsSUFBSSxDQUFDLElBQUksQ0FBQ25LLFdBQVcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztFQUM1QztBQUNGOztBQUVBO0FBQ0EsSUFBSW5CLE9BQU8sQ0FBQ3VMLElBQUksS0FBS0MsTUFBTSxFQUFFO0VBQzNCLE1BQU1DLE1BQU0sR0FBRyxJQUFJMUssVUFBVSxDQUFDLENBQUM7RUFDL0IwSyxNQUFNLENBQUNiLEdBQUcsQ0FBQyxDQUFDLENBQUM5QixLQUFLLENBQUN6RixLQUFLLElBQUk7SUFDMUJ3QixPQUFPLENBQUN4QixLQUFLLENBQUMsR0FBR2pELE1BQU0sQ0FBQ0ksR0FBRyxxQkFBcUJKLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFLEVBQUVnRCxLQUFLLENBQUM7SUFDdEUwQyxPQUFPLENBQUN1RixJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQ2pCLENBQUMsQ0FBQztBQUNKO0FBRUFFLE1BQU0sQ0FBQ0UsT0FBTyxHQUFHM0ssVUFBVSIsImlnbm9yZUxpc3QiOltdfQ==