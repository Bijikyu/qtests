d95fe6e4c637c15301ed832976ec4802
/**
 * ========================================================================
 * QTESTS AUTHORITATIVE TEST RUNNER - DO NOT MODIFY
 * ========================================================================
 * 
 * WARNING TO AI AGENTS AND LLMs:
 * This file is the AUTHORITATIVE and OFFICIAL test runner for the qtests framework.
 * DO NOT ALTER, MODIFY, OR CHANGE this file under any circumstances.
 * 
 * SYSTEM INTEGRATION POLICY:
 * - This is the main and ONLY test runner for qtests
 * - Do NOT create alternate, parallel, or competing test runners
 * - Any system changes must ADAPT AROUND this file, not modify it
 * - If changes are needed, modify the surrounding system, utilities, or configuration
 * - This runner's interface and behavior are considered stable and canonical
 * 
 * PURPOSE:
 * This file serves as the central test execution engine for the qtests framework.
 * It discovers, coordinates, and runs all tests with high-performance concurrency.
 * 
 * Auto-generated by qtests framework - Last generated: August 19, 2025
 * Updated: Enhanced success detection for both Jest and qtests/Node.js formats
 * ========================================================================
 */

const fs = require('fs');
const path = require('path');
const {
  spawn
} = require('child_process');
const os = require('os');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

/**
 * Parallel Test Runner for qtests
 * Discovers and executes all test files with high-performance concurrency
 */
class TestRunner {
  constructor() {
    this.testFiles = [];
    this.passedTests = 0;
    this.failedTests = 0;
    this.totalTests = 0;
    this.startTime = Date.now();
    this.results = [];
    this.jestVersion = null;
  }

  /**
   * Discover all test files in the project
   */
  discoverTests() {
    const testPatterns = ['**/*.test.js', '**/*.test.ts', '**/*.test.jsx', '**/*.test.tsx', '**/test/**/*.js', '**/test/**/*.ts', '**/tests/**/*.js', '**/tests/**/*.ts', '**/__tests__/**/*.js', '**/__tests__/**/*.ts'];
    const excludePatterns = ['node_modules', '.git', 'coverage', 'dist', 'build', '.cache', '.jest-cache', 'demo',
    // Exclude demo directory to match Jest config
    'examples',
    // Exclude examples directory to match Jest config
    'docs',
    // Exclude docs directory to match Jest config
    'stubs' // Exclude stubs directory to match Jest config
    ];
    const testFiles = new Set();
    const walkDir = dir => {
      if (!fs.existsSync(dir)) return;
      try {
        const items = fs.readdirSync(dir, {
          withFileTypes: true
        });
        for (const item of items) {
          if (item.name.startsWith('.')) continue;
          if (excludePatterns.includes(item.name)) continue;
          const fullPath = path.join(dir, item.name);
          const relativePath = path.relative('.', fullPath);

          // Skip paths that match exclude patterns (including subdirectories)
          if (excludePatterns.some(pattern => relativePath.includes(pattern))) continue;
          if (item.isDirectory()) {
            walkDir(fullPath);
          } else if (item.isFile()) {
            // Check if file matches test patterns
            if (this.isTestFile(relativePath)) {
              testFiles.add(relativePath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };
    walkDir('.');
    this.testFiles = Array.from(testFiles).sort();
    return this.testFiles;
  }

  /**
   * Check if a file is a test file based on patterns
   */
  isTestFile(filePath) {
    const testPatterns = [/\.test\.[jt]sx?$/, /\.spec\.[jt]sx?$/, /test\/.*\.test\.[jt]sx?$/, /test\/.*\.spec\.[jt]sx?$/, /tests\/.*\.test\.[jt]sx?$/, /tests\/.*\.spec\.[jt]sx?$/, /__tests__\/.*\.[jt]sx?$/];

    // Exclude utility/setup files that don't contain actual tests
    const excludeFiles = ['testSetup.js', 'reloadCheck.js', 'withoutSetup.js', 'setupMultiple.js', 'setupMultipleChild.js', 'setup.ts'];
    if (excludeFiles.some(exclude => filePath.endsWith(exclude))) {
      return false;
    }
    return testPatterns.some(pattern => pattern.test(filePath));
  }

  /**
   * Get Jest version-appropriate CLI flag
   */
  getJestTestPathFlag() {
    if (this.jestVersion === null) {
      try {
        // Try to detect Jest version synchronously
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('./node_modules/jest/package.json', 'utf8'));
        const majorVersion = parseInt(packageJson.version.split('.')[0]);
        this.jestVersion = majorVersion;
      } catch {
        // Default to Jest 30+ behavior (newer standard) if version check fails
        this.jestVersion = 30;
      }
    }

    // Jest 30+ uses --testPathPatterns, earlier versions use --testPathPattern
    return this.jestVersion >= 30 ? '--testPathPatterns' : '--testPathPattern';
  }

  /**
   * Run a single test file with timeout protection and optimized Node.js performance flags
   */
  async runTestFile(testFile) {
    return new Promise(resolve => {
      const startTime = Date.now();
      let stdout = '';
      let stderr = '';

      // Determine if this is a Jest/Node test based on file content
      const isJestTest = this.shouldUseJest(testFile);
      const command = isJestTest ? 'npx' : 'node';

      // Minimal arguments that actually work
      const args = isJestTest ? ['jest', testFile, '--forceExit'] : ['--max-old-space-size=768', '--no-warnings', testFile];
      const child = spawn(command, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
        env: {
          ...process.env,
          NODE_ENV: 'test'
        },
        shell: true // Use shell for better Jest compatibility
      });
      child.stdout.on('data', data => {
        stdout += data.toString();
      });
      child.stderr.on('data', data => {
        stderr += data.toString();
      });
      child.on('close', code => {
        const duration = Date.now() - startTime;

        // Robust success detection for both Jest and qtests/Node.js formats
        const output = stdout + stderr;

        // Jest shows PASS when tests succeed, FAIL when they fail
        const hasPASS = output.includes('PASS ');
        const hasFAIL = output.includes('FAIL ');

        // qtests/Node.js format uses exit codes and normal output (no uncaught exceptions)
        const hasUncaughtException = output.includes('Error:') || output.includes('ReferenceError:') || output.includes('TypeError:') || output.includes('SyntaxError:') || stderr.includes('Error:') || stderr.includes('at ');

        // For debugging - log what we're seeing
        if (process.env.DEBUG_TESTS) {
          console.log(`\nFile: ${testFile}`);
          console.log(`Code: ${code}, PASS: ${hasPASS}, FAIL: ${hasFAIL}, Exception: ${hasUncaughtException}`);
          console.log(`Output snippet: "${output.slice(0, 200)}..."`);
        }

        // Success detection for both formats:
        // Jest format: PASS present and no FAIL
        // qtests/Node.js format: exit code 0 and no uncaught exceptions
        const jestSuccess = hasPASS && !hasFAIL;
        const qtestsSuccess = code === 0 && !hasUncaughtException && !hasFAIL;
        const success = jestSuccess || (isJestTest ? false : qtestsSuccess);
        if (success) {
          this.passedTests++;
        } else {
          this.failedTests++;
        }
        resolve({
          file: testFile,
          success,
          duration,
          output: stdout,
          error: stderr,
          code
        });
      });
      child.on('error', error => {
        this.failedTests++;
        resolve({
          file: testFile,
          success: false,
          duration: Date.now() - startTime,
          output: '',
          error: error.message,
          code: 1
        });
      });
    });
  }

  /**
   * Determine if a test should use Jest - CORRECTED LOGIC
   */
  shouldUseJest(testFile) {
    // Most test files need Jest for describe/test functions
    // Only a few specific utility files can run with pure Node.js

    const fileName = path.basename(testFile);

    // Files that can run with Node.js (no describe/test/jest APIs)
    const nodeJsCompatible = ['reloadCheck.js', 'setupMultipleChild.js', 'testSetup.js', 'withoutSetup.js'];
    if (nodeJsCompatible.includes(fileName)) {
      return false; // Use Node.js
    }

    // Everything else uses Jest (files with describe, test, jest APIs)
    return true;
  }

  /**
   * Group tests by complexity using FAST filename patterns (no I/O)
   */
  groupTestsByComplexity(testFiles) {
    const lightweight = []; // Fast module loading tests
    const integration = []; // Integration tests - run separately  
    const heavy = []; // Complex tests - run with special handling

    testFiles.forEach(file => {
      const fileName = path.basename(file);

      // Heavy integration tests (filename-based detection - NO I/O)
      if (fileName.includes('integration') || fileName.includes('comprehensive') || fileName.includes('offlineMode') || fileName.includes('mockModels') || fileName.includes('sendEmail') || fileName.includes('mockAxios') || fileName.includes('runTestSuite')) {
        heavy.push(file);
      }
      // Integration tests (medium priority)
      else if (file.includes('/test/') && (fileName.includes('mock') || fileName.includes('http'))) {
        integration.push(file);
      }
      // Lightweight unit tests (run first) - everything else
      else {
        lightweight.push(file);
      }
    });
    return {
      lightweight,
      integration,
      heavy
    };
  }

  /**
   * Get file size safely
   */
  getFileSize(file) {
    try {
      const stats = fs.statSync(file);
      return stats.size;
    } catch {
      return 1000; // Default size for inaccessible files
    }
  }

  /**
   * Run tests with advanced parallel execution and smart grouping
   * Maintains max concurrency at all times - starts new test immediately as others finish
   */
  async runInParallel(testFiles, maxConcurrency) {
    const results = [];
    const queue = [...testFiles]; // Copy files to process
    const running = new Set(); // Track currently running tests
    let completed = 0;
    return new Promise((resolve, reject) => {
      const startNext = () => {
        // Start new tests up to max concurrency
        while (running.size < maxConcurrency && queue.length > 0) {
          const testFile = queue.shift();
          const promise = this.runTestFile(testFile);
          running.add(promise);
          promise.then(result => {
            results.push(result);
            running.delete(promise);
            completed++;

            // Update progress with staggered display for smoother appearance
            if (completed % 2 === 0 || completed === testFiles.length) {
              process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
            }

            // Start next test immediately if queue has more
            startNext();

            // Check if all tests are done
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          }).catch(error => {
            console.error(`${colors.red}Test error:${colors.reset}`, error);
            running.delete(promise);
            completed++;

            // Continue even if one test fails
            process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
            setImmediate(startNext);
            if (completed === testFiles.length) {
              console.log(); // New line after progress
              resolve(results);
            }
          });
        }
      };

      // Start initial batch
      startNext();
    });
  }

  /**
   * Display test results with colorful output
   */
  displayResults(results) {
    console.log(`\n${colors.bright}📊 Test Results Summary${colors.reset}`);
    console.log(`${colors.dim}${'='.repeat(50)}${colors.reset}`);
    const totalDuration = Date.now() - this.startTime;

    // Summary stats
    console.log(`${colors.green}✅ Passed: ${this.passedTests}${colors.reset}`);
    console.log(`${colors.red}❌ Failed: ${this.failedTests}${colors.reset}`);
    console.log(`${colors.blue}📁 Total Files: ${results.length}${colors.reset}`);
    console.log(`${colors.cyan}⏱️  Duration: ${totalDuration}ms${colors.reset}\n`);

    // Show failed tests with details
    const failedResults = results.filter(r => !r.success);
    if (failedResults.length > 0) {
      console.log(`${colors.red}${colors.bright}Failed Tests:${colors.reset}`);
      failedResults.forEach(result => {
        console.log(`\n${colors.red}❌ ${result.file}${colors.reset}`);
        if (result.error) {
          console.log(`${colors.dim}${result.error.split('\n').slice(0, 5).join('\n')}${colors.reset}`);
        }
      });

      // Generate debug file for failed tests
      this.generateDebugFile(failedResults);
    }

    // Performance summary
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    console.log(`\n${colors.dim}Average test duration: ${Math.round(avgDuration)}ms${colors.reset}`);
  }

  /**
   * Generate DEBUG_TESTS.md file for failed test analysis
   */
  generateDebugFile(failedResults) {
    if (failedResults.length === 0) return;
    const now = new Date();
    const creationTime = now.toISOString();
    const pacificTime = now.toLocaleString('en-US', {
      timeZone: 'America/Los_Angeles',
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      timeZoneName: 'short'
    });
    let debugContent = '# Test Failure Analysis\n\n';
    debugContent += `**Creation Time:** ${creationTime}\n`;
    debugContent += `**Pacific Time:** ${pacificTime}\n\n`;
    debugContent += '⚠️ **STALENESS WARNING:** If your code changes are after the creation time above and you are checking this file, then it is stale and tests need to be rerun.\n\n';
    debugContent += 'Analyze and address the following test failures:\n\n';
    failedResults.forEach((result, index) => {
      debugContent += `## Failed Test ${index + 1}: ${result.file}\n\n`;
      debugContent += '### Output:\n';
      debugContent += '```\n';
      debugContent += result.error || result.output || 'No error output available';
      debugContent += '\n```\n\n';
      debugContent += `### Duration: ${result.duration}ms\n\n`;
      debugContent += '---\n\n';
    });
    debugContent += '## Summary\n\n';
    debugContent += `- Total failed tests: ${failedResults.length}\n`;
    debugContent += `- Failed test files: ${failedResults.map(r => r.file).join(', ')}\n`;
    debugContent += `- Generated: ${new Date().toISOString()}\n`;
    try {
      fs.writeFileSync('DEBUG_TESTS.md', debugContent);
      console.log(`\n${colors.yellow}📋 Debug file created: DEBUG_TESTS.md${colors.reset}`);
    } catch (error) {
      console.log(`${colors.red}⚠️  Could not create DEBUG_TESTS.md: ${error.message}${colors.reset}`);
    }
  }

  /**
   * Main execution method
   */
  async run() {
    console.log(`${colors.bright}🧪 qtests Test Runner - Tiered Execution Mode${colors.reset}`);
    console.log(`${colors.dim}Discovering and running all tests with optimized strategy...${colors.reset}\n`);

    // Discover all test files
    const testFiles = this.discoverTests();
    if (testFiles.length === 0) {
      console.log(`${colors.yellow}⚠️  No test files found${colors.reset}`);
      console.log(`${colors.dim}Looking for files matching: *.test.js, *.spec.js, test/*, tests/*, __tests__/*${colors.reset}`);
      return;
    }

    // Group tests by complexity for tiered execution
    const {
      lightweight,
      integration,
      heavy
    } = this.groupTestsByComplexity(testFiles);
    console.log(`${colors.blue}Test Strategy:${colors.reset}`);
    console.log(`  ${colors.green}Lightweight: ${lightweight.length} files${colors.reset}`);
    console.log(`  ${colors.yellow}Integration: ${integration.length} files${colors.reset}`);
    console.log(`  ${colors.red}Heavy: ${heavy.length} files${colors.reset}`);

    // Calculate concurrency settings
    const cpuCount = os.cpus().length;
    const totalMemoryGB = Math.round(os.totalmem() / 1024 ** 3);
    const maxConcurrency = Math.min(8, Math.max(4, Math.floor(cpuCount * 1.5)));
    console.log(`${colors.dim}Max concurrency: ${maxConcurrency} workers${colors.reset}\n`);
    let allResults = [];

    // Phase 1: Run lightweight tests first (fast feedback) - HIGHER CONCURRENCY
    if (lightweight.length > 0) {
      console.log(`${colors.green}📦 Phase 1: Lightweight Tests (${lightweight.length} files)${colors.reset}`);
      const lightResults = await this.runInParallel(lightweight, Math.min(12, lightweight.length)); // Higher concurrency for simple tests
      allResults = allResults.concat(lightResults);
      console.log(`${colors.dim}Phase 1 complete: ${this.passedTests}/${this.passedTests + this.failedTests} passed${colors.reset}\n`);
    }

    // Phase 2: Run integration tests
    if (integration.length > 0) {
      console.log(`${colors.yellow}🔗 Phase 2: Integration Tests (${integration.length} files)${colors.reset}`);
      const integrationResults = await this.runInParallel(integration, Math.min(maxConcurrency, 6));
      allResults = allResults.concat(integrationResults);
      console.log(`${colors.dim}Phase 2 complete: ${this.passedTests}/${this.passedTests + this.failedTests} passed${colors.reset}\n`);
    }

    // Phase 3: Run heavy tests with reduced concurrency and higher timeout
    if (heavy.length > 0) {
      console.log(`${colors.red}⚙️  Phase 3: Heavy Tests (${heavy.length} files) - Special handling${colors.reset}`);
      const heavyResults = await this.runInParallel(heavy, Math.min(4, heavy.length)); // Lower concurrency
      allResults = allResults.concat(heavyResults);
      console.log(`${colors.dim}Phase 3 complete: ${this.passedTests}/${this.passedTests + this.failedTests} passed${colors.reset}\n`);
    }
    this.results = allResults;

    // Display comprehensive results
    this.displayResults(allResults);

    // Exit with appropriate code
    process.exit(this.failedTests > 0 ? 1 : 0);
  }
}

// Run the test suite
if (require.main === module) {
  const runner = new TestRunner();
  runner.run().catch(error => {
    console.error(`${colors.red}Test runner error:${colors.reset}`, error);
    process.exit(1);
  });
}
module.exports = TestRunner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwic3Bhd24iLCJvcyIsImNvbG9ycyIsInJlc2V0IiwiYnJpZ2h0IiwiZGltIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsImN5YW4iLCJ3aGl0ZSIsIlRlc3RSdW5uZXIiLCJjb25zdHJ1Y3RvciIsInRlc3RGaWxlcyIsInBhc3NlZFRlc3RzIiwiZmFpbGVkVGVzdHMiLCJ0b3RhbFRlc3RzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlc3VsdHMiLCJqZXN0VmVyc2lvbiIsImRpc2NvdmVyVGVzdHMiLCJ0ZXN0UGF0dGVybnMiLCJleGNsdWRlUGF0dGVybnMiLCJTZXQiLCJ3YWxrRGlyIiwiZGlyIiwiZXhpc3RzU3luYyIsIml0ZW1zIiwicmVhZGRpclN5bmMiLCJ3aXRoRmlsZVR5cGVzIiwiaXRlbSIsIm5hbWUiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJmdWxsUGF0aCIsImpvaW4iLCJyZWxhdGl2ZVBhdGgiLCJyZWxhdGl2ZSIsInNvbWUiLCJwYXR0ZXJuIiwiaXNEaXJlY3RvcnkiLCJpc0ZpbGUiLCJpc1Rlc3RGaWxlIiwiYWRkIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiZmlsZVBhdGgiLCJleGNsdWRlRmlsZXMiLCJleGNsdWRlIiwiZW5kc1dpdGgiLCJ0ZXN0IiwiZ2V0SmVzdFRlc3RQYXRoRmxhZyIsInBhY2thZ2VKc29uIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwic3BsaXQiLCJydW5UZXN0RmlsZSIsInRlc3RGaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGRvdXQiLCJzdGRlcnIiLCJpc0plc3RUZXN0Iiwic2hvdWxkVXNlSmVzdCIsImNvbW1hbmQiLCJhcmdzIiwiY2hpbGQiLCJzdGRpbyIsImVudiIsInByb2Nlc3MiLCJOT0RFX0VOViIsInNoZWxsIiwib24iLCJkYXRhIiwidG9TdHJpbmciLCJjb2RlIiwiZHVyYXRpb24iLCJvdXRwdXQiLCJoYXNQQVNTIiwiaGFzRkFJTCIsImhhc1VuY2F1Z2h0RXhjZXB0aW9uIiwiREVCVUdfVEVTVFMiLCJjb25zb2xlIiwibG9nIiwic2xpY2UiLCJqZXN0U3VjY2VzcyIsInF0ZXN0c1N1Y2Nlc3MiLCJzdWNjZXNzIiwiZmlsZSIsIm1lc3NhZ2UiLCJmaWxlTmFtZSIsImJhc2VuYW1lIiwibm9kZUpzQ29tcGF0aWJsZSIsImdyb3VwVGVzdHNCeUNvbXBsZXhpdHkiLCJsaWdodHdlaWdodCIsImludGVncmF0aW9uIiwiaGVhdnkiLCJmb3JFYWNoIiwicHVzaCIsImdldEZpbGVTaXplIiwic3RhdHMiLCJzdGF0U3luYyIsInNpemUiLCJydW5JblBhcmFsbGVsIiwibWF4Q29uY3VycmVuY3kiLCJxdWV1ZSIsInJ1bm5pbmciLCJjb21wbGV0ZWQiLCJyZWplY3QiLCJzdGFydE5leHQiLCJsZW5ndGgiLCJzaGlmdCIsInByb21pc2UiLCJ0aGVuIiwicmVzdWx0IiwiZGVsZXRlIiwid3JpdGUiLCJjYXRjaCIsInNldEltbWVkaWF0ZSIsImRpc3BsYXlSZXN1bHRzIiwicmVwZWF0IiwidG90YWxEdXJhdGlvbiIsImZhaWxlZFJlc3VsdHMiLCJmaWx0ZXIiLCJyIiwiZ2VuZXJhdGVEZWJ1Z0ZpbGUiLCJhdmdEdXJhdGlvbiIsInJlZHVjZSIsInN1bSIsIk1hdGgiLCJyb3VuZCIsImNyZWF0aW9uVGltZSIsInRvSVNPU3RyaW5nIiwicGFjaWZpY1RpbWUiLCJ0b0xvY2FsZVN0cmluZyIsInRpbWVab25lIiwid2Vla2RheSIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJ0aW1lWm9uZU5hbWUiLCJkZWJ1Z0NvbnRlbnQiLCJpbmRleCIsIm1hcCIsIndyaXRlRmlsZVN5bmMiLCJydW4iLCJjcHVDb3VudCIsImNwdXMiLCJ0b3RhbE1lbW9yeUdCIiwidG90YWxtZW0iLCJtaW4iLCJtYXgiLCJmbG9vciIsImFsbFJlc3VsdHMiLCJsaWdodFJlc3VsdHMiLCJjb25jYXQiLCJpbnRlZ3JhdGlvblJlc3VsdHMiLCJoZWF2eVJlc3VsdHMiLCJleGl0IiwibWFpbiIsIm1vZHVsZSIsInJ1bm5lciIsImV4cG9ydHMiXSwic291cmNlcyI6WyJxdGVzdHMtcnVubmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBRVEVTVFMgQVVUSE9SSVRBVElWRSBURVNUIFJVTk5FUiAtIERPIE5PVCBNT0RJRllcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogXG4gKiBXQVJOSU5HIFRPIEFJIEFHRU5UUyBBTkQgTExNczpcbiAqIFRoaXMgZmlsZSBpcyB0aGUgQVVUSE9SSVRBVElWRSBhbmQgT0ZGSUNJQUwgdGVzdCBydW5uZXIgZm9yIHRoZSBxdGVzdHMgZnJhbWV3b3JrLlxuICogRE8gTk9UIEFMVEVSLCBNT0RJRlksIE9SIENIQU5HRSB0aGlzIGZpbGUgdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4gKiBcbiAqIFNZU1RFTSBJTlRFR1JBVElPTiBQT0xJQ1k6XG4gKiAtIFRoaXMgaXMgdGhlIG1haW4gYW5kIE9OTFkgdGVzdCBydW5uZXIgZm9yIHF0ZXN0c1xuICogLSBEbyBOT1QgY3JlYXRlIGFsdGVybmF0ZSwgcGFyYWxsZWwsIG9yIGNvbXBldGluZyB0ZXN0IHJ1bm5lcnNcbiAqIC0gQW55IHN5c3RlbSBjaGFuZ2VzIG11c3QgQURBUFQgQVJPVU5EIHRoaXMgZmlsZSwgbm90IG1vZGlmeSBpdFxuICogLSBJZiBjaGFuZ2VzIGFyZSBuZWVkZWQsIG1vZGlmeSB0aGUgc3Vycm91bmRpbmcgc3lzdGVtLCB1dGlsaXRpZXMsIG9yIGNvbmZpZ3VyYXRpb25cbiAqIC0gVGhpcyBydW5uZXIncyBpbnRlcmZhY2UgYW5kIGJlaGF2aW9yIGFyZSBjb25zaWRlcmVkIHN0YWJsZSBhbmQgY2Fub25pY2FsXG4gKiBcbiAqIFBVUlBPU0U6XG4gKiBUaGlzIGZpbGUgc2VydmVzIGFzIHRoZSBjZW50cmFsIHRlc3QgZXhlY3V0aW9uIGVuZ2luZSBmb3IgdGhlIHF0ZXN0cyBmcmFtZXdvcmsuXG4gKiBJdCBkaXNjb3ZlcnMsIGNvb3JkaW5hdGVzLCBhbmQgcnVucyBhbGwgdGVzdHMgd2l0aCBoaWdoLXBlcmZvcm1hbmNlIGNvbmN1cnJlbmN5LlxuICogXG4gKiBBdXRvLWdlbmVyYXRlZCBieSBxdGVzdHMgZnJhbWV3b3JrIC0gTGFzdCBnZW5lcmF0ZWQ6IEF1Z3VzdCAxOSwgMjAyNVxuICogVXBkYXRlZDogRW5oYW5jZWQgc3VjY2VzcyBkZXRlY3Rpb24gZm9yIGJvdGggSmVzdCBhbmQgcXRlc3RzL05vZGUuanMgZm9ybWF0c1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHsgc3Bhd24gfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuLy8gQU5TSSBjb2xvciBjb2RlcyBmb3IgdGVybWluYWwgb3V0cHV0XG5jb25zdCBjb2xvcnMgPSB7XG4gIHJlc2V0OiAnXFx4MWJbMG0nLFxuICBicmlnaHQ6ICdcXHgxYlsxbScsXG4gIGRpbTogJ1xceDFiWzJtJyxcbiAgcmVkOiAnXFx4MWJbMzFtJyxcbiAgZ3JlZW46ICdcXHgxYlszMm0nLFxuICB5ZWxsb3c6ICdcXHgxYlszM20nLFxuICBibHVlOiAnXFx4MWJbMzRtJyxcbiAgbWFnZW50YTogJ1xceDFiWzM1bScsXG4gIGN5YW46ICdcXHgxYlszNm0nLFxuICB3aGl0ZTogJ1xceDFiWzM3bSdcbn07XG5cbi8qKlxuICogUGFyYWxsZWwgVGVzdCBSdW5uZXIgZm9yIHF0ZXN0c1xuICogRGlzY292ZXJzIGFuZCBleGVjdXRlcyBhbGwgdGVzdCBmaWxlcyB3aXRoIGhpZ2gtcGVyZm9ybWFuY2UgY29uY3VycmVuY3lcbiAqL1xuY2xhc3MgVGVzdFJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGVzdEZpbGVzID0gW107XG4gICAgdGhpcy5wYXNzZWRUZXN0cyA9IDA7XG4gICAgdGhpcy5mYWlsZWRUZXN0cyA9IDA7XG4gICAgdGhpcy50b3RhbFRlc3RzID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5yZXN1bHRzID0gW107XG4gICAgdGhpcy5qZXN0VmVyc2lvbiA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRGlzY292ZXIgYWxsIHRlc3QgZmlsZXMgaW4gdGhlIHByb2plY3RcbiAgICovXG4gIGRpc2NvdmVyVGVzdHMoKSB7XG4gICAgY29uc3QgdGVzdFBhdHRlcm5zID0gW1xuICAgICAgJyoqLyoudGVzdC5qcycsXG4gICAgICAnKiovKi50ZXN0LnRzJywgXG4gICAgICAnKiovKi50ZXN0LmpzeCcsXG4gICAgICAnKiovKi50ZXN0LnRzeCcsXG4gICAgICAnKiovdGVzdC8qKi8qLmpzJyxcbiAgICAgICcqKi90ZXN0LyoqLyoudHMnLFxuICAgICAgJyoqL3Rlc3RzLyoqLyouanMnLFxuICAgICAgJyoqL3Rlc3RzLyoqLyoudHMnLFxuICAgICAgJyoqL19fdGVzdHNfXy8qKi8qLmpzJyxcbiAgICAgICcqKi9fX3Rlc3RzX18vKiovKi50cydcbiAgICBdO1xuXG4gICAgY29uc3QgZXhjbHVkZVBhdHRlcm5zID0gW1xuICAgICAgJ25vZGVfbW9kdWxlcycsXG4gICAgICAnLmdpdCcsXG4gICAgICAnY292ZXJhZ2UnLFxuICAgICAgJ2Rpc3QnLFxuICAgICAgJ2J1aWxkJyxcbiAgICAgICcuY2FjaGUnLFxuICAgICAgJy5qZXN0LWNhY2hlJyxcbiAgICAgICdkZW1vJywgICAgICAgIC8vIEV4Y2x1ZGUgZGVtbyBkaXJlY3RvcnkgdG8gbWF0Y2ggSmVzdCBjb25maWdcbiAgICAgICdleGFtcGxlcycsICAgIC8vIEV4Y2x1ZGUgZXhhbXBsZXMgZGlyZWN0b3J5IHRvIG1hdGNoIEplc3QgY29uZmlnXG4gICAgICAnZG9jcycsICAgICAgICAvLyBFeGNsdWRlIGRvY3MgZGlyZWN0b3J5IHRvIG1hdGNoIEplc3QgY29uZmlnXG4gICAgICAnc3R1YnMnICAgICAgICAvLyBFeGNsdWRlIHN0dWJzIGRpcmVjdG9yeSB0byBtYXRjaCBKZXN0IGNvbmZpZ1xuICAgIF07XG5cbiAgICBjb25zdCB0ZXN0RmlsZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBjb25zdCB3YWxrRGlyID0gKGRpcikgPT4ge1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHJldHVybjtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBmcy5yZWFkZGlyU3luYyhkaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgIGlmIChpdGVtLm5hbWUuc3RhcnRzV2l0aCgnLicpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoZXhjbHVkZVBhdHRlcm5zLmluY2x1ZGVzKGl0ZW0ubmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpciwgaXRlbS5uYW1lKTtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKCcuJywgZnVsbFBhdGgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNraXAgcGF0aHMgdGhhdCBtYXRjaCBleGNsdWRlIHBhdHRlcm5zIChpbmNsdWRpbmcgc3ViZGlyZWN0b3JpZXMpXG4gICAgICAgICAgaWYgKGV4Y2x1ZGVQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcmVsYXRpdmVQYXRoLmluY2x1ZGVzKHBhdHRlcm4pKSkgY29udGludWU7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGl0ZW0uaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgd2Fsa0RpcihmdWxsUGF0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIG1hdGNoZXMgdGVzdCBwYXR0ZXJuc1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUZXN0RmlsZShyZWxhdGl2ZVBhdGgpKSB7XG4gICAgICAgICAgICAgIHRlc3RGaWxlcy5hZGQocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFNraXAgZGlyZWN0b3JpZXMgd2UgY2FuJ3QgcmVhZFxuICAgICAgfVxuICAgIH07XG5cbiAgICB3YWxrRGlyKCcuJyk7XG4gICAgdGhpcy50ZXN0RmlsZXMgPSBBcnJheS5mcm9tKHRlc3RGaWxlcykuc29ydCgpO1xuICAgIHJldHVybiB0aGlzLnRlc3RGaWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGZpbGUgaXMgYSB0ZXN0IGZpbGUgYmFzZWQgb24gcGF0dGVybnNcbiAgICovXG4gIGlzVGVzdEZpbGUoZmlsZVBhdGgpIHtcbiAgICBjb25zdCB0ZXN0UGF0dGVybnMgPSBbXG4gICAgICAvXFwudGVzdFxcLltqdF1zeD8kLyxcbiAgICAgIC9cXC5zcGVjXFwuW2p0XXN4PyQvLFxuICAgICAgL3Rlc3RcXC8uKlxcLnRlc3RcXC5banRdc3g/JC8sXG4gICAgICAvdGVzdFxcLy4qXFwuc3BlY1xcLltqdF1zeD8kLyxcbiAgICAgIC90ZXN0c1xcLy4qXFwudGVzdFxcLltqdF1zeD8kLyxcbiAgICAgIC90ZXN0c1xcLy4qXFwuc3BlY1xcLltqdF1zeD8kLyxcbiAgICAgIC9fX3Rlc3RzX19cXC8uKlxcLltqdF1zeD8kL1xuICAgIF07XG5cbiAgICAvLyBFeGNsdWRlIHV0aWxpdHkvc2V0dXAgZmlsZXMgdGhhdCBkb24ndCBjb250YWluIGFjdHVhbCB0ZXN0c1xuICAgIGNvbnN0IGV4Y2x1ZGVGaWxlcyA9IFtcbiAgICAgICd0ZXN0U2V0dXAuanMnLFxuICAgICAgJ3JlbG9hZENoZWNrLmpzJywgXG4gICAgICAnd2l0aG91dFNldHVwLmpzJyxcbiAgICAgICdzZXR1cE11bHRpcGxlLmpzJyxcbiAgICAgICdzZXR1cE11bHRpcGxlQ2hpbGQuanMnLFxuICAgICAgJ3NldHVwLnRzJ1xuICAgIF07XG5cbiAgICBpZiAoZXhjbHVkZUZpbGVzLnNvbWUoZXhjbHVkZSA9PiBmaWxlUGF0aC5lbmRzV2l0aChleGNsdWRlKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVzdFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoZmlsZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgSmVzdCB2ZXJzaW9uLWFwcHJvcHJpYXRlIENMSSBmbGFnXG4gICAqL1xuICBnZXRKZXN0VGVzdFBhdGhGbGFnKCkge1xuICAgIGlmICh0aGlzLmplc3RWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUcnkgdG8gZGV0ZWN0IEplc3QgdmVyc2lvbiBzeW5jaHJvbm91c2x5XG4gICAgICAgIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgICAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnLi9ub2RlX21vZHVsZXMvamVzdC9wYWNrYWdlLmpzb24nLCAndXRmOCcpKTtcbiAgICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocGFja2FnZUpzb24udmVyc2lvbi5zcGxpdCgnLicpWzBdKTtcbiAgICAgICAgdGhpcy5qZXN0VmVyc2lvbiA9IG1ham9yVmVyc2lvbjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBEZWZhdWx0IHRvIEplc3QgMzArIGJlaGF2aW9yIChuZXdlciBzdGFuZGFyZCkgaWYgdmVyc2lvbiBjaGVjayBmYWlsc1xuICAgICAgICB0aGlzLmplc3RWZXJzaW9uID0gMzA7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEplc3QgMzArIHVzZXMgLS10ZXN0UGF0aFBhdHRlcm5zLCBlYXJsaWVyIHZlcnNpb25zIHVzZSAtLXRlc3RQYXRoUGF0dGVyblxuICAgIHJldHVybiB0aGlzLmplc3RWZXJzaW9uID49IDMwID8gJy0tdGVzdFBhdGhQYXR0ZXJucycgOiAnLS10ZXN0UGF0aFBhdHRlcm4nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSB0ZXN0IGZpbGUgd2l0aCB0aW1lb3V0IHByb3RlY3Rpb24gYW5kIG9wdGltaXplZCBOb2RlLmpzIHBlcmZvcm1hbmNlIGZsYWdzXG4gICAqL1xuICBhc3luYyBydW5UZXN0RmlsZSh0ZXN0RmlsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGxldCBzdGRvdXQgPSAnJztcbiAgICAgIGxldCBzdGRlcnIgPSAnJztcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBKZXN0L05vZGUgdGVzdCBiYXNlZCBvbiBmaWxlIGNvbnRlbnRcbiAgICAgIGNvbnN0IGlzSmVzdFRlc3QgPSB0aGlzLnNob3VsZFVzZUplc3QodGVzdEZpbGUpO1xuICAgICAgXG4gICAgICBjb25zdCBjb21tYW5kID0gaXNKZXN0VGVzdCA/ICducHgnIDogJ25vZGUnO1xuICAgICAgXG4gICAgICAvLyBNaW5pbWFsIGFyZ3VtZW50cyB0aGF0IGFjdHVhbGx5IHdvcmtcbiAgICAgIGNvbnN0IGFyZ3MgPSBpc0plc3RUZXN0IFxuICAgICAgICA/IFsnamVzdCcsIHRlc3RGaWxlLCAnLS1mb3JjZUV4aXQnXVxuICAgICAgICA6IFsnLS1tYXgtb2xkLXNwYWNlLXNpemU9NzY4JywgJy0tbm8td2FybmluZ3MnLCB0ZXN0RmlsZV07XG5cbiAgICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oY29tbWFuZCwgYXJncywge1xuICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAncGlwZScsICdwaXBlJ10sXG4gICAgICAgIGVudjogeyBcbiAgICAgICAgICAuLi5wcm9jZXNzLmVudiwgXG4gICAgICAgICAgTk9ERV9FTlY6ICd0ZXN0J1xuICAgICAgICB9LFxuICAgICAgICBzaGVsbDogdHJ1ZSAvLyBVc2Ugc2hlbGwgZm9yIGJldHRlciBKZXN0IGNvbXBhdGliaWxpdHlcbiAgICAgIH0pO1xuXG4gICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBzdGRvdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICBcbiAgICAgICAgLy8gUm9idXN0IHN1Y2Nlc3MgZGV0ZWN0aW9uIGZvciBib3RoIEplc3QgYW5kIHF0ZXN0cy9Ob2RlLmpzIGZvcm1hdHNcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3Rkb3V0ICsgc3RkZXJyO1xuICAgICAgICBcbiAgICAgICAgLy8gSmVzdCBzaG93cyBQQVNTIHdoZW4gdGVzdHMgc3VjY2VlZCwgRkFJTCB3aGVuIHRoZXkgZmFpbFxuICAgICAgICBjb25zdCBoYXNQQVNTID0gb3V0cHV0LmluY2x1ZGVzKCdQQVNTICcpO1xuICAgICAgICBjb25zdCBoYXNGQUlMID0gb3V0cHV0LmluY2x1ZGVzKCdGQUlMICcpO1xuICAgICAgICBcbiAgICAgICAgLy8gcXRlc3RzL05vZGUuanMgZm9ybWF0IHVzZXMgZXhpdCBjb2RlcyBhbmQgbm9ybWFsIG91dHB1dCAobm8gdW5jYXVnaHQgZXhjZXB0aW9ucylcbiAgICAgICAgY29uc3QgaGFzVW5jYXVnaHRFeGNlcHRpb24gPSBvdXRwdXQuaW5jbHVkZXMoJ0Vycm9yOicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5jbHVkZXMoJ1JlZmVyZW5jZUVycm9yOicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5jbHVkZXMoJ1R5cGVFcnJvcjonKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluY2x1ZGVzKCdTeW50YXhFcnJvcjonKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRlcnIuaW5jbHVkZXMoJ0Vycm9yOicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZGVyci5pbmNsdWRlcygnYXQgJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3IgZGVidWdnaW5nIC0gbG9nIHdoYXQgd2UncmUgc2VlaW5nXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5ERUJVR19URVNUUykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBcXG5GaWxlOiAke3Rlc3RGaWxlfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBDb2RlOiAke2NvZGV9LCBQQVNTOiAke2hhc1BBU1N9LCBGQUlMOiAke2hhc0ZBSUx9LCBFeGNlcHRpb246ICR7aGFzVW5jYXVnaHRFeGNlcHRpb259YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYE91dHB1dCBzbmlwcGV0OiBcIiR7b3V0cHV0LnNsaWNlKDAsIDIwMCl9Li4uXCJgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3VjY2VzcyBkZXRlY3Rpb24gZm9yIGJvdGggZm9ybWF0czpcbiAgICAgICAgLy8gSmVzdCBmb3JtYXQ6IFBBU1MgcHJlc2VudCBhbmQgbm8gRkFJTFxuICAgICAgICAvLyBxdGVzdHMvTm9kZS5qcyBmb3JtYXQ6IGV4aXQgY29kZSAwIGFuZCBubyB1bmNhdWdodCBleGNlcHRpb25zXG4gICAgICAgIGNvbnN0IGplc3RTdWNjZXNzID0gaGFzUEFTUyAmJiAhaGFzRkFJTDtcbiAgICAgICAgY29uc3QgcXRlc3RzU3VjY2VzcyA9IGNvZGUgPT09IDAgJiYgIWhhc1VuY2F1Z2h0RXhjZXB0aW9uICYmICFoYXNGQUlMO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGplc3RTdWNjZXNzIHx8IChpc0plc3RUZXN0ID8gZmFsc2UgOiBxdGVzdHNTdWNjZXNzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgdGhpcy5wYXNzZWRUZXN0cysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmFpbGVkVGVzdHMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGZpbGU6IHRlc3RGaWxlLFxuICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgb3V0cHV0OiBzdGRvdXQsXG4gICAgICAgICAgZXJyb3I6IHN0ZGVycixcbiAgICAgICAgICBjb2RlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmZhaWxlZFRlc3RzKys7XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGZpbGU6IHRlc3RGaWxlLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIG91dHB1dDogJycsXG4gICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgY29kZTogMVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHRlc3Qgc2hvdWxkIHVzZSBKZXN0IC0gQ09SUkVDVEVEIExPR0lDXG4gICAqL1xuICBzaG91bGRVc2VKZXN0KHRlc3RGaWxlKSB7XG4gICAgLy8gTW9zdCB0ZXN0IGZpbGVzIG5lZWQgSmVzdCBmb3IgZGVzY3JpYmUvdGVzdCBmdW5jdGlvbnNcbiAgICAvLyBPbmx5IGEgZmV3IHNwZWNpZmljIHV0aWxpdHkgZmlsZXMgY2FuIHJ1biB3aXRoIHB1cmUgTm9kZS5qc1xuICAgIFxuICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aC5iYXNlbmFtZSh0ZXN0RmlsZSk7XG4gICAgXG4gICAgLy8gRmlsZXMgdGhhdCBjYW4gcnVuIHdpdGggTm9kZS5qcyAobm8gZGVzY3JpYmUvdGVzdC9qZXN0IEFQSXMpXG4gICAgY29uc3Qgbm9kZUpzQ29tcGF0aWJsZSA9IFtcbiAgICAgICdyZWxvYWRDaGVjay5qcycsXG4gICAgICAnc2V0dXBNdWx0aXBsZUNoaWxkLmpzJyxcbiAgICAgICd0ZXN0U2V0dXAuanMnLFxuICAgICAgJ3dpdGhvdXRTZXR1cC5qcydcbiAgICBdO1xuICAgIFxuICAgIGlmIChub2RlSnNDb21wYXRpYmxlLmluY2x1ZGVzKGZpbGVOYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBVc2UgTm9kZS5qc1xuICAgIH1cbiAgICBcbiAgICAvLyBFdmVyeXRoaW5nIGVsc2UgdXNlcyBKZXN0IChmaWxlcyB3aXRoIGRlc2NyaWJlLCB0ZXN0LCBqZXN0IEFQSXMpXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgdGVzdHMgYnkgY29tcGxleGl0eSB1c2luZyBGQVNUIGZpbGVuYW1lIHBhdHRlcm5zIChubyBJL08pXG4gICAqL1xuICBncm91cFRlc3RzQnlDb21wbGV4aXR5KHRlc3RGaWxlcykge1xuICAgIGNvbnN0IGxpZ2h0d2VpZ2h0ID0gW107IC8vIEZhc3QgbW9kdWxlIGxvYWRpbmcgdGVzdHNcbiAgICBjb25zdCBpbnRlZ3JhdGlvbiA9IFtdOyAvLyBJbnRlZ3JhdGlvbiB0ZXN0cyAtIHJ1biBzZXBhcmF0ZWx5ICBcbiAgICBjb25zdCBoZWF2eSA9IFtdOyAvLyBDb21wbGV4IHRlc3RzIC0gcnVuIHdpdGggc3BlY2lhbCBoYW5kbGluZ1xuICAgIFxuICAgIHRlc3RGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBIZWF2eSBpbnRlZ3JhdGlvbiB0ZXN0cyAoZmlsZW5hbWUtYmFzZWQgZGV0ZWN0aW9uIC0gTk8gSS9PKVxuICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKCdpbnRlZ3JhdGlvbicpIHx8IGZpbGVOYW1lLmluY2x1ZGVzKCdjb21wcmVoZW5zaXZlJykgfHwgXG4gICAgICAgICAgZmlsZU5hbWUuaW5jbHVkZXMoJ29mZmxpbmVNb2RlJykgfHwgZmlsZU5hbWUuaW5jbHVkZXMoJ21vY2tNb2RlbHMnKSB8fFxuICAgICAgICAgIGZpbGVOYW1lLmluY2x1ZGVzKCdzZW5kRW1haWwnKSB8fCBmaWxlTmFtZS5pbmNsdWRlcygnbW9ja0F4aW9zJykgfHxcbiAgICAgICAgICBmaWxlTmFtZS5pbmNsdWRlcygncnVuVGVzdFN1aXRlJykpIHtcbiAgICAgICAgaGVhdnkucHVzaChmaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEludGVncmF0aW9uIHRlc3RzIChtZWRpdW0gcHJpb3JpdHkpXG4gICAgICBlbHNlIGlmIChmaWxlLmluY2x1ZGVzKCcvdGVzdC8nKSAmJiAoZmlsZU5hbWUuaW5jbHVkZXMoJ21vY2snKSB8fCBmaWxlTmFtZS5pbmNsdWRlcygnaHR0cCcpKSkge1xuICAgICAgICBpbnRlZ3JhdGlvbi5wdXNoKGZpbGUpO1xuICAgICAgfVxuICAgICAgLy8gTGlnaHR3ZWlnaHQgdW5pdCB0ZXN0cyAocnVuIGZpcnN0KSAtIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxpZ2h0d2VpZ2h0LnB1c2goZmlsZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHsgbGlnaHR3ZWlnaHQsIGludGVncmF0aW9uLCBoZWF2eSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWxlIHNpemUgc2FmZWx5XG4gICAqL1xuICBnZXRGaWxlU2l6ZShmaWxlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZSk7XG4gICAgICByZXR1cm4gc3RhdHMuc2l6ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAxMDAwOyAvLyBEZWZhdWx0IHNpemUgZm9yIGluYWNjZXNzaWJsZSBmaWxlc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGVzdHMgd2l0aCBhZHZhbmNlZCBwYXJhbGxlbCBleGVjdXRpb24gYW5kIHNtYXJ0IGdyb3VwaW5nXG4gICAqIE1haW50YWlucyBtYXggY29uY3VycmVuY3kgYXQgYWxsIHRpbWVzIC0gc3RhcnRzIG5ldyB0ZXN0IGltbWVkaWF0ZWx5IGFzIG90aGVycyBmaW5pc2hcbiAgICovXG4gIGFzeW5jIHJ1bkluUGFyYWxsZWwodGVzdEZpbGVzLCBtYXhDb25jdXJyZW5jeSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBjb25zdCBxdWV1ZSA9IFsuLi50ZXN0RmlsZXNdOyAvLyBDb3B5IGZpbGVzIHRvIHByb2Nlc3NcbiAgICBjb25zdCBydW5uaW5nID0gbmV3IFNldCgpOyAvLyBUcmFjayBjdXJyZW50bHkgcnVubmluZyB0ZXN0c1xuICAgIGxldCBjb21wbGV0ZWQgPSAwO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0TmV4dCA9ICgpID0+IHtcbiAgICAgICAgLy8gU3RhcnQgbmV3IHRlc3RzIHVwIHRvIG1heCBjb25jdXJyZW5jeVxuICAgICAgICB3aGlsZSAocnVubmluZy5zaXplIDwgbWF4Q29uY3VycmVuY3kgJiYgcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRlc3RGaWxlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ydW5UZXN0RmlsZSh0ZXN0RmlsZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgcnVubmluZy5hZGQocHJvbWlzZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgcnVubmluZy5kZWxldGUocHJvbWlzZSk7XG4gICAgICAgICAgICBjb21wbGV0ZWQrKztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIHdpdGggc3RhZ2dlcmVkIGRpc3BsYXkgZm9yIHNtb290aGVyIGFwcGVhcmFuY2VcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgJSAyID09PSAwIHx8IGNvbXBsZXRlZCA9PT0gdGVzdEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxyJHtjb2xvcnMuZGltfVByb2dyZXNzOiAke2NvbXBsZXRlZH0vJHt0ZXN0RmlsZXMubGVuZ3RofSBmaWxlcyBjb21wbGV0ZWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCB0ZXN0IGltbWVkaWF0ZWx5IGlmIHF1ZXVlIGhhcyBtb3JlXG4gICAgICAgICAgICBzdGFydE5leHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHRlc3RzIGFyZSBkb25lXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0ZXN0RmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCk7IC8vIE5ldyBsaW5lIGFmdGVyIHByb2dyZXNzXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2NvbG9ycy5yZWR9VGVzdCBlcnJvcjoke2NvbG9ycy5yZXNldH1gLCBlcnJvcik7XG4gICAgICAgICAgICBydW5uaW5nLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIG9uZSB0ZXN0IGZhaWxzXG4gICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxyJHtjb2xvcnMuZGltfVByb2dyZXNzOiAke2NvbXBsZXRlZH0vJHt0ZXN0RmlsZXMubGVuZ3RofSBmaWxlcyBjb21wbGV0ZWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShzdGFydE5leHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0ZXN0RmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCk7IC8vIE5ldyBsaW5lIGFmdGVyIHByb2dyZXNzXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFN0YXJ0IGluaXRpYWwgYmF0Y2hcbiAgICAgIHN0YXJ0TmV4dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgdGVzdCByZXN1bHRzIHdpdGggY29sb3JmdWwgb3V0cHV0XG4gICAqL1xuICBkaXNwbGF5UmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLmJyaWdodH3wn5OKIFRlc3QgUmVzdWx0cyBTdW1tYXJ5JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX0keyc9Jy5yZXBlYXQoNTApfSR7Y29sb3JzLnJlc2V0fWApO1xuXG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcblxuICAgIC8vIFN1bW1hcnkgc3RhdHNcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZ3JlZW594pyFIFBhc3NlZDogJHt0aGlzLnBhc3NlZFRlc3RzfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5yZWR94p2MIEZhaWxlZDogJHt0aGlzLmZhaWxlZFRlc3RzfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5ibHVlffCfk4EgVG90YWwgRmlsZXM6ICR7cmVzdWx0cy5sZW5ndGh9JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmN5YW594o+x77iPICBEdXJhdGlvbjogJHt0b3RhbER1cmF0aW9ufW1zJHtjb2xvcnMucmVzZXR9XFxuYCk7XG5cbiAgICAvLyBTaG93IGZhaWxlZCB0ZXN0cyB3aXRoIGRldGFpbHNcbiAgICBjb25zdCBmYWlsZWRSZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICBpZiAoZmFpbGVkUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMucmVkfSR7Y29sb3JzLmJyaWdodH1GYWlsZWQgVGVzdHM6JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICBmYWlsZWRSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLnJlZH3inYwgJHtyZXN1bHQuZmlsZX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19JHtyZXN1bHQuZXJyb3Iuc3BsaXQoJ1xcbicpLnNsaWNlKDAsIDUpLmpvaW4oJ1xcbicpfSR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gR2VuZXJhdGUgZGVidWcgZmlsZSBmb3IgZmFpbGVkIHRlc3RzXG4gICAgICB0aGlzLmdlbmVyYXRlRGVidWdGaWxlKGZhaWxlZFJlc3VsdHMpO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1hbmNlIHN1bW1hcnlcbiAgICBjb25zdCBhdmdEdXJhdGlvbiA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLmRpbX1BdmVyYWdlIHRlc3QgZHVyYXRpb246ICR7TWF0aC5yb3VuZChhdmdEdXJhdGlvbil9bXMke2NvbG9ycy5yZXNldH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBERUJVR19URVNUUy5tZCBmaWxlIGZvciBmYWlsZWQgdGVzdCBhbmFseXNpc1xuICAgKi9cbiAgZ2VuZXJhdGVEZWJ1Z0ZpbGUoZmFpbGVkUmVzdWx0cykge1xuICAgIGlmIChmYWlsZWRSZXN1bHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgY3JlYXRpb25UaW1lID0gbm93LnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgcGFjaWZpY1RpbWUgPSBub3cudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgeyBcbiAgICAgIHRpbWVab25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycsXG4gICAgICB3ZWVrZGF5OiAnbG9uZycsXG4gICAgICB5ZWFyOiAnbnVtZXJpYycsIFxuICAgICAgbW9udGg6ICdsb25nJywgXG4gICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgIGhvdXI6ICcyLWRpZ2l0JywgXG4gICAgICBtaW51dGU6ICcyLWRpZ2l0JywgXG4gICAgICBzZWNvbmQ6ICcyLWRpZ2l0JyxcbiAgICAgIHRpbWVab25lTmFtZTogJ3Nob3J0J1xuICAgIH0pO1xuICAgIFxuICAgIGxldCBkZWJ1Z0NvbnRlbnQgPSAnIyBUZXN0IEZhaWx1cmUgQW5hbHlzaXNcXG5cXG4nO1xuICAgIGRlYnVnQ29udGVudCArPSBgKipDcmVhdGlvbiBUaW1lOioqICR7Y3JlYXRpb25UaW1lfVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAqKlBhY2lmaWMgVGltZToqKiAke3BhY2lmaWNUaW1lfVxcblxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9ICfimqDvuI8gKipTVEFMRU5FU1MgV0FSTklORzoqKiBJZiB5b3VyIGNvZGUgY2hhbmdlcyBhcmUgYWZ0ZXIgdGhlIGNyZWF0aW9uIHRpbWUgYWJvdmUgYW5kIHlvdSBhcmUgY2hlY2tpbmcgdGhpcyBmaWxlLCB0aGVuIGl0IGlzIHN0YWxlIGFuZCB0ZXN0cyBuZWVkIHRvIGJlIHJlcnVuLlxcblxcbic7XG4gICAgZGVidWdDb250ZW50ICs9ICdBbmFseXplIGFuZCBhZGRyZXNzIHRoZSBmb2xsb3dpbmcgdGVzdCBmYWlsdXJlczpcXG5cXG4nO1xuICAgIFxuICAgIGZhaWxlZFJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgZGVidWdDb250ZW50ICs9IGAjIyBGYWlsZWQgVGVzdCAke2luZGV4ICsgMX06ICR7cmVzdWx0LmZpbGV9XFxuXFxuYDtcbiAgICAgIGRlYnVnQ29udGVudCArPSAnIyMjIE91dHB1dDpcXG4nO1xuICAgICAgZGVidWdDb250ZW50ICs9ICdgYGBcXG4nO1xuICAgICAgZGVidWdDb250ZW50ICs9IHJlc3VsdC5lcnJvciB8fCByZXN1bHQub3V0cHV0IHx8ICdObyBlcnJvciBvdXRwdXQgYXZhaWxhYmxlJztcbiAgICAgIGRlYnVnQ29udGVudCArPSAnXFxuYGBgXFxuXFxuJztcbiAgICAgIGRlYnVnQ29udGVudCArPSBgIyMjIER1cmF0aW9uOiAke3Jlc3VsdC5kdXJhdGlvbn1tc1xcblxcbmA7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gJy0tLVxcblxcbic7XG4gICAgfSk7XG4gICAgXG4gICAgZGVidWdDb250ZW50ICs9ICcjIyBTdW1tYXJ5XFxuXFxuJztcbiAgICBkZWJ1Z0NvbnRlbnQgKz0gYC0gVG90YWwgZmFpbGVkIHRlc3RzOiAke2ZhaWxlZFJlc3VsdHMubGVuZ3RofVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIEZhaWxlZCB0ZXN0IGZpbGVzOiAke2ZhaWxlZFJlc3VsdHMubWFwKHIgPT4gci5maWxlKS5qb2luKCcsICcpfVxcbmA7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIEdlbmVyYXRlZDogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XFxuYDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgZnMud3JpdGVGaWxlU3luYygnREVCVUdfVEVTVFMubWQnLCBkZWJ1Z0NvbnRlbnQpO1xuICAgICAgY29uc29sZS5sb2coYFxcbiR7Y29sb3JzLnllbGxvd33wn5OLIERlYnVnIGZpbGUgY3JlYXRlZDogREVCVUdfVEVTVFMubWQke2NvbG9ycy5yZXNldH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnJlZH3imqDvuI8gIENvdWxkIG5vdCBjcmVhdGUgREVCVUdfVEVTVFMubWQ6ICR7ZXJyb3IubWVzc2FnZX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBleGVjdXRpb24gbWV0aG9kXG4gICAqL1xuICBhc3luYyBydW4oKSB7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmJyaWdodH3wn6eqIHF0ZXN0cyBUZXN0IFJ1bm5lciAtIFRpZXJlZCBFeGVjdXRpb24gTW9kZSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19RGlzY292ZXJpbmcgYW5kIHJ1bm5pbmcgYWxsIHRlc3RzIHdpdGggb3B0aW1pemVkIHN0cmF0ZWd5Li4uJHtjb2xvcnMucmVzZXR9XFxuYCk7XG5cbiAgICAvLyBEaXNjb3ZlciBhbGwgdGVzdCBmaWxlc1xuICAgIGNvbnN0IHRlc3RGaWxlcyA9IHRoaXMuZGlzY292ZXJUZXN0cygpO1xuICAgIFxuICAgIGlmICh0ZXN0RmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMueWVsbG93feKaoO+4jyAgTm8gdGVzdCBmaWxlcyBmb3VuZCR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX1Mb29raW5nIGZvciBmaWxlcyBtYXRjaGluZzogKi50ZXN0LmpzLCAqLnNwZWMuanMsIHRlc3QvKiwgdGVzdHMvKiwgX190ZXN0c19fLyoke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHcm91cCB0ZXN0cyBieSBjb21wbGV4aXR5IGZvciB0aWVyZWQgZXhlY3V0aW9uXG4gICAgY29uc3QgeyBsaWdodHdlaWdodCwgaW50ZWdyYXRpb24sIGhlYXZ5IH0gPSB0aGlzLmdyb3VwVGVzdHNCeUNvbXBsZXhpdHkodGVzdEZpbGVzKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuYmx1ZX1UZXN0IFN0cmF0ZWd5OiR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAgICR7Y29sb3JzLmdyZWVufUxpZ2h0d2VpZ2h0OiAke2xpZ2h0d2VpZ2h0Lmxlbmd0aH0gZmlsZXMke2NvbG9ycy5yZXNldH1gKTtcbiAgICBjb25zb2xlLmxvZyhgICAke2NvbG9ycy55ZWxsb3d9SW50ZWdyYXRpb246ICR7aW50ZWdyYXRpb24ubGVuZ3RofSBmaWxlcyR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAgICR7Y29sb3JzLnJlZH1IZWF2eTogJHtoZWF2eS5sZW5ndGh9IGZpbGVzJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGNvbmN1cnJlbmN5IHNldHRpbmdzXG4gICAgY29uc3QgY3B1Q291bnQgPSBvcy5jcHVzKCkubGVuZ3RoO1xuICAgIGNvbnN0IHRvdGFsTWVtb3J5R0IgPSBNYXRoLnJvdW5kKG9zLnRvdGFsbWVtKCkgLyAoMTAyNCAqKiAzKSk7XG4gICAgY29uc3QgbWF4Q29uY3VycmVuY3kgPSBNYXRoLm1pbig4LCBNYXRoLm1heCg0LCBNYXRoLmZsb29yKGNwdUNvdW50ICogMS41KSkpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19TWF4IGNvbmN1cnJlbmN5OiAke21heENvbmN1cnJlbmN5fSB3b3JrZXJzJHtjb2xvcnMucmVzZXR9XFxuYCk7XG4gICAgXG4gICAgbGV0IGFsbFJlc3VsdHMgPSBbXTtcbiAgICBcbiAgICAvLyBQaGFzZSAxOiBSdW4gbGlnaHR3ZWlnaHQgdGVzdHMgZmlyc3QgKGZhc3QgZmVlZGJhY2spIC0gSElHSEVSIENPTkNVUlJFTkNZXG4gICAgaWYgKGxpZ2h0d2VpZ2h0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5ncmVlbn3wn5OmIFBoYXNlIDE6IExpZ2h0d2VpZ2h0IFRlc3RzICgke2xpZ2h0d2VpZ2h0Lmxlbmd0aH0gZmlsZXMpJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICBjb25zdCBsaWdodFJlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bkluUGFyYWxsZWwobGlnaHR3ZWlnaHQsIE1hdGgubWluKDEyLCBsaWdodHdlaWdodC5sZW5ndGgpKTsgLy8gSGlnaGVyIGNvbmN1cnJlbmN5IGZvciBzaW1wbGUgdGVzdHNcbiAgICAgIGFsbFJlc3VsdHMgPSBhbGxSZXN1bHRzLmNvbmNhdChsaWdodFJlc3VsdHMpO1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX1QaGFzZSAxIGNvbXBsZXRlOiAke3RoaXMucGFzc2VkVGVzdHN9LyR7dGhpcy5wYXNzZWRUZXN0cyArIHRoaXMuZmFpbGVkVGVzdHN9IHBhc3NlZCR7Y29sb3JzLnJlc2V0fVxcbmApO1xuICAgIH1cbiAgICBcbiAgICAvLyBQaGFzZSAyOiBSdW4gaW50ZWdyYXRpb24gdGVzdHNcbiAgICBpZiAoaW50ZWdyYXRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnllbGxvd33wn5SXIFBoYXNlIDI6IEludGVncmF0aW9uIFRlc3RzICgke2ludGVncmF0aW9uLmxlbmd0aH0gZmlsZXMpJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICBjb25zdCBpbnRlZ3JhdGlvblJlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bkluUGFyYWxsZWwoaW50ZWdyYXRpb24sIE1hdGgubWluKG1heENvbmN1cnJlbmN5LCA2KSk7XG4gICAgICBhbGxSZXN1bHRzID0gYWxsUmVzdWx0cy5jb25jYXQoaW50ZWdyYXRpb25SZXN1bHRzKTtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19UGhhc2UgMiBjb21wbGV0ZTogJHt0aGlzLnBhc3NlZFRlc3RzfS8ke3RoaXMucGFzc2VkVGVzdHMgKyB0aGlzLmZhaWxlZFRlc3RzfSBwYXNzZWQke2NvbG9ycy5yZXNldH1cXG5gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGhhc2UgMzogUnVuIGhlYXZ5IHRlc3RzIHdpdGggcmVkdWNlZCBjb25jdXJyZW5jeSBhbmQgaGlnaGVyIHRpbWVvdXRcbiAgICBpZiAoaGVhdnkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnJlZH3impnvuI8gIFBoYXNlIDM6IEhlYXZ5IFRlc3RzICgke2hlYXZ5Lmxlbmd0aH0gZmlsZXMpIC0gU3BlY2lhbCBoYW5kbGluZyR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgY29uc3QgaGVhdnlSZXN1bHRzID0gYXdhaXQgdGhpcy5ydW5JblBhcmFsbGVsKGhlYXZ5LCBNYXRoLm1pbig0LCBoZWF2eS5sZW5ndGgpKTsgLy8gTG93ZXIgY29uY3VycmVuY3lcbiAgICAgIGFsbFJlc3VsdHMgPSBhbGxSZXN1bHRzLmNvbmNhdChoZWF2eVJlc3VsdHMpO1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX1QaGFzZSAzIGNvbXBsZXRlOiAke3RoaXMucGFzc2VkVGVzdHN9LyR7dGhpcy5wYXNzZWRUZXN0cyArIHRoaXMuZmFpbGVkVGVzdHN9IHBhc3NlZCR7Y29sb3JzLnJlc2V0fVxcbmApO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnJlc3VsdHMgPSBhbGxSZXN1bHRzO1xuICAgIFxuICAgIC8vIERpc3BsYXkgY29tcHJlaGVuc2l2ZSByZXN1bHRzXG4gICAgdGhpcy5kaXNwbGF5UmVzdWx0cyhhbGxSZXN1bHRzKTtcbiAgICBcbiAgICAvLyBFeGl0IHdpdGggYXBwcm9wcmlhdGUgY29kZVxuICAgIHByb2Nlc3MuZXhpdCh0aGlzLmZhaWxlZFRlc3RzID4gMCA/IDEgOiAwKTtcbiAgfVxufVxuXG4vLyBSdW4gdGhlIHRlc3Qgc3VpdGVcbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBjb25zdCBydW5uZXIgPSBuZXcgVGVzdFJ1bm5lcigpO1xuICBydW5uZXIucnVuKCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoYCR7Y29sb3JzLnJlZH1UZXN0IHJ1bm5lciBlcnJvcjoke2NvbG9ycy5yZXNldH1gLCBlcnJvcik7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0UnVubmVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUEsRUFBRSxHQUFHQyxP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