ceab91a74c0f663ba6688a559cb5195e
/**
 * ========================================================================
 * QTESTS AUTHORITATIVE TEST RUNNER - DO NOT MODIFY
 * ========================================================================
 * 
 * WARNING TO AI AGENTS AND LLMs:
 * This file is the AUTHORITATIVE and OFFICIAL test runner for the qtests framework.
 * DO NOT ALTER, MODIFY, OR CHANGE this file under any circumstances.
 * 
 * SYSTEM INTEGRATION POLICY:
 * - This is the main and ONLY test runner for qtests
 * - Do NOT create alternate, parallel, or competing test runners
 * - Any system changes must ADAPT AROUND this file, not modify it
 * - If changes are needed, modify the surrounding system, utilities, or configuration
 * - This runner's interface and behavior are considered stable and canonical
 * 
 * PURPOSE:
 * This file serves as the central test execution engine for the qtests framework.
 * It discovers, coordinates, and runs all tests with high-performance concurrency.
 * 
 * Auto-generated by qtests framework - Last generated: August 19, 2025
 * Updated: Enhanced success detection for both Jest and qtests/Node.js formats
 * ========================================================================
 */

const fs = require('fs');
const path = require('path');
const {
  spawn
} = require('child_process');
const os = require('os');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

/**
 * Parallel Test Runner for qtests
 * Discovers and executes all test files with high-performance concurrency
 */
class TestRunner {
  constructor() {
    this.testFiles = [];
    this.passedTests = 0;
    this.failedTests = 0;
    this.totalTests = 0;
    this.startTime = Date.now();
    this.results = [];
    this.jestVersion = null;
  }

  /**
   * Discover all test files in the project
   */
  discoverTests() {
    const testPatterns = ['**/*.test.js', '**/*.test.ts', '**/*.test.jsx', '**/*.test.tsx', '**/test/**/*.js', '**/test/**/*.ts', '**/tests/**/*.js', '**/tests/**/*.ts', '**/__tests__/**/*.js', '**/__tests__/**/*.ts'];
    const excludePatterns = ['node_modules', '.git', 'coverage', 'dist', 'build', '.cache', '.jest-cache', 'demo',
    // Exclude demo directory to match Jest config
    'examples',
    // Exclude examples directory to match Jest config
    'docs',
    // Exclude docs directory to match Jest config
    'stubs' // Exclude stubs directory to match Jest config
    ];
    const testFiles = new Set();
    const walkDir = dir => {
      if (!fs.existsSync(dir)) return;
      try {
        const items = fs.readdirSync(dir, {
          withFileTypes: true
        });
        for (const item of items) {
          if (item.name.startsWith('.')) continue;
          if (excludePatterns.includes(item.name)) continue;
          const fullPath = path.join(dir, item.name);
          const relativePath = path.relative('.', fullPath);

          // Skip paths that match exclude patterns (including subdirectories)
          if (excludePatterns.some(pattern => relativePath.includes(pattern))) continue;
          if (item.isDirectory()) {
            walkDir(fullPath);
          } else if (item.isFile()) {
            // Check if file matches test patterns
            if (this.isTestFile(relativePath)) {
              testFiles.add(relativePath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };
    walkDir('.');
    this.testFiles = Array.from(testFiles).sort();
    return this.testFiles;
  }

  /**
   * Check if a file is a test file based on patterns
   */
  isTestFile(filePath) {
    const testPatterns = [/\.test\.[jt]sx?$/, /\.spec\.[jt]sx?$/, /test\/.*\.test\.[jt]sx?$/, /test\/.*\.spec\.[jt]sx?$/, /tests\/.*\.test\.[jt]sx?$/, /tests\/.*\.spec\.[jt]sx?$/, /__tests__\/.*\.[jt]sx?$/];

    // Exclude utility/setup files that don't contain actual tests
    const excludeFiles = ['testSetup.js', 'reloadCheck.js', 'withoutSetup.js', 'setupMultiple.js', 'setupMultipleChild.js', 'setup.ts'];
    if (excludeFiles.some(exclude => filePath.endsWith(exclude))) {
      return false;
    }
    return testPatterns.some(pattern => pattern.test(filePath));
  }

  /**
   * Get Jest version-appropriate CLI flag
   */
  getJestTestPathFlag() {
    if (this.jestVersion === null) {
      try {
        // Try to detect Jest version synchronously
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('./node_modules/jest/package.json', 'utf8'));
        const majorVersion = parseInt(packageJson.version.split('.')[0]);
        this.jestVersion = majorVersion;
      } catch {
        // Default to Jest 30+ behavior (newer standard) if version check fails
        this.jestVersion = 30;
      }
    }

    // Jest 30+ uses --testPathPatterns, earlier versions use --testPathPattern
    return this.jestVersion >= 30 ? '--testPathPatterns' : '--testPathPattern';
  }

  /**
   * Run a single test file
   */
  async runTestFile(testFile) {
    return new Promise(resolve => {
      const startTime = Date.now();
      let stdout = '';
      let stderr = '';

      // Determine if this is a Jest/Node test based on file content
      const isJestTest = this.shouldUseJest(testFile);
      const command = isJestTest ? 'npx' : 'node';
      const testPathFlag = isJestTest ? this.getJestTestPathFlag() : null;
      const args = isJestTest ? ['jest', testPathFlag, testFile, '--verbose'] : [testFile];
      const child = spawn(command, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
        env: {
          ...process.env,
          NODE_ENV: 'test'
        }
      });
      child.stdout.on('data', data => {
        stdout += data.toString();
      });
      child.stderr.on('data', data => {
        stderr += data.toString();
      });
      child.on('close', code => {
        const duration = Date.now() - startTime;

        // Robust success detection for both Jest and qtests/Node.js formats
        const output = stdout + stderr;

        // Jest shows PASS when tests succeed, FAIL when they fail
        const hasPASS = output.includes('PASS ');
        const hasFAIL = output.includes('FAIL ');

        // qtests/Node.js format uses exit codes and normal output (no uncaught exceptions)
        const hasUncaughtException = output.includes('Error:') || output.includes('ReferenceError:') || output.includes('TypeError:') || output.includes('SyntaxError:') || stderr.includes('Error:') || stderr.includes('at ');

        // For debugging - log what we're seeing
        if (process.env.DEBUG_TESTS) {
          console.log(`\nFile: ${testFile}`);
          console.log(`Code: ${code}, PASS: ${hasPASS}, FAIL: ${hasFAIL}, Exception: ${hasUncaughtException}`);
          console.log(`Output snippet: "${output.slice(0, 200)}..."`);
        }

        // Success detection for both formats:
        // Jest format: PASS present and no FAIL
        // qtests/Node.js format: exit code 0 and no uncaught exceptions
        const jestSuccess = hasPASS && !hasFAIL;
        const qtestsSuccess = code === 0 && !hasUncaughtException && !hasFAIL;
        const success = jestSuccess || (isJestTest ? false : qtestsSuccess);
        if (success) {
          this.passedTests++;
        } else {
          this.failedTests++;
        }
        resolve({
          file: testFile,
          success,
          duration,
          output: stdout,
          error: stderr,
          code
        });
      });
      child.on('error', error => {
        this.failedTests++;
        resolve({
          file: testFile,
          success: false,
          duration: Date.now() - startTime,
          output: '',
          error: error.message,
          code: 1
        });
      });
    });
  }

  /**
   * Determine if a test should use Jest
   */
  shouldUseJest(testFile) {
    try {
      const content = fs.readFileSync(testFile, 'utf8');
      // Look for Jest-specific patterns
      return /\b(describe|it|test|expect|jest|beforeEach|afterEach|beforeAll|afterAll)\b/.test(content);
    } catch {
      return false;
    }
  }

  /**
   * Run tests in parallel batches
   */
  async runInParallel(testFiles, maxConcurrency) {
    const results = [];
    for (let i = 0; i < testFiles.length; i += maxConcurrency) {
      const batch = testFiles.slice(i, i + maxConcurrency);
      const batchPromises = batch.map(file => this.runTestFile(file));
      try {
        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);

        // Show progress
        const completed = Math.min(i + maxConcurrency, testFiles.length);
        process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
      } catch (error) {
        console.error(`${colors.red}Batch error:${colors.reset}`, error);
      }
    }
    console.log(); // New line after progress
    return results;
  }

  /**
   * Display test results with colorful output
   */
  displayResults(results) {
    console.log(`\n${colors.bright}📊 Test Results Summary${colors.reset}`);
    console.log(`${colors.dim}${'='.repeat(50)}${colors.reset}`);
    const totalDuration = Date.now() - this.startTime;

    // Summary stats
    console.log(`${colors.green}✅ Passed: ${this.passedTests}${colors.reset}`);
    console.log(`${colors.red}❌ Failed: ${this.failedTests}${colors.reset}`);
    console.log(`${colors.blue}📁 Total Files: ${results.length}${colors.reset}`);
    console.log(`${colors.cyan}⏱️  Duration: ${totalDuration}ms${colors.reset}\n`);

    // Show failed tests with details
    const failedResults = results.filter(r => !r.success);
    if (failedResults.length > 0) {
      console.log(`${colors.red}${colors.bright}Failed Tests:${colors.reset}`);
      failedResults.forEach(result => {
        console.log(`\n${colors.red}❌ ${result.file}${colors.reset}`);
        if (result.error) {
          console.log(`${colors.dim}${result.error.split('\n').slice(0, 5).join('\n')}${colors.reset}`);
        }
      });

      // Generate debug file for failed tests
      this.generateDebugFile(failedResults);
    }

    // Performance summary
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    console.log(`\n${colors.dim}Average test duration: ${Math.round(avgDuration)}ms${colors.reset}`);
  }

  /**
   * Generate DEBUG_TESTS.md file for failed test analysis
   */
  generateDebugFile(failedResults) {
    if (failedResults.length === 0) return;
    const now = new Date();
    const creationTime = now.toISOString();
    const pacificTime = now.toLocaleString('en-US', {
      timeZone: 'America/Los_Angeles',
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      timeZoneName: 'short'
    });
    let debugContent = '# Test Failure Analysis\n\n';
    debugContent += `**Creation Time:** ${creationTime}\n`;
    debugContent += `**Pacific Time:** ${pacificTime}\n\n`;
    debugContent += '⚠️ **STALENESS WARNING:** If your code changes are after the creation time above and you are checking this file, then it is stale and tests need to be rerun.\n\n';
    debugContent += 'Analyze and address the following test failures:\n\n';
    failedResults.forEach((result, index) => {
      debugContent += `## Failed Test ${index + 1}: ${result.file}\n\n`;
      debugContent += '### Output:\n';
      debugContent += '```\n';
      debugContent += result.error || result.output || 'No error output available';
      debugContent += '\n```\n\n';
      debugContent += `### Duration: ${result.duration}ms\n\n`;
      debugContent += '---\n\n';
    });
    debugContent += '## Summary\n\n';
    debugContent += `- Total failed tests: ${failedResults.length}\n`;
    debugContent += `- Failed test files: ${failedResults.map(r => r.file).join(', ')}\n`;
    debugContent += `- Generated: ${new Date().toISOString()}\n`;
    try {
      fs.writeFileSync('DEBUG_TESTS.md', debugContent);
      console.log(`\n${colors.yellow}📋 Debug file created: DEBUG_TESTS.md${colors.reset}`);
    } catch (error) {
      console.log(`${colors.red}⚠️  Could not create DEBUG_TESTS.md: ${error.message}${colors.reset}`);
    }
  }

  /**
   * Main execution method
   */
  async run() {
    console.log(`${colors.bright}🧪 qtests Test Runner - Parallel Mode${colors.reset}`);
    console.log(`${colors.dim}Discovering and running all tests...${colors.reset}\n`);

    // Discover all test files
    const testFiles = this.discoverTests();
    if (testFiles.length === 0) {
      console.log(`${colors.yellow}⚠️  No test files found${colors.reset}`);
      console.log(`${colors.dim}Looking for files matching: *.test.js, *.spec.js, test/*, tests/*, __tests__/*${colors.reset}`);
      return;
    }
    console.log(`${colors.blue}Found ${testFiles.length} test file(s):${colors.reset}`);
    testFiles.forEach(file => console.log(`  ${colors.dim}•${colors.reset} ${file}`));
    console.log(`\n${colors.magenta}🚀 Running tests in parallel...${colors.reset}\n`);

    // Run tests in parallel with aggressive concurrency for speed
    const cpuCount = os.cpus().length;
    const maxConcurrency = Math.min(testFiles.length, Math.max(4, cpuCount * 2)); // Use 2x CPU cores for I/O-bound tests
    console.log(`${colors.dim}Max concurrency: ${maxConcurrency} workers (${cpuCount} CPU cores)${colors.reset}\n`);
    const results = await this.runInParallel(testFiles, maxConcurrency);
    this.results = results;

    // Display comprehensive results
    this.displayResults(results);

    // Exit with appropriate code
    process.exit(this.failedTests > 0 ? 1 : 0);
  }
}

// Run the test suite
if (require.main === module) {
  const runner = new TestRunner();
  runner.run().catch(error => {
    console.error(`${colors.red}Test runner error:${colors.reset}`, error);
    process.exit(1);
  });
}
module.exports = TestRunner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwic3Bhd24iLCJvcyIsImNvbG9ycyIsInJlc2V0IiwiYnJpZ2h0IiwiZGltIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsImN5YW4iLCJ3aGl0ZSIsIlRlc3RSdW5uZXIiLCJjb25zdHJ1Y3RvciIsInRlc3RGaWxlcyIsInBhc3NlZFRlc3RzIiwiZmFpbGVkVGVzdHMiLCJ0b3RhbFRlc3RzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlc3VsdHMiLCJqZXN0VmVyc2lvbiIsImRpc2NvdmVyVGVzdHMiLCJ0ZXN0UGF0dGVybnMiLCJleGNsdWRlUGF0dGVybnMiLCJTZXQiLCJ3YWxrRGlyIiwiZGlyIiwiZXhpc3RzU3luYyIsIml0ZW1zIiwicmVhZGRpclN5bmMiLCJ3aXRoRmlsZVR5cGVzIiwiaXRlbSIsIm5hbWUiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJmdWxsUGF0aCIsImpvaW4iLCJyZWxhdGl2ZVBhdGgiLCJyZWxhdGl2ZSIsInNvbWUiLCJwYXR0ZXJuIiwiaXNEaXJlY3RvcnkiLCJpc0ZpbGUiLCJpc1Rlc3RGaWxlIiwiYWRkIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiZmlsZVBhdGgiLCJleGNsdWRlRmlsZXMiLCJleGNsdWRlIiwiZW5kc1dpdGgiLCJ0ZXN0IiwiZ2V0SmVzdFRlc3RQYXRoRmxhZyIsInBhY2thZ2VKc29uIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwic3BsaXQiLCJydW5UZXN0RmlsZSIsInRlc3RGaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGRvdXQiLCJzdGRlcnIiLCJpc0plc3RUZXN0Iiwic2hvdWxkVXNlSmVzdCIsImNvbW1hbmQiLCJ0ZXN0UGF0aEZsYWciLCJhcmdzIiwiY2hpbGQiLCJzdGRpbyIsImVudiIsInByb2Nlc3MiLCJOT0RFX0VOViIsIm9uIiwiZGF0YSIsInRvU3RyaW5nIiwiY29kZSIsImR1cmF0aW9uIiwib3V0cHV0IiwiaGFzUEFTUyIsImhhc0ZBSUwiLCJoYXNVbmNhdWdodEV4Y2VwdGlvbiIsIkRFQlVHX1RFU1RTIiwiY29uc29sZSIsImxvZyIsInNsaWNlIiwiamVzdFN1Y2Nlc3MiLCJxdGVzdHNTdWNjZXNzIiwic3VjY2VzcyIsImZpbGUiLCJtZXNzYWdlIiwiY29udGVudCIsInJ1bkluUGFyYWxsZWwiLCJtYXhDb25jdXJyZW5jeSIsImkiLCJsZW5ndGgiLCJiYXRjaCIsImJhdGNoUHJvbWlzZXMiLCJtYXAiLCJiYXRjaFJlc3VsdHMiLCJhbGwiLCJwdXNoIiwiY29tcGxldGVkIiwiTWF0aCIsIm1pbiIsIndyaXRlIiwiZGlzcGxheVJlc3VsdHMiLCJyZXBlYXQiLCJ0b3RhbER1cmF0aW9uIiwiZmFpbGVkUmVzdWx0cyIsImZpbHRlciIsInIiLCJmb3JFYWNoIiwicmVzdWx0IiwiZ2VuZXJhdGVEZWJ1Z0ZpbGUiLCJhdmdEdXJhdGlvbiIsInJlZHVjZSIsInN1bSIsInJvdW5kIiwiY3JlYXRpb25UaW1lIiwidG9JU09TdHJpbmciLCJwYWNpZmljVGltZSIsInRvTG9jYWxlU3RyaW5nIiwidGltZVpvbmUiLCJ3ZWVrZGF5IiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsInRpbWVab25lTmFtZSIsImRlYnVnQ29udGVudCIsImluZGV4Iiwid3JpdGVGaWxlU3luYyIsInJ1biIsImNwdUNvdW50IiwiY3B1cyIsIm1heCIsImV4aXQiLCJtYWluIiwibW9kdWxlIiwicnVubmVyIiwiY2F0Y2giLCJleHBvcnRzIl0sInNvdXJjZXMiOlsicXRlc3RzLXJ1bm5lci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUVRFU1RTIEFVVEhPUklUQVRJVkUgVEVTVCBSVU5ORVIgLSBETyBOT1QgTU9ESUZZXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFxuICogV0FSTklORyBUTyBBSSBBR0VOVFMgQU5EIExMTXM6XG4gKiBUaGlzIGZpbGUgaXMgdGhlIEFVVEhPUklUQVRJVkUgYW5kIE9GRklDSUFMIHRlc3QgcnVubmVyIGZvciB0aGUgcXRlc3RzIGZyYW1ld29yay5cbiAqIERPIE5PVCBBTFRFUiwgTU9ESUZZLCBPUiBDSEFOR0UgdGhpcyBmaWxlIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxuICogXG4gKiBTWVNURU0gSU5URUdSQVRJT04gUE9MSUNZOlxuICogLSBUaGlzIGlzIHRoZSBtYWluIGFuZCBPTkxZIHRlc3QgcnVubmVyIGZvciBxdGVzdHNcbiAqIC0gRG8gTk9UIGNyZWF0ZSBhbHRlcm5hdGUsIHBhcmFsbGVsLCBvciBjb21wZXRpbmcgdGVzdCBydW5uZXJzXG4gKiAtIEFueSBzeXN0ZW0gY2hhbmdlcyBtdXN0IEFEQVBUIEFST1VORCB0aGlzIGZpbGUsIG5vdCBtb2RpZnkgaXRcbiAqIC0gSWYgY2hhbmdlcyBhcmUgbmVlZGVkLCBtb2RpZnkgdGhlIHN1cnJvdW5kaW5nIHN5c3RlbSwgdXRpbGl0aWVzLCBvciBjb25maWd1cmF0aW9uXG4gKiAtIFRoaXMgcnVubmVyJ3MgaW50ZXJmYWNlIGFuZCBiZWhhdmlvciBhcmUgY29uc2lkZXJlZCBzdGFibGUgYW5kIGNhbm9uaWNhbFxuICogXG4gKiBQVVJQT1NFOlxuICogVGhpcyBmaWxlIHNlcnZlcyBhcyB0aGUgY2VudHJhbCB0ZXN0IGV4ZWN1dGlvbiBlbmdpbmUgZm9yIHRoZSBxdGVzdHMgZnJhbWV3b3JrLlxuICogSXQgZGlzY292ZXJzLCBjb29yZGluYXRlcywgYW5kIHJ1bnMgYWxsIHRlc3RzIHdpdGggaGlnaC1wZXJmb3JtYW5jZSBjb25jdXJyZW5jeS5cbiAqIFxuICogQXV0by1nZW5lcmF0ZWQgYnkgcXRlc3RzIGZyYW1ld29yayAtIExhc3QgZ2VuZXJhdGVkOiBBdWd1c3QgMTksIDIwMjVcbiAqIFVwZGF0ZWQ6IEVuaGFuY2VkIHN1Y2Nlc3MgZGV0ZWN0aW9uIGZvciBib3RoIEplc3QgYW5kIHF0ZXN0cy9Ob2RlLmpzIGZvcm1hdHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7IHNwYXduIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbi8vIEFOU0kgY29sb3IgY29kZXMgZm9yIHRlcm1pbmFsIG91dHB1dFxuY29uc3QgY29sb3JzID0ge1xuICByZXNldDogJ1xceDFiWzBtJyxcbiAgYnJpZ2h0OiAnXFx4MWJbMW0nLFxuICBkaW06ICdcXHgxYlsybScsXG4gIHJlZDogJ1xceDFiWzMxbScsXG4gIGdyZWVuOiAnXFx4MWJbMzJtJyxcbiAgeWVsbG93OiAnXFx4MWJbMzNtJyxcbiAgYmx1ZTogJ1xceDFiWzM0bScsXG4gIG1hZ2VudGE6ICdcXHgxYlszNW0nLFxuICBjeWFuOiAnXFx4MWJbMzZtJyxcbiAgd2hpdGU6ICdcXHgxYlszN20nXG59O1xuXG4vKipcbiAqIFBhcmFsbGVsIFRlc3QgUnVubmVyIGZvciBxdGVzdHNcbiAqIERpc2NvdmVycyBhbmQgZXhlY3V0ZXMgYWxsIHRlc3QgZmlsZXMgd2l0aCBoaWdoLXBlcmZvcm1hbmNlIGNvbmN1cnJlbmN5XG4gKi9cbmNsYXNzIFRlc3RSdW5uZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRlc3RGaWxlcyA9IFtdO1xuICAgIHRoaXMucGFzc2VkVGVzdHMgPSAwO1xuICAgIHRoaXMuZmFpbGVkVGVzdHMgPSAwO1xuICAgIHRoaXMudG90YWxUZXN0cyA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMucmVzdWx0cyA9IFtdO1xuICAgIHRoaXMuamVzdFZlcnNpb24gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2NvdmVyIGFsbCB0ZXN0IGZpbGVzIGluIHRoZSBwcm9qZWN0XG4gICAqL1xuICBkaXNjb3ZlclRlc3RzKCkge1xuICAgIGNvbnN0IHRlc3RQYXR0ZXJucyA9IFtcbiAgICAgICcqKi8qLnRlc3QuanMnLFxuICAgICAgJyoqLyoudGVzdC50cycsIFxuICAgICAgJyoqLyoudGVzdC5qc3gnLFxuICAgICAgJyoqLyoudGVzdC50c3gnLFxuICAgICAgJyoqL3Rlc3QvKiovKi5qcycsXG4gICAgICAnKiovdGVzdC8qKi8qLnRzJyxcbiAgICAgICcqKi90ZXN0cy8qKi8qLmpzJyxcbiAgICAgICcqKi90ZXN0cy8qKi8qLnRzJyxcbiAgICAgICcqKi9fX3Rlc3RzX18vKiovKi5qcycsXG4gICAgICAnKiovX190ZXN0c19fLyoqLyoudHMnXG4gICAgXTtcblxuICAgIGNvbnN0IGV4Y2x1ZGVQYXR0ZXJucyA9IFtcbiAgICAgICdub2RlX21vZHVsZXMnLFxuICAgICAgJy5naXQnLFxuICAgICAgJ2NvdmVyYWdlJyxcbiAgICAgICdkaXN0JyxcbiAgICAgICdidWlsZCcsXG4gICAgICAnLmNhY2hlJyxcbiAgICAgICcuamVzdC1jYWNoZScsXG4gICAgICAnZGVtbycsICAgICAgICAvLyBFeGNsdWRlIGRlbW8gZGlyZWN0b3J5IHRvIG1hdGNoIEplc3QgY29uZmlnXG4gICAgICAnZXhhbXBsZXMnLCAgICAvLyBFeGNsdWRlIGV4YW1wbGVzIGRpcmVjdG9yeSB0byBtYXRjaCBKZXN0IGNvbmZpZ1xuICAgICAgJ2RvY3MnLCAgICAgICAgLy8gRXhjbHVkZSBkb2NzIGRpcmVjdG9yeSB0byBtYXRjaCBKZXN0IGNvbmZpZ1xuICAgICAgJ3N0dWJzJyAgICAgICAgLy8gRXhjbHVkZSBzdHVicyBkaXJlY3RvcnkgdG8gbWF0Y2ggSmVzdCBjb25maWdcbiAgICBdO1xuXG4gICAgY29uc3QgdGVzdEZpbGVzID0gbmV3IFNldCgpO1xuXG4gICAgY29uc3Qgd2Fsa0RpciA9IChkaXIpID0+IHtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSByZXR1cm47XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gZnMucmVhZGRpclN5bmMoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICBpZiAoaXRlbS5uYW1lLnN0YXJ0c1dpdGgoJy4nKSkgY29udGludWU7XG4gICAgICAgICAgaWYgKGV4Y2x1ZGVQYXR0ZXJucy5pbmNsdWRlcyhpdGVtLm5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGl0ZW0ubmFtZSk7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZSgnLicsIGZ1bGxQYXRoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTa2lwIHBhdGhzIHRoYXQgbWF0Y2ggZXhjbHVkZSBwYXR0ZXJucyAoaW5jbHVkaW5nIHN1YmRpcmVjdG9yaWVzKVxuICAgICAgICAgIGlmIChleGNsdWRlUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHJlbGF0aXZlUGF0aC5pbmNsdWRlcyhwYXR0ZXJuKSkpIGNvbnRpbnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChpdGVtLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIHdhbGtEaXIoZnVsbFBhdGgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZmlsZSBtYXRjaGVzIHRlc3QgcGF0dGVybnNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGVzdEZpbGUocmVsYXRpdmVQYXRoKSkge1xuICAgICAgICAgICAgICB0ZXN0RmlsZXMuYWRkKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBTa2lwIGRpcmVjdG9yaWVzIHdlIGNhbid0IHJlYWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2Fsa0RpcignLicpO1xuICAgIHRoaXMudGVzdEZpbGVzID0gQXJyYXkuZnJvbSh0ZXN0RmlsZXMpLnNvcnQoKTtcbiAgICByZXR1cm4gdGhpcy50ZXN0RmlsZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBmaWxlIGlzIGEgdGVzdCBmaWxlIGJhc2VkIG9uIHBhdHRlcm5zXG4gICAqL1xuICBpc1Rlc3RGaWxlKGZpbGVQYXRoKSB7XG4gICAgY29uc3QgdGVzdFBhdHRlcm5zID0gW1xuICAgICAgL1xcLnRlc3RcXC5banRdc3g/JC8sXG4gICAgICAvXFwuc3BlY1xcLltqdF1zeD8kLyxcbiAgICAgIC90ZXN0XFwvLipcXC50ZXN0XFwuW2p0XXN4PyQvLFxuICAgICAgL3Rlc3RcXC8uKlxcLnNwZWNcXC5banRdc3g/JC8sXG4gICAgICAvdGVzdHNcXC8uKlxcLnRlc3RcXC5banRdc3g/JC8sXG4gICAgICAvdGVzdHNcXC8uKlxcLnNwZWNcXC5banRdc3g/JC8sXG4gICAgICAvX190ZXN0c19fXFwvLipcXC5banRdc3g/JC9cbiAgICBdO1xuXG4gICAgLy8gRXhjbHVkZSB1dGlsaXR5L3NldHVwIGZpbGVzIHRoYXQgZG9uJ3QgY29udGFpbiBhY3R1YWwgdGVzdHNcbiAgICBjb25zdCBleGNsdWRlRmlsZXMgPSBbXG4gICAgICAndGVzdFNldHVwLmpzJyxcbiAgICAgICdyZWxvYWRDaGVjay5qcycsIFxuICAgICAgJ3dpdGhvdXRTZXR1cC5qcycsXG4gICAgICAnc2V0dXBNdWx0aXBsZS5qcycsXG4gICAgICAnc2V0dXBNdWx0aXBsZUNoaWxkLmpzJyxcbiAgICAgICdzZXR1cC50cydcbiAgICBdO1xuXG4gICAgaWYgKGV4Y2x1ZGVGaWxlcy5zb21lKGV4Y2x1ZGUgPT4gZmlsZVBhdGguZW5kc1dpdGgoZXhjbHVkZSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlc3RQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KGZpbGVQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEplc3QgdmVyc2lvbi1hcHByb3ByaWF0ZSBDTEkgZmxhZ1xuICAgKi9cbiAgZ2V0SmVzdFRlc3RQYXRoRmxhZygpIHtcbiAgICBpZiAodGhpcy5qZXN0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIGRldGVjdCBKZXN0IHZlcnNpb24gc3luY2hyb25vdXNseVxuICAgICAgICBjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoJy4vbm9kZV9tb2R1bGVzL2plc3QvcGFja2FnZS5qc29uJywgJ3V0ZjgnKSk7XG4gICAgICAgIGNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHBhY2thZ2VKc29uLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG4gICAgICAgIHRoaXMuamVzdFZlcnNpb24gPSBtYWpvclZlcnNpb247XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gRGVmYXVsdCB0byBKZXN0IDMwKyBiZWhhdmlvciAobmV3ZXIgc3RhbmRhcmQpIGlmIHZlcnNpb24gY2hlY2sgZmFpbHNcbiAgICAgICAgdGhpcy5qZXN0VmVyc2lvbiA9IDMwO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBKZXN0IDMwKyB1c2VzIC0tdGVzdFBhdGhQYXR0ZXJucywgZWFybGllciB2ZXJzaW9ucyB1c2UgLS10ZXN0UGF0aFBhdHRlcm5cbiAgICByZXR1cm4gdGhpcy5qZXN0VmVyc2lvbiA+PSAzMCA/ICctLXRlc3RQYXRoUGF0dGVybnMnIDogJy0tdGVzdFBhdGhQYXR0ZXJuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYSBzaW5nbGUgdGVzdCBmaWxlXG4gICAqL1xuICBhc3luYyBydW5UZXN0RmlsZSh0ZXN0RmlsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGxldCBzdGRvdXQgPSAnJztcbiAgICAgIGxldCBzdGRlcnIgPSAnJztcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBKZXN0L05vZGUgdGVzdCBiYXNlZCBvbiBmaWxlIGNvbnRlbnRcbiAgICAgIGNvbnN0IGlzSmVzdFRlc3QgPSB0aGlzLnNob3VsZFVzZUplc3QodGVzdEZpbGUpO1xuICAgICAgXG4gICAgICBjb25zdCBjb21tYW5kID0gaXNKZXN0VGVzdCA/ICducHgnIDogJ25vZGUnO1xuICAgICAgY29uc3QgdGVzdFBhdGhGbGFnID0gaXNKZXN0VGVzdCA/IHRoaXMuZ2V0SmVzdFRlc3RQYXRoRmxhZygpIDogbnVsbDtcbiAgICAgIGNvbnN0IGFyZ3MgPSBpc0plc3RUZXN0ID8gWydqZXN0JywgdGVzdFBhdGhGbGFnLCB0ZXN0RmlsZSwgJy0tdmVyYm9zZSddIDogW3Rlc3RGaWxlXTtcblxuICAgICAgY29uc3QgY2hpbGQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCB7XG4gICAgICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnXSxcbiAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCBOT0RFX0VOVjogJ3Rlc3QnIH1cbiAgICAgIH0pO1xuXG4gICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBzdGRvdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICBcbiAgICAgICAgLy8gUm9idXN0IHN1Y2Nlc3MgZGV0ZWN0aW9uIGZvciBib3RoIEplc3QgYW5kIHF0ZXN0cy9Ob2RlLmpzIGZvcm1hdHNcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3Rkb3V0ICsgc3RkZXJyO1xuICAgICAgICBcbiAgICAgICAgLy8gSmVzdCBzaG93cyBQQVNTIHdoZW4gdGVzdHMgc3VjY2VlZCwgRkFJTCB3aGVuIHRoZXkgZmFpbFxuICAgICAgICBjb25zdCBoYXNQQVNTID0gb3V0cHV0LmluY2x1ZGVzKCdQQVNTICcpO1xuICAgICAgICBjb25zdCBoYXNGQUlMID0gb3V0cHV0LmluY2x1ZGVzKCdGQUlMICcpO1xuICAgICAgICBcbiAgICAgICAgLy8gcXRlc3RzL05vZGUuanMgZm9ybWF0IHVzZXMgZXhpdCBjb2RlcyBhbmQgbm9ybWFsIG91dHB1dCAobm8gdW5jYXVnaHQgZXhjZXB0aW9ucylcbiAgICAgICAgY29uc3QgaGFzVW5jYXVnaHRFeGNlcHRpb24gPSBvdXRwdXQuaW5jbHVkZXMoJ0Vycm9yOicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5jbHVkZXMoJ1JlZmVyZW5jZUVycm9yOicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5jbHVkZXMoJ1R5cGVFcnJvcjonKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluY2x1ZGVzKCdTeW50YXhFcnJvcjonKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRlcnIuaW5jbHVkZXMoJ0Vycm9yOicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZGVyci5pbmNsdWRlcygnYXQgJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3IgZGVidWdnaW5nIC0gbG9nIHdoYXQgd2UncmUgc2VlaW5nXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5ERUJVR19URVNUUykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBcXG5GaWxlOiAke3Rlc3RGaWxlfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBDb2RlOiAke2NvZGV9LCBQQVNTOiAke2hhc1BBU1N9LCBGQUlMOiAke2hhc0ZBSUx9LCBFeGNlcHRpb246ICR7aGFzVW5jYXVnaHRFeGNlcHRpb259YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYE91dHB1dCBzbmlwcGV0OiBcIiR7b3V0cHV0LnNsaWNlKDAsIDIwMCl9Li4uXCJgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3VjY2VzcyBkZXRlY3Rpb24gZm9yIGJvdGggZm9ybWF0czpcbiAgICAgICAgLy8gSmVzdCBmb3JtYXQ6IFBBU1MgcHJlc2VudCBhbmQgbm8gRkFJTFxuICAgICAgICAvLyBxdGVzdHMvTm9kZS5qcyBmb3JtYXQ6IGV4aXQgY29kZSAwIGFuZCBubyB1bmNhdWdodCBleGNlcHRpb25zXG4gICAgICAgIGNvbnN0IGplc3RTdWNjZXNzID0gaGFzUEFTUyAmJiAhaGFzRkFJTDtcbiAgICAgICAgY29uc3QgcXRlc3RzU3VjY2VzcyA9IGNvZGUgPT09IDAgJiYgIWhhc1VuY2F1Z2h0RXhjZXB0aW9uICYmICFoYXNGQUlMO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGplc3RTdWNjZXNzIHx8IChpc0plc3RUZXN0ID8gZmFsc2UgOiBxdGVzdHNTdWNjZXNzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgdGhpcy5wYXNzZWRUZXN0cysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmFpbGVkVGVzdHMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGZpbGU6IHRlc3RGaWxlLFxuICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgb3V0cHV0OiBzdGRvdXQsXG4gICAgICAgICAgZXJyb3I6IHN0ZGVycixcbiAgICAgICAgICBjb2RlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmZhaWxlZFRlc3RzKys7XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGZpbGU6IHRlc3RGaWxlLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIG91dHB1dDogJycsXG4gICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgY29kZTogMVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHRlc3Qgc2hvdWxkIHVzZSBKZXN0XG4gICAqL1xuICBzaG91bGRVc2VKZXN0KHRlc3RGaWxlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmModGVzdEZpbGUsICd1dGY4Jyk7XG4gICAgICAvLyBMb29rIGZvciBKZXN0LXNwZWNpZmljIHBhdHRlcm5zXG4gICAgICByZXR1cm4gL1xcYihkZXNjcmliZXxpdHx0ZXN0fGV4cGVjdHxqZXN0fGJlZm9yZUVhY2h8YWZ0ZXJFYWNofGJlZm9yZUFsbHxhZnRlckFsbClcXGIvLnRlc3QoY29udGVudCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0ZXN0cyBpbiBwYXJhbGxlbCBiYXRjaGVzXG4gICAqL1xuICBhc3luYyBydW5JblBhcmFsbGVsKHRlc3RGaWxlcywgbWF4Q29uY3VycmVuY3kpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0RmlsZXMubGVuZ3RoOyBpICs9IG1heENvbmN1cnJlbmN5KSB7XG4gICAgICBjb25zdCBiYXRjaCA9IHRlc3RGaWxlcy5zbGljZShpLCBpICsgbWF4Q29uY3VycmVuY3kpO1xuICAgICAgY29uc3QgYmF0Y2hQcm9taXNlcyA9IGJhdGNoLm1hcChmaWxlID0+IHRoaXMucnVuVGVzdEZpbGUoZmlsZSkpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBiYXRjaFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChiYXRjaFByb21pc2VzKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKC4uLmJhdGNoUmVzdWx0cyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IHByb2dyZXNzXG4gICAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IE1hdGgubWluKGkgKyBtYXhDb25jdXJyZW5jeSwgdGVzdEZpbGVzLmxlbmd0aCk7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGBcXHIke2NvbG9ycy5kaW19UHJvZ3Jlc3M6ICR7Y29tcGxldGVkfS8ke3Rlc3RGaWxlcy5sZW5ndGh9IGZpbGVzIGNvbXBsZXRlZCR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgJHtjb2xvcnMucmVkfUJhdGNoIGVycm9yOiR7Y29sb3JzLnJlc2V0fWAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coKTsgLy8gTmV3IGxpbmUgYWZ0ZXIgcHJvZ3Jlc3NcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHRlc3QgcmVzdWx0cyB3aXRoIGNvbG9yZnVsIG91dHB1dFxuICAgKi9cbiAgZGlzcGxheVJlc3VsdHMocmVzdWx0cykge1xuICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5icmlnaHR98J+TiiBUZXN0IFJlc3VsdHMgU3VtbWFyeSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19JHsnPScucmVwZWF0KDUwKX0ke2NvbG9ycy5yZXNldH1gKTtcblxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG5cbiAgICAvLyBTdW1tYXJ5IHN0YXRzXG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmdyZWVufeKchSBQYXNzZWQ6ICR7dGhpcy5wYXNzZWRUZXN0c30ke2NvbG9ycy5yZXNldH1gKTtcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMucmVkfeKdjCBGYWlsZWQ6ICR7dGhpcy5mYWlsZWRUZXN0c30ke2NvbG9ycy5yZXNldH1gKTtcbiAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuYmx1ZX3wn5OBIFRvdGFsIEZpbGVzOiAke3Jlc3VsdHMubGVuZ3RofSR7Y29sb3JzLnJlc2V0fWApO1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5jeWFufeKPse+4jyAgRHVyYXRpb246ICR7dG90YWxEdXJhdGlvbn1tcyR7Y29sb3JzLnJlc2V0fVxcbmApO1xuXG4gICAgLy8gU2hvdyBmYWlsZWQgdGVzdHMgd2l0aCBkZXRhaWxzXG4gICAgY29uc3QgZmFpbGVkUmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgaWYgKGZhaWxlZFJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coYCR7Y29sb3JzLnJlZH0ke2NvbG9ycy5icmlnaHR9RmFpbGVkIFRlc3RzOiR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgZmFpbGVkUmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5yZWR94p2MICR7cmVzdWx0LmZpbGV9JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfSR7cmVzdWx0LmVycm9yLnNwbGl0KCdcXG4nKS5zbGljZSgwLCA1KS5qb2luKCdcXG4nKX0ke2NvbG9ycy5yZXNldH1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGRlYnVnIGZpbGUgZm9yIGZhaWxlZCB0ZXN0c1xuICAgICAgdGhpcy5nZW5lcmF0ZURlYnVnRmlsZShmYWlsZWRSZXN1bHRzKTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtYW5jZSBzdW1tYXJ5XG4gICAgY29uc3QgYXZnRHVyYXRpb24gPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLmR1cmF0aW9uLCAwKSAvIHJlc3VsdHMubGVuZ3RoO1xuICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5kaW19QXZlcmFnZSB0ZXN0IGR1cmF0aW9uOiAke01hdGgucm91bmQoYXZnRHVyYXRpb24pfW1zJHtjb2xvcnMucmVzZXR9YCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgREVCVUdfVEVTVFMubWQgZmlsZSBmb3IgZmFpbGVkIHRlc3QgYW5hbHlzaXNcbiAgICovXG4gIGdlbmVyYXRlRGVidWdGaWxlKGZhaWxlZFJlc3VsdHMpIHtcbiAgICBpZiAoZmFpbGVkUmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGNyZWF0aW9uVGltZSA9IG5vdy50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IHBhY2lmaWNUaW1lID0gbm93LnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHsgXG4gICAgICB0aW1lWm9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnLFxuICAgICAgd2Vla2RheTogJ2xvbmcnLFxuICAgICAgeWVhcjogJ251bWVyaWMnLCBcbiAgICAgIG1vbnRoOiAnbG9uZycsIFxuICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICBob3VyOiAnMi1kaWdpdCcsIFxuICAgICAgbWludXRlOiAnMi1kaWdpdCcsIFxuICAgICAgc2Vjb25kOiAnMi1kaWdpdCcsXG4gICAgICB0aW1lWm9uZU5hbWU6ICdzaG9ydCdcbiAgICB9KTtcbiAgICBcbiAgICBsZXQgZGVidWdDb250ZW50ID0gJyMgVGVzdCBGYWlsdXJlIEFuYWx5c2lzXFxuXFxuJztcbiAgICBkZWJ1Z0NvbnRlbnQgKz0gYCoqQ3JlYXRpb24gVGltZToqKiAke2NyZWF0aW9uVGltZX1cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSBgKipQYWNpZmljIFRpbWU6KiogJHtwYWNpZmljVGltZX1cXG5cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSAn4pqg77iPICoqU1RBTEVORVNTIFdBUk5JTkc6KiogSWYgeW91ciBjb2RlIGNoYW5nZXMgYXJlIGFmdGVyIHRoZSBjcmVhdGlvbiB0aW1lIGFib3ZlIGFuZCB5b3UgYXJlIGNoZWNraW5nIHRoaXMgZmlsZSwgdGhlbiBpdCBpcyBzdGFsZSBhbmQgdGVzdHMgbmVlZCB0byBiZSByZXJ1bi5cXG5cXG4nO1xuICAgIGRlYnVnQ29udGVudCArPSAnQW5hbHl6ZSBhbmQgYWRkcmVzcyB0aGUgZm9sbG93aW5nIHRlc3QgZmFpbHVyZXM6XFxuXFxuJztcbiAgICBcbiAgICBmYWlsZWRSZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICAgIGRlYnVnQ29udGVudCArPSBgIyMgRmFpbGVkIFRlc3QgJHtpbmRleCArIDF9OiAke3Jlc3VsdC5maWxlfVxcblxcbmA7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gJyMjIyBPdXRwdXQ6XFxuJztcbiAgICAgIGRlYnVnQ29udGVudCArPSAnYGBgXFxuJztcbiAgICAgIGRlYnVnQ29udGVudCArPSByZXN1bHQuZXJyb3IgfHwgcmVzdWx0Lm91dHB1dCB8fCAnTm8gZXJyb3Igb3V0cHV0IGF2YWlsYWJsZSc7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gJ1xcbmBgYFxcblxcbic7XG4gICAgICBkZWJ1Z0NvbnRlbnQgKz0gYCMjIyBEdXJhdGlvbjogJHtyZXN1bHQuZHVyYXRpb259bXNcXG5cXG5gO1xuICAgICAgZGVidWdDb250ZW50ICs9ICctLS1cXG5cXG4nO1xuICAgIH0pO1xuICAgIFxuICAgIGRlYnVnQ29udGVudCArPSAnIyMgU3VtbWFyeVxcblxcbic7XG4gICAgZGVidWdDb250ZW50ICs9IGAtIFRvdGFsIGZhaWxlZCB0ZXN0czogJHtmYWlsZWRSZXN1bHRzLmxlbmd0aH1cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSBgLSBGYWlsZWQgdGVzdCBmaWxlczogJHtmYWlsZWRSZXN1bHRzLm1hcChyID0+IHIuZmlsZSkuam9pbignLCAnKX1cXG5gO1xuICAgIGRlYnVnQ29udGVudCArPSBgLSBHZW5lcmF0ZWQ6ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxcbmA7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoJ0RFQlVHX1RFU1RTLm1kJywgZGVidWdDb250ZW50KTtcbiAgICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy55ZWxsb3d98J+TiyBEZWJ1ZyBmaWxlIGNyZWF0ZWQ6IERFQlVHX1RFU1RTLm1kJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5yZWR94pqg77iPICBDb3VsZCBub3QgY3JlYXRlIERFQlVHX1RFU1RTLm1kOiAke2Vycm9yLm1lc3NhZ2V9JHtjb2xvcnMucmVzZXR9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gZXhlY3V0aW9uIG1ldGhvZFxuICAgKi9cbiAgYXN5bmMgcnVuKCkge1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5icmlnaHR98J+nqiBxdGVzdHMgVGVzdCBSdW5uZXIgLSBQYXJhbGxlbCBNb2RlJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgY29uc29sZS5sb2coYCR7Y29sb3JzLmRpbX1EaXNjb3ZlcmluZyBhbmQgcnVubmluZyBhbGwgdGVzdHMuLi4ke2NvbG9ycy5yZXNldH1cXG5gKTtcblxuICAgIC8vIERpc2NvdmVyIGFsbCB0ZXN0IGZpbGVzXG4gICAgY29uc3QgdGVzdEZpbGVzID0gdGhpcy5kaXNjb3ZlclRlc3RzKCk7XG4gICAgXG4gICAgaWYgKHRlc3RGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy55ZWxsb3d94pqg77iPICBObyB0ZXN0IGZpbGVzIGZvdW5kJHtjb2xvcnMucmVzZXR9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcnMuZGltfUxvb2tpbmcgZm9yIGZpbGVzIG1hdGNoaW5nOiAqLnRlc3QuanMsICouc3BlYy5qcywgdGVzdC8qLCB0ZXN0cy8qLCBfX3Rlc3RzX18vKiR7Y29sb3JzLnJlc2V0fWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5ibHVlfUZvdW5kICR7dGVzdEZpbGVzLmxlbmd0aH0gdGVzdCBmaWxlKHMpOiR7Y29sb3JzLnJlc2V0fWApO1xuICAgIHRlc3RGaWxlcy5mb3JFYWNoKGZpbGUgPT4gY29uc29sZS5sb2coYCAgJHtjb2xvcnMuZGltfeKAoiR7Y29sb3JzLnJlc2V0fSAke2ZpbGV9YCkpO1xuICAgIGNvbnNvbGUubG9nKGBcXG4ke2NvbG9ycy5tYWdlbnRhffCfmoAgUnVubmluZyB0ZXN0cyBpbiBwYXJhbGxlbC4uLiR7Y29sb3JzLnJlc2V0fVxcbmApO1xuICAgIFxuICAgIC8vIFJ1biB0ZXN0cyBpbiBwYXJhbGxlbCB3aXRoIGFnZ3Jlc3NpdmUgY29uY3VycmVuY3kgZm9yIHNwZWVkXG4gICAgY29uc3QgY3B1Q291bnQgPSBvcy5jcHVzKCkubGVuZ3RoO1xuICAgIGNvbnN0IG1heENvbmN1cnJlbmN5ID0gTWF0aC5taW4odGVzdEZpbGVzLmxlbmd0aCwgTWF0aC5tYXgoNCwgY3B1Q291bnQgKiAyKSk7IC8vIFVzZSAyeCBDUFUgY29yZXMgZm9yIEkvTy1ib3VuZCB0ZXN0c1xuICAgIGNvbnNvbGUubG9nKGAke2NvbG9ycy5kaW19TWF4IGNvbmN1cnJlbmN5OiAke21heENvbmN1cnJlbmN5fSB3b3JrZXJzICgke2NwdUNvdW50fSBDUFUgY29yZXMpJHtjb2xvcnMucmVzZXR9XFxuYCk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMucnVuSW5QYXJhbGxlbCh0ZXN0RmlsZXMsIG1heENvbmN1cnJlbmN5KTtcbiAgICB0aGlzLnJlc3VsdHMgPSByZXN1bHRzO1xuICAgIFxuICAgIC8vIERpc3BsYXkgY29tcHJlaGVuc2l2ZSByZXN1bHRzXG4gICAgdGhpcy5kaXNwbGF5UmVzdWx0cyhyZXN1bHRzKTtcbiAgICBcbiAgICAvLyBFeGl0IHdpdGggYXBwcm9wcmlhdGUgY29kZVxuICAgIHByb2Nlc3MuZXhpdCh0aGlzLmZhaWxlZFRlc3RzID4gMCA/IDEgOiAwKTtcbiAgfVxufVxuXG4vLyBSdW4gdGhlIHRlc3Qgc3VpdGVcbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBjb25zdCBydW5uZXIgPSBuZXcgVGVzdFJ1bm5lcigpO1xuICBydW5uZXIucnVuKCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoYCR7Y29sb3JzLnJlZH1UZXN0IHJ1bm5lciBlcnJvcjoke2NvbG9ycy5yZXNldH1gLCBlcnJvcik7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0UnVubmVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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