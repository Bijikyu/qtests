ff76e6ae4e2883fdc53183719f7f7f60
/**
 * Test Environment Management Utilities
 * 
 * Provides comprehensive environment variable management and mock creation
 * for complex testing scenarios. This module handles the common pattern of
 * setting up test environments with known values and cleaning up afterward.
 * 
 * Design philosophy:
 * - Environment isolation: tests shouldn't affect each other or the host environment
 * - Predictable test data: use known values for consistent test results
 * - Mock management: centralized creation and cleanup of test doubles
 * - Framework agnostic: works with or without Jest
 * 
 * Use cases:
 * - API testing with known API keys
 * - Testing code that depends on environment variables
 * - Complex test scenarios requiring multiple mocks
 * - Integration tests that need controlled environments
 */

// Import logging utilities including wrapper for consistent logs
const {
  logStart,
  logReturn,
  executeWithLogs,
  setLogging
} = require('../lib/logUtils'); //(import setLogging for optional disable)
if (process.env.NODE_ENV !== 'test') setLogging(false); //(mute logs outside tests)

const defaultEnv = {
  // (shared env defaults for tests)
  GOOGLE_API_KEY: 'key',
  // (fake google api key)
  GOOGLE_CX: 'cx',
  // (fake search cx)
  OPENAI_TOKEN: 'token' // (fake openai token)
};

/**
 * Sets up a standard test environment with common API keys
 * 
 * This function establishes a predictable environment for tests by setting
 * commonly used environment variables to known test values. This ensures
 * tests are deterministic and don't depend on the developer's local environment.
 * 
 * Why these specific variables:
 * - GOOGLE_API_KEY: Common in search and maps functionality
 * - GOOGLE_CX: Google Custom Search Engine ID
 * - OPENAI_TOKEN: AI/ML functionality testing
 * 
 * Values chosen:
 * - Simple strings that are obviously fake ('key', 'cx', 'token')
 * - Short to avoid log pollution
 * - Recognizable as test data
 * 
 * @returns {boolean} Always returns true to confirm environment was set
 */
function setTestEnv() {
  console.log(`setTestEnv is running with default values`); // logging function start per requirements

  try {
    // Apply default test environment variables using Object.assign for atomic operation
    // Object.assign chosen over individual assignments for performance and atomicity
    // All environment variables are set together to prevent partial states
    // Overwrites existing values to ensure predictable test environment regardless of host setup
    Object.assign(process.env, defaultEnv);
    console.log(`setTestEnv is returning true`); // logging return value per requirements
    return true;
  } catch (error) {
    // Log error context for debugging environment setup issues
    // Environment variable assignment rarely fails but can occur with read-only process.env
    // Error re-throwing maintains contract while providing diagnostic information
    console.log(`setTestEnv error: ${error.message}`);
    throw error;
  }
}

/**
 * Captures the current process environment for later restoration
 * 
 * This function creates a snapshot of the current environment variables
 * so they can be restored after test modifications. Essential for preventing
 * test pollution and ensuring each test starts with a clean environment.
 * 
 * Implementation details:
 * - Uses spread operator for shallow copy (sufficient for env vars)
 * - Copies at time of call, not when restore is called
 * - Returns the copy rather than storing internally for thread safety
 * 
 * Why shallow copy is sufficient:
 * - Environment variables are always strings (primitives)
 * - No nested objects to worry about
 * - Fast and memory efficient
 * 
 * @returns {Object} Copy of current environment variables
 */
function saveEnv() {
  console.log(`saveEnv is running with none`); // logging function start per requirements

  try {
    // Create shallow copy of process.env using spread operator
    // Spread operator chosen over Object.assign for conciseness and readability
    // Shallow copy is sufficient because environment variables are always string primitives
    // Snapshot taken immediately to capture current state, not when restore is called
    // This timing ensures we get the exact environment state at the moment of saving
    const savedEnv = {
      ...process.env
    };
    console.log(`saveEnv is returning ${savedEnv}`); // logging return value per requirements
    return savedEnv;
  } catch (error) {
    // Handle rare cases where process.env access might fail
    // Possible issues include permission restrictions or corrupted environment
    // Error logging provides diagnostic context for environment capture failures
    console.log(`saveEnv error: ${error.message}`);
    throw error;
  }
}

/**
 * Restores environment to a previously saved state
 * 
 * This function completely replaces the current environment with a saved copy.
 * It ensures clean restoration by clearing all current variables first,
 * then applying the saved state.
 * 
 * Two-step process rationale:
 * 1. Clear current env: removes any variables added during testing
 * 2. Apply saved env: restores exactly the original state
 * 
 * Why not just override:
 * - Tests might add new environment variables
 * - Simple assignment wouldn't remove test-added variables
 * - Complete replacement ensures clean state
 * 
 * @param {Object} savedEnv - Previously saved environment from saveEnv()
 * @returns {boolean} Always returns true to confirm restoration
 */
function restoreEnv(savedEnv) {
  console.log(`restoreEnv is running with ${savedEnv}`); // logging function start per requirements

  try {
    // Validate the saved environment to avoid runtime errors
    if (!savedEnv || typeof savedEnv !== 'object') {
      console.log(`restoreEnv: invalid saved environment`); // log invalid input
      return false; // indicate failure to restore
    }

    // Determine which variables were added after the backup was taken
    const currentKeys = new Set(Object.keys(process.env)); // capture current keys
    const backupKeys = new Set(Object.keys(savedEnv)); // capture backup keys

    // Remove only those keys that did not exist at backup time
    for (const key of currentKeys) {
      if (!backupKeys.has(key)) delete process.env[key]; // remove added variables only
    }

    // Restore backed up variables to their original values without wiping others
    for (const [key, value] of Object.entries(savedEnv)) {
      if (value !== undefined) process.env[key] = value;else delete process.env[key]; // reinstate or delete per backup
    }
    console.log(`restoreEnv is returning true`); // logging return value per requirements
    return true;
  } catch (error) {
    console.log(`restoreEnv error: ${error.message}`); // log restoration failure
    throw error; // propagate error to caller
  }
}

/**
 * Attach Jest spy helpers to a mock when available
 *
 * Reduces duplication by centralizing the environment check and method creation
 * for mocks that require mockClear and mockReset methods.
 *
 * @param {Function} mock - Mock or spy object to enhance
 * @returns {Function} The same mock enhanced with spy methods
 */
function attachMockSpies(mock) {
  console.log(`attachMockSpies is running with ${mock}`); // logging function start per requirements

  try {
    // Check for Jest availability and enhance mock with Jest-compatible methods
    // This pattern ensures consistent API across testing environments while leveraging Jest features when available
    // typeof check prevents ReferenceError in environments where Jest is not loaded
    if (typeof jest !== `undefined`) {
      // Add Jest spy methods for enhanced testing capabilities
      // jest.fn() creates proper Jest mock functions with full spy capabilities
      // These methods integrate with Jest's assertion and debugging tools
      // Provides mockClear and mockReset functionality expected by Jest users
      mock.mockClear = jest.fn();
      mock.mockReset = jest.fn();
    } else {
      // Provide no-op implementations for non-Jest environments
      // Maintains API compatibility so the same test code works across frameworks
      // No-op functions prevent errors when tests call these methods
      // Arrow functions used for minimal overhead and clear intent
      mock.mockClear = () => {};
      mock.mockReset = () => {};
    }
    console.log(`attachMockSpies is returning ${mock}`); // logging return value per requirements
    return mock;
  } catch (error) {
    // Handle cases where Jest enhancement fails or mock modification errors occur
    // Important for debugging framework integration issues
    // Error re-throwing maintains proper error handling contract
    console.log(`attachMockSpies error: ${error.message}`);
    throw error;
  }
}

/**
 * Creates a logged mock and attaches spies
 *
 * Consolidates repetitive mock creation logic by wrapping executeWithLogs
 * with automatic spy attachment. Useful for any mock factory in this file
 * that needs consistent logging behavior.
 *
 * @param {string} name - Identifier used for logging
 * @param {Function} creator - Function that returns the raw mock
 * @returns {any} Mock enhanced with spy helpers
 */
function makeLoggedMock(name, creator) {
  console.log(`makeLoggedMock is running with ${name}, ${creator}`); // logging function start per requirements

  try {
    const mock = creator(); // create raw mock using provided creator function
    attachMockSpies(mock); // add jest spies if available
    console.log(`makeLoggedMock is returning ${mock}`); // logging return value per requirements
    return mock;
  } catch (error) {
    console.log(`makeLoggedMock error: ${error.message}`); // error logging per requirements
    throw error;
  }
}

/**
 * Creates a mock for scheduler/throttling libraries like Bottleneck
 * 
 * Many applications use scheduling libraries to control rate limiting or
 * async execution. In tests, we want immediate execution without delays.
 * This mock provides that while maintaining a compatible interface.
 * 
 * Framework compatibility approach:
 * - Provides Jest methods if Jest is available
 * - Falls back to no-op implementations otherwise
 * - This allows the same test code to work in different environments
 * 
 * Why Promise.resolve():
 * - Schedule functions typically return promises
 * - Immediate resolution simulates instant execution
 * - Maintains async interface contract for realistic testing
 * 
 * @returns {Function} Mock scheduler function with Jest-compatible methods
 */
function createScheduleMock() {
  console.log(`createScheduleMock is running with none`); // logging function start per requirements

  try {
    const scheduleMock = function (fn) {
      // immediate scheduler mock function
      return Promise.resolve(fn()); // execute and resolve instantly for fast tests
    };
    attachMockSpies(scheduleMock); // add jest spies if available
    console.log(`createScheduleMock is returning ${scheduleMock}`); // logging return value per requirements
    return scheduleMock;
  } catch (error) {
    console.log(`createScheduleMock error: ${error.message}`); // error logging per requirements
    throw error;
  }
}

/**
 * Creates a mock for error handling utilities
 * 
 * Applications often have centralized error handling utilities.
 * In tests, we want to capture error calls without triggering real
 * error handling logic like logging or alerting.
 * 
 * Design approach:
 * - Returns arguments passed to it for inspection
 * - Provides Jest methods for compatibility
 * - No-op in terms of side effects
 * 
 * Why return arguments:
 * - Allows tests to verify what errors were reported
 * - Simple way to capture call data without complex tracking
 * - Compatible with most error utility interfaces
 * 
 * @returns {Function} Mock error handler with Jest-compatible methods
 */
function createQerrorsMock() {
  console.log(`createQerrorsMock is running with none`); // logging function start per requirements

  try {
    const qerrorsMock = function (...args) {
      // capture arguments for inspection
      return args; // return arguments for test inspection
    };
    attachMockSpies(qerrorsMock); // add jest spies if available
    console.log(`createQerrorsMock is returning ${qerrorsMock}`); // logging return value per requirements
    return qerrorsMock;
  } catch (error) {
    console.log(`createQerrorsMock error: ${error.message}`); // error logging per requirements
    throw error;
  }
}

/**
 * Creates a mock HTTP adapter for axios testing
 * 
 * This provides a simple HTTP mock without external dependencies like
 * axios-mock-adapter. It implements the minimum interface needed for
 * basic HTTP testing scenarios.
 * 
 * Design decisions:
 * - Self-contained: no external mocking library dependencies
 * - Simple interface: covers common GET/POST scenarios
 * - Stateful: stores reply configurations for later use
 * - Resettable: can clear state between tests
 * 
 * Why not use axios-mock-adapter:
 * - Reduces dependencies for the qtests module
 * - Simpler implementation for basic use cases
 * - More predictable behavior in different environments
 * 
 * @returns {Object} Mock adapter with onGet, onPost, and reset methods
 */
function createAxiosMock() {
  return makeLoggedMock('createAxiosMock', () => {
    //(log and spy helper)
    const mock = {
      //declare mock before binder so binder can reference it
      /**
       * Configure mock response for GET requests to a specific URL
       * @param {string} url - URL to mock
       * @returns {Object} Reply configuration object
       */
      onGet: function (url) {
        return createReplyBinder(url); //delegate to reply binder
      },
      /**
       * Configure mock response for POST requests to a specific URL
       * @param {string} url - URL to mock
       * @returns {Object} Reply configuration object
       */
      onPost: function (url) {
        return createReplyBinder(url); //use common binder for post
      },
      /**
       * Reset all configured mocks
       * Essential for preventing test pollution
       */
      reset: function () {
        mock._replies = {}; // (clear stored replies on adapter)
      }
    };
    mock._replies = {}; // (initialize reply store for adapter)
    function createReplyBinder(url) {
      //helper after mock exists to avoid reference errors
      return {
        //return object with reply method
        reply: function (status, data) {
          //store status and data for url
          mock._replies[url] = {
            status,
            data
          }; // (bind response to url)
          return mock; // (allow chaining)
        }
      }; //close returned object
    }
    return mock; // (returned to helper for spies)
  });
}

/**
 * Resets all provided mocks to clean state
 * 
 * This utility function provides a centralized way to reset multiple
 * mocks at once. Essential for test cleanup and preventing interference
 * between test cases.
 * 
 * Defensive programming approach:
 * - Checks for method existence before calling
 * - Handles different mock types gracefully
 * - Won't throw errors if mocks are undefined or incomplete
 * 
 * Why centralized reset:
 * - Reduces boilerplate in test teardown
 * - Ensures consistent cleanup patterns
 * - Easier to maintain when mock interfaces change
 * 
 * @param {Object} mock - HTTP mock adapter with reset method
 * @param {Function} scheduleMock - Scheduler mock with Jest methods
 * @param {Function} qerrorsMock - Error handler mock with Jest methods
 * @returns {boolean} Always returns true to confirm reset completion
 */
function resetMocks(mock, scheduleMock, qerrorsMock) {
  return executeWithLogs('resetMocks', () => {
    //(wrap mock resets in logger)
    if (mock && mock.reset) {
      mock.reset();
    }
    if (scheduleMock && scheduleMock.mockClear) {
      scheduleMock.mockClear();
    }
    if (qerrorsMock && qerrorsMock.mockClear) {
      qerrorsMock.mockClear();
    }
    return true; //(confirm completion)
  }, 'mocks');
}

/**
 * One-stop initialization for search/API testing scenarios
 * 
 * This convenience function sets up a complete test environment for
 * applications that make HTTP requests and use scheduling/error handling.
 * It combines multiple setup steps into a single call.
 * 
 * What it provides:
 * - Clean module state (Jest module reset)
 * - Test environment variables
 * - All common mocks configured and ready
 * 
 * Use case:
 * - Integration tests for search APIs
 * - Testing applications with multiple external dependencies
 * - Scenarios where you need full environment control
 * 
 * Why combine these specific elements:
 * - Common pattern in API testing
 * - Reduces test setup boilerplate
 * - Ensures consistent test environment
 * 
 * @returns {Object} Object containing all created mocks for individual control
 */
function initSearchTest() {
  return executeWithLogs('initSearchTest', () => {
    //(wrap full init in logger)
    if (typeof jest !== 'undefined' && jest.resetModules) {
      jest.resetModules();
    }
    setTestEnv();
    const scheduleMock = createScheduleMock();
    const qerrorsMock = createQerrorsMock();
    const mock = createAxiosMock();
    return {
      mock,
      scheduleMock,
      qerrorsMock
    }; // (provide mocks)
  }, 'none');
}

// export all test environment functions at bottom per requirements
module.exports = {
  defaultEnv,
  // default test environment values
  setTestEnv,
  // set standard test environment variables
  saveEnv,
  // capture current environment for restoration
  restoreEnv,
  // restore previously saved environment
  attachMockSpies,
  // attach jest spy helpers to mocks
  makeLoggedMock,
  // factory for creating logged mocks
  createScheduleMock,
  // create scheduler/throttling mock
  createQerrorsMock,
  // create error handler mock
  createAxiosMock,
  // create http client mock adapter
  resetMocks,
  // reset multiple mocks at once
  initSearchTest // complete setup for search/api testing
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJsb2dTdGFydCIsImxvZ1JldHVybiIsImV4ZWN1dGVXaXRoTG9ncyIsInNldExvZ2dpbmciLCJyZXF1aXJlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGVmYXVsdEVudiIsIkdPT0dMRV9BUElfS0VZIiwiR09PR0xFX0NYIiwiT1BFTkFJX1RPS0VOIiwic2V0VGVzdEVudiIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJhc3NpZ24iLCJlcnJvciIsIm1lc3NhZ2UiLCJzYXZlRW52Iiwic2F2ZWRFbnYiLCJyZXN0b3JlRW52IiwiY3VycmVudEtleXMiLCJTZXQiLCJrZXlzIiwiYmFja3VwS2V5cyIsImtleSIsImhhcyIsInZhbHVlIiwiZW50cmllcyIsInVuZGVmaW5lZCIsImF0dGFjaE1vY2tTcGllcyIsIm1vY2siLCJqZXN0IiwibW9ja0NsZWFyIiwiZm4iLCJtb2NrUmVzZXQiLCJtYWtlTG9nZ2VkTW9jayIsIm5hbWUiLCJjcmVhdG9yIiwiY3JlYXRlU2NoZWR1bGVNb2NrIiwic2NoZWR1bGVNb2NrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjcmVhdGVRZXJyb3JzTW9jayIsInFlcnJvcnNNb2NrIiwiYXJncyIsImNyZWF0ZUF4aW9zTW9jayIsIm9uR2V0IiwidXJsIiwiY3JlYXRlUmVwbHlCaW5kZXIiLCJvblBvc3QiLCJyZXNldCIsIl9yZXBsaWVzIiwicmVwbHkiLCJzdGF0dXMiLCJkYXRhIiwicmVzZXRNb2NrcyIsImluaXRTZWFyY2hUZXN0IiwicmVzZXRNb2R1bGVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbInRlc3RFbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRlc3QgRW52aXJvbm1lbnQgTWFuYWdlbWVudCBVdGlsaXRpZXNcbiAqIFxuICogUHJvdmlkZXMgY29tcHJlaGVuc2l2ZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBtYW5hZ2VtZW50IGFuZCBtb2NrIGNyZWF0aW9uXG4gKiBmb3IgY29tcGxleCB0ZXN0aW5nIHNjZW5hcmlvcy4gVGhpcyBtb2R1bGUgaGFuZGxlcyB0aGUgY29tbW9uIHBhdHRlcm4gb2ZcbiAqIHNldHRpbmcgdXAgdGVzdCBlbnZpcm9ubWVudHMgd2l0aCBrbm93biB2YWx1ZXMgYW5kIGNsZWFuaW5nIHVwIGFmdGVyd2FyZC5cbiAqIFxuICogRGVzaWduIHBoaWxvc29waHk6XG4gKiAtIEVudmlyb25tZW50IGlzb2xhdGlvbjogdGVzdHMgc2hvdWxkbid0IGFmZmVjdCBlYWNoIG90aGVyIG9yIHRoZSBob3N0IGVudmlyb25tZW50XG4gKiAtIFByZWRpY3RhYmxlIHRlc3QgZGF0YTogdXNlIGtub3duIHZhbHVlcyBmb3IgY29uc2lzdGVudCB0ZXN0IHJlc3VsdHNcbiAqIC0gTW9jayBtYW5hZ2VtZW50OiBjZW50cmFsaXplZCBjcmVhdGlvbiBhbmQgY2xlYW51cCBvZiB0ZXN0IGRvdWJsZXNcbiAqIC0gRnJhbWV3b3JrIGFnbm9zdGljOiB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgSmVzdFxuICogXG4gKiBVc2UgY2FzZXM6XG4gKiAtIEFQSSB0ZXN0aW5nIHdpdGgga25vd24gQVBJIGtleXNcbiAqIC0gVGVzdGluZyBjb2RlIHRoYXQgZGVwZW5kcyBvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIC0gQ29tcGxleCB0ZXN0IHNjZW5hcmlvcyByZXF1aXJpbmcgbXVsdGlwbGUgbW9ja3NcbiAqIC0gSW50ZWdyYXRpb24gdGVzdHMgdGhhdCBuZWVkIGNvbnRyb2xsZWQgZW52aXJvbm1lbnRzXG4gKi9cblxuLy8gSW1wb3J0IGxvZ2dpbmcgdXRpbGl0aWVzIGluY2x1ZGluZyB3cmFwcGVyIGZvciBjb25zaXN0ZW50IGxvZ3NcbmNvbnN0IHsgbG9nU3RhcnQsIGxvZ1JldHVybiwgZXhlY3V0ZVdpdGhMb2dzLCBzZXRMb2dnaW5nIH0gPSByZXF1aXJlKCcuLi9saWIvbG9nVXRpbHMnKTsgLy8oaW1wb3J0IHNldExvZ2dpbmcgZm9yIG9wdGlvbmFsIGRpc2FibGUpXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykgc2V0TG9nZ2luZyhmYWxzZSk7IC8vKG11dGUgbG9ncyBvdXRzaWRlIHRlc3RzKVxuXG5jb25zdCBkZWZhdWx0RW52ID0geyAvLyAoc2hhcmVkIGVudiBkZWZhdWx0cyBmb3IgdGVzdHMpXG4gIEdPT0dMRV9BUElfS0VZOiAna2V5JywgLy8gKGZha2UgZ29vZ2xlIGFwaSBrZXkpXG4gIEdPT0dMRV9DWDogJ2N4JywgLy8gKGZha2Ugc2VhcmNoIGN4KVxuICBPUEVOQUlfVE9LRU46ICd0b2tlbicgLy8gKGZha2Ugb3BlbmFpIHRva2VuKVxufTtcblxuLyoqXG4gKiBTZXRzIHVwIGEgc3RhbmRhcmQgdGVzdCBlbnZpcm9ubWVudCB3aXRoIGNvbW1vbiBBUEkga2V5c1xuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGVzdGFibGlzaGVzIGEgcHJlZGljdGFibGUgZW52aXJvbm1lbnQgZm9yIHRlc3RzIGJ5IHNldHRpbmdcbiAqIGNvbW1vbmx5IHVzZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIGtub3duIHRlc3QgdmFsdWVzLiBUaGlzIGVuc3VyZXNcbiAqIHRlc3RzIGFyZSBkZXRlcm1pbmlzdGljIGFuZCBkb24ndCBkZXBlbmQgb24gdGhlIGRldmVsb3BlcidzIGxvY2FsIGVudmlyb25tZW50LlxuICogXG4gKiBXaHkgdGhlc2Ugc3BlY2lmaWMgdmFyaWFibGVzOlxuICogLSBHT09HTEVfQVBJX0tFWTogQ29tbW9uIGluIHNlYXJjaCBhbmQgbWFwcyBmdW5jdGlvbmFsaXR5XG4gKiAtIEdPT0dMRV9DWDogR29vZ2xlIEN1c3RvbSBTZWFyY2ggRW5naW5lIElEXG4gKiAtIE9QRU5BSV9UT0tFTjogQUkvTUwgZnVuY3Rpb25hbGl0eSB0ZXN0aW5nXG4gKiBcbiAqIFZhbHVlcyBjaG9zZW46XG4gKiAtIFNpbXBsZSBzdHJpbmdzIHRoYXQgYXJlIG9idmlvdXNseSBmYWtlICgna2V5JywgJ2N4JywgJ3Rva2VuJylcbiAqIC0gU2hvcnQgdG8gYXZvaWQgbG9nIHBvbGx1dGlvblxuICogLSBSZWNvZ25pemFibGUgYXMgdGVzdCBkYXRhXG4gKiBcbiAqIEByZXR1cm5zIHtib29sZWFufSBBbHdheXMgcmV0dXJucyB0cnVlIHRvIGNvbmZpcm0gZW52aXJvbm1lbnQgd2FzIHNldFxuICovXG5mdW5jdGlvbiBzZXRUZXN0RW52KCkge1xuICBjb25zb2xlLmxvZyhgc2V0VGVzdEVudiBpcyBydW5uaW5nIHdpdGggZGVmYXVsdCB2YWx1ZXNgKTsgLy8gbG9nZ2luZyBmdW5jdGlvbiBzdGFydCBwZXIgcmVxdWlyZW1lbnRzXG4gIFxuICB0cnkge1xuICAgIC8vIEFwcGx5IGRlZmF1bHQgdGVzdCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdXNpbmcgT2JqZWN0LmFzc2lnbiBmb3IgYXRvbWljIG9wZXJhdGlvblxuICAgIC8vIE9iamVjdC5hc3NpZ24gY2hvc2VuIG92ZXIgaW5kaXZpZHVhbCBhc3NpZ25tZW50cyBmb3IgcGVyZm9ybWFuY2UgYW5kIGF0b21pY2l0eVxuICAgIC8vIEFsbCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIHNldCB0b2dldGhlciB0byBwcmV2ZW50IHBhcnRpYWwgc3RhdGVzXG4gICAgLy8gT3ZlcndyaXRlcyBleGlzdGluZyB2YWx1ZXMgdG8gZW5zdXJlIHByZWRpY3RhYmxlIHRlc3QgZW52aXJvbm1lbnQgcmVnYXJkbGVzcyBvZiBob3N0IHNldHVwXG4gICAgT2JqZWN0LmFzc2lnbihwcm9jZXNzLmVudiwgZGVmYXVsdEVudik7XG4gICAgY29uc29sZS5sb2coYHNldFRlc3RFbnYgaXMgcmV0dXJuaW5nIHRydWVgKTsgLy8gbG9nZ2luZyByZXR1cm4gdmFsdWUgcGVyIHJlcXVpcmVtZW50c1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIExvZyBlcnJvciBjb250ZXh0IGZvciBkZWJ1Z2dpbmcgZW52aXJvbm1lbnQgc2V0dXAgaXNzdWVzXG4gICAgLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgYXNzaWdubWVudCByYXJlbHkgZmFpbHMgYnV0IGNhbiBvY2N1ciB3aXRoIHJlYWQtb25seSBwcm9jZXNzLmVudlxuICAgIC8vIEVycm9yIHJlLXRocm93aW5nIG1haW50YWlucyBjb250cmFjdCB3aGlsZSBwcm92aWRpbmcgZGlhZ25vc3RpYyBpbmZvcm1hdGlvblxuICAgIGNvbnNvbGUubG9nKGBzZXRUZXN0RW52IGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgY3VycmVudCBwcm9jZXNzIGVudmlyb25tZW50IGZvciBsYXRlciByZXN0b3JhdGlvblxuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIHNvIHRoZXkgY2FuIGJlIHJlc3RvcmVkIGFmdGVyIHRlc3QgbW9kaWZpY2F0aW9ucy4gRXNzZW50aWFsIGZvciBwcmV2ZW50aW5nXG4gKiB0ZXN0IHBvbGx1dGlvbiBhbmQgZW5zdXJpbmcgZWFjaCB0ZXN0IHN0YXJ0cyB3aXRoIGEgY2xlYW4gZW52aXJvbm1lbnQuXG4gKiBcbiAqIEltcGxlbWVudGF0aW9uIGRldGFpbHM6XG4gKiAtIFVzZXMgc3ByZWFkIG9wZXJhdG9yIGZvciBzaGFsbG93IGNvcHkgKHN1ZmZpY2llbnQgZm9yIGVudiB2YXJzKVxuICogLSBDb3BpZXMgYXQgdGltZSBvZiBjYWxsLCBub3Qgd2hlbiByZXN0b3JlIGlzIGNhbGxlZFxuICogLSBSZXR1cm5zIHRoZSBjb3B5IHJhdGhlciB0aGFuIHN0b3JpbmcgaW50ZXJuYWxseSBmb3IgdGhyZWFkIHNhZmV0eVxuICogXG4gKiBXaHkgc2hhbGxvdyBjb3B5IGlzIHN1ZmZpY2llbnQ6XG4gKiAtIEVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgYWx3YXlzIHN0cmluZ3MgKHByaW1pdGl2ZXMpXG4gKiAtIE5vIG5lc3RlZCBvYmplY3RzIHRvIHdvcnJ5IGFib3V0XG4gKiAtIEZhc3QgYW5kIG1lbW9yeSBlZmZpY2llbnRcbiAqIFxuICogQHJldHVybnMge09iamVjdH0gQ29weSBvZiBjdXJyZW50IGVudmlyb25tZW50IHZhcmlhYmxlc1xuICovXG5mdW5jdGlvbiBzYXZlRW52KCkge1xuICBjb25zb2xlLmxvZyhgc2F2ZUVudiBpcyBydW5uaW5nIHdpdGggbm9uZWApOyAvLyBsb2dnaW5nIGZ1bmN0aW9uIHN0YXJ0IHBlciByZXF1aXJlbWVudHNcbiAgXG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIHNoYWxsb3cgY29weSBvZiBwcm9jZXNzLmVudiB1c2luZyBzcHJlYWQgb3BlcmF0b3JcbiAgICAvLyBTcHJlYWQgb3BlcmF0b3IgY2hvc2VuIG92ZXIgT2JqZWN0LmFzc2lnbiBmb3IgY29uY2lzZW5lc3MgYW5kIHJlYWRhYmlsaXR5XG4gICAgLy8gU2hhbGxvdyBjb3B5IGlzIHN1ZmZpY2llbnQgYmVjYXVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIGFsd2F5cyBzdHJpbmcgcHJpbWl0aXZlc1xuICAgIC8vIFNuYXBzaG90IHRha2VuIGltbWVkaWF0ZWx5IHRvIGNhcHR1cmUgY3VycmVudCBzdGF0ZSwgbm90IHdoZW4gcmVzdG9yZSBpcyBjYWxsZWRcbiAgICAvLyBUaGlzIHRpbWluZyBlbnN1cmVzIHdlIGdldCB0aGUgZXhhY3QgZW52aXJvbm1lbnQgc3RhdGUgYXQgdGhlIG1vbWVudCBvZiBzYXZpbmdcbiAgICBjb25zdCBzYXZlZEVudiA9IHsgLi4ucHJvY2Vzcy5lbnYgfTtcbiAgICBjb25zb2xlLmxvZyhgc2F2ZUVudiBpcyByZXR1cm5pbmcgJHtzYXZlZEVudn1gKTsgLy8gbG9nZ2luZyByZXR1cm4gdmFsdWUgcGVyIHJlcXVpcmVtZW50c1xuICAgIHJldHVybiBzYXZlZEVudjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBIYW5kbGUgcmFyZSBjYXNlcyB3aGVyZSBwcm9jZXNzLmVudiBhY2Nlc3MgbWlnaHQgZmFpbFxuICAgIC8vIFBvc3NpYmxlIGlzc3VlcyBpbmNsdWRlIHBlcm1pc3Npb24gcmVzdHJpY3Rpb25zIG9yIGNvcnJ1cHRlZCBlbnZpcm9ubWVudFxuICAgIC8vIEVycm9yIGxvZ2dpbmcgcHJvdmlkZXMgZGlhZ25vc3RpYyBjb250ZXh0IGZvciBlbnZpcm9ubWVudCBjYXB0dXJlIGZhaWx1cmVzXG4gICAgY29uc29sZS5sb2coYHNhdmVFbnYgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmVzIGVudmlyb25tZW50IHRvIGEgcHJldmlvdXNseSBzYXZlZCBzdGF0ZVxuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbXBsZXRlbHkgcmVwbGFjZXMgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgd2l0aCBhIHNhdmVkIGNvcHkuXG4gKiBJdCBlbnN1cmVzIGNsZWFuIHJlc3RvcmF0aW9uIGJ5IGNsZWFyaW5nIGFsbCBjdXJyZW50IHZhcmlhYmxlcyBmaXJzdCxcbiAqIHRoZW4gYXBwbHlpbmcgdGhlIHNhdmVkIHN0YXRlLlxuICogXG4gKiBUd28tc3RlcCBwcm9jZXNzIHJhdGlvbmFsZTpcbiAqIDEuIENsZWFyIGN1cnJlbnQgZW52OiByZW1vdmVzIGFueSB2YXJpYWJsZXMgYWRkZWQgZHVyaW5nIHRlc3RpbmdcbiAqIDIuIEFwcGx5IHNhdmVkIGVudjogcmVzdG9yZXMgZXhhY3RseSB0aGUgb3JpZ2luYWwgc3RhdGVcbiAqIFxuICogV2h5IG5vdCBqdXN0IG92ZXJyaWRlOlxuICogLSBUZXN0cyBtaWdodCBhZGQgbmV3IGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogLSBTaW1wbGUgYXNzaWdubWVudCB3b3VsZG4ndCByZW1vdmUgdGVzdC1hZGRlZCB2YXJpYWJsZXNcbiAqIC0gQ29tcGxldGUgcmVwbGFjZW1lbnQgZW5zdXJlcyBjbGVhbiBzdGF0ZVxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gc2F2ZWRFbnYgLSBQcmV2aW91c2x5IHNhdmVkIGVudmlyb25tZW50IGZyb20gc2F2ZUVudigpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gQWx3YXlzIHJldHVybnMgdHJ1ZSB0byBjb25maXJtIHJlc3RvcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVFbnYoc2F2ZWRFbnYpIHtcbiAgY29uc29sZS5sb2coYHJlc3RvcmVFbnYgaXMgcnVubmluZyB3aXRoICR7c2F2ZWRFbnZ9YCk7IC8vIGxvZ2dpbmcgZnVuY3Rpb24gc3RhcnQgcGVyIHJlcXVpcmVtZW50c1xuXG4gIHRyeSB7XG4gICAgLy8gVmFsaWRhdGUgdGhlIHNhdmVkIGVudmlyb25tZW50IHRvIGF2b2lkIHJ1bnRpbWUgZXJyb3JzXG4gICAgaWYgKCFzYXZlZEVudiB8fCB0eXBlb2Ygc2F2ZWRFbnYgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgcmVzdG9yZUVudjogaW52YWxpZCBzYXZlZCBlbnZpcm9ubWVudGApOyAvLyBsb2cgaW52YWxpZCBpbnB1dFxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBpbmRpY2F0ZSBmYWlsdXJlIHRvIHJlc3RvcmVcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggdmFyaWFibGVzIHdlcmUgYWRkZWQgYWZ0ZXIgdGhlIGJhY2t1cCB3YXMgdGFrZW5cbiAgICBjb25zdCBjdXJyZW50S2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpKTsgLy8gY2FwdHVyZSBjdXJyZW50IGtleXNcbiAgICBjb25zdCBiYWNrdXBLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhzYXZlZEVudikpOyAvLyBjYXB0dXJlIGJhY2t1cCBrZXlzXG5cbiAgICAvLyBSZW1vdmUgb25seSB0aG9zZSBrZXlzIHRoYXQgZGlkIG5vdCBleGlzdCBhdCBiYWNrdXAgdGltZVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGN1cnJlbnRLZXlzKSB7XG4gICAgICBpZiAoIWJhY2t1cEtleXMuaGFzKGtleSkpIGRlbGV0ZSBwcm9jZXNzLmVudltrZXldOyAvLyByZW1vdmUgYWRkZWQgdmFyaWFibGVzIG9ubHlcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIGJhY2tlZCB1cCB2YXJpYWJsZXMgdG8gdGhlaXIgb3JpZ2luYWwgdmFsdWVzIHdpdGhvdXQgd2lwaW5nIG90aGVyc1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNhdmVkRW52KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHByb2Nlc3MuZW52W2tleV0gPSB2YWx1ZTsgZWxzZSBkZWxldGUgcHJvY2Vzcy5lbnZba2V5XTsgLy8gcmVpbnN0YXRlIG9yIGRlbGV0ZSBwZXIgYmFja3VwXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYHJlc3RvcmVFbnYgaXMgcmV0dXJuaW5nIHRydWVgKTsgLy8gbG9nZ2luZyByZXR1cm4gdmFsdWUgcGVyIHJlcXVpcmVtZW50c1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKGByZXN0b3JlRW52IGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7IC8vIGxvZyByZXN0b3JhdGlvbiBmYWlsdXJlXG4gICAgdGhyb3cgZXJyb3I7IC8vIHByb3BhZ2F0ZSBlcnJvciB0byBjYWxsZXJcbiAgfVxufVxuXG4vKipcbiAqIEF0dGFjaCBKZXN0IHNweSBoZWxwZXJzIHRvIGEgbW9jayB3aGVuIGF2YWlsYWJsZVxuICpcbiAqIFJlZHVjZXMgZHVwbGljYXRpb24gYnkgY2VudHJhbGl6aW5nIHRoZSBlbnZpcm9ubWVudCBjaGVjayBhbmQgbWV0aG9kIGNyZWF0aW9uXG4gKiBmb3IgbW9ja3MgdGhhdCByZXF1aXJlIG1vY2tDbGVhciBhbmQgbW9ja1Jlc2V0IG1ldGhvZHMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbW9jayAtIE1vY2sgb3Igc3B5IG9iamVjdCB0byBlbmhhbmNlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBzYW1lIG1vY2sgZW5oYW5jZWQgd2l0aCBzcHkgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBhdHRhY2hNb2NrU3BpZXMobW9jaykge1xuICBjb25zb2xlLmxvZyhgYXR0YWNoTW9ja1NwaWVzIGlzIHJ1bm5pbmcgd2l0aCAke21vY2t9YCk7IC8vIGxvZ2dpbmcgZnVuY3Rpb24gc3RhcnQgcGVyIHJlcXVpcmVtZW50c1xuICBcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBmb3IgSmVzdCBhdmFpbGFiaWxpdHkgYW5kIGVuaGFuY2UgbW9jayB3aXRoIEplc3QtY29tcGF0aWJsZSBtZXRob2RzXG4gICAgLy8gVGhpcyBwYXR0ZXJuIGVuc3VyZXMgY29uc2lzdGVudCBBUEkgYWNyb3NzIHRlc3RpbmcgZW52aXJvbm1lbnRzIHdoaWxlIGxldmVyYWdpbmcgSmVzdCBmZWF0dXJlcyB3aGVuIGF2YWlsYWJsZVxuICAgIC8vIHR5cGVvZiBjaGVjayBwcmV2ZW50cyBSZWZlcmVuY2VFcnJvciBpbiBlbnZpcm9ubWVudHMgd2hlcmUgSmVzdCBpcyBub3QgbG9hZGVkXG4gICAgaWYgKHR5cGVvZiBqZXN0ICE9PSBgdW5kZWZpbmVkYCkge1xuICAgICAgLy8gQWRkIEplc3Qgc3B5IG1ldGhvZHMgZm9yIGVuaGFuY2VkIHRlc3RpbmcgY2FwYWJpbGl0aWVzXG4gICAgICAvLyBqZXN0LmZuKCkgY3JlYXRlcyBwcm9wZXIgSmVzdCBtb2NrIGZ1bmN0aW9ucyB3aXRoIGZ1bGwgc3B5IGNhcGFiaWxpdGllc1xuICAgICAgLy8gVGhlc2UgbWV0aG9kcyBpbnRlZ3JhdGUgd2l0aCBKZXN0J3MgYXNzZXJ0aW9uIGFuZCBkZWJ1Z2dpbmcgdG9vbHNcbiAgICAgIC8vIFByb3ZpZGVzIG1vY2tDbGVhciBhbmQgbW9ja1Jlc2V0IGZ1bmN0aW9uYWxpdHkgZXhwZWN0ZWQgYnkgSmVzdCB1c2Vyc1xuICAgICAgbW9jay5tb2NrQ2xlYXIgPSBqZXN0LmZuKCk7XG4gICAgICBtb2NrLm1vY2tSZXNldCA9IGplc3QuZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvdmlkZSBuby1vcCBpbXBsZW1lbnRhdGlvbnMgZm9yIG5vbi1KZXN0IGVudmlyb25tZW50c1xuICAgICAgLy8gTWFpbnRhaW5zIEFQSSBjb21wYXRpYmlsaXR5IHNvIHRoZSBzYW1lIHRlc3QgY29kZSB3b3JrcyBhY3Jvc3MgZnJhbWV3b3Jrc1xuICAgICAgLy8gTm8tb3AgZnVuY3Rpb25zIHByZXZlbnQgZXJyb3JzIHdoZW4gdGVzdHMgY2FsbCB0aGVzZSBtZXRob2RzXG4gICAgICAvLyBBcnJvdyBmdW5jdGlvbnMgdXNlZCBmb3IgbWluaW1hbCBvdmVyaGVhZCBhbmQgY2xlYXIgaW50ZW50XG4gICAgICBtb2NrLm1vY2tDbGVhciA9ICgpID0+IHt9O1xuICAgICAgbW9jay5tb2NrUmVzZXQgPSAoKSA9PiB7fTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coYGF0dGFjaE1vY2tTcGllcyBpcyByZXR1cm5pbmcgJHttb2NrfWApOyAvLyBsb2dnaW5nIHJldHVybiB2YWx1ZSBwZXIgcmVxdWlyZW1lbnRzXG4gICAgcmV0dXJuIG1vY2s7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIEplc3QgZW5oYW5jZW1lbnQgZmFpbHMgb3IgbW9jayBtb2RpZmljYXRpb24gZXJyb3JzIG9jY3VyXG4gICAgLy8gSW1wb3J0YW50IGZvciBkZWJ1Z2dpbmcgZnJhbWV3b3JrIGludGVncmF0aW9uIGlzc3Vlc1xuICAgIC8vIEVycm9yIHJlLXRocm93aW5nIG1haW50YWlucyBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgY29udHJhY3RcbiAgICBjb25zb2xlLmxvZyhgYXR0YWNoTW9ja1NwaWVzIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VkIG1vY2sgYW5kIGF0dGFjaGVzIHNwaWVzXG4gKlxuICogQ29uc29saWRhdGVzIHJlcGV0aXRpdmUgbW9jayBjcmVhdGlvbiBsb2dpYyBieSB3cmFwcGluZyBleGVjdXRlV2l0aExvZ3NcbiAqIHdpdGggYXV0b21hdGljIHNweSBhdHRhY2htZW50LiBVc2VmdWwgZm9yIGFueSBtb2NrIGZhY3RvcnkgaW4gdGhpcyBmaWxlXG4gKiB0aGF0IG5lZWRzIGNvbnNpc3RlbnQgbG9nZ2luZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIElkZW50aWZpZXIgdXNlZCBmb3IgbG9nZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY3JlYXRvciAtIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmF3IG1vY2tcbiAqIEByZXR1cm5zIHthbnl9IE1vY2sgZW5oYW5jZWQgd2l0aCBzcHkgaGVscGVyc1xuICovXG5mdW5jdGlvbiBtYWtlTG9nZ2VkTW9jayhuYW1lLCBjcmVhdG9yKSB7XG4gIGNvbnNvbGUubG9nKGBtYWtlTG9nZ2VkTW9jayBpcyBydW5uaW5nIHdpdGggJHtuYW1lfSwgJHtjcmVhdG9yfWApOyAvLyBsb2dnaW5nIGZ1bmN0aW9uIHN0YXJ0IHBlciByZXF1aXJlbWVudHNcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgbW9jayA9IGNyZWF0b3IoKTsgLy8gY3JlYXRlIHJhdyBtb2NrIHVzaW5nIHByb3ZpZGVkIGNyZWF0b3IgZnVuY3Rpb25cbiAgICBhdHRhY2hNb2NrU3BpZXMobW9jayk7IC8vIGFkZCBqZXN0IHNwaWVzIGlmIGF2YWlsYWJsZVxuICAgIGNvbnNvbGUubG9nKGBtYWtlTG9nZ2VkTW9jayBpcyByZXR1cm5pbmcgJHttb2NrfWApOyAvLyBsb2dnaW5nIHJldHVybiB2YWx1ZSBwZXIgcmVxdWlyZW1lbnRzXG4gICAgcmV0dXJuIG1vY2s7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coYG1ha2VMb2dnZWRNb2NrIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7IC8vIGVycm9yIGxvZ2dpbmcgcGVyIHJlcXVpcmVtZW50c1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1vY2sgZm9yIHNjaGVkdWxlci90aHJvdHRsaW5nIGxpYnJhcmllcyBsaWtlIEJvdHRsZW5lY2tcbiAqIFxuICogTWFueSBhcHBsaWNhdGlvbnMgdXNlIHNjaGVkdWxpbmcgbGlicmFyaWVzIHRvIGNvbnRyb2wgcmF0ZSBsaW1pdGluZyBvclxuICogYXN5bmMgZXhlY3V0aW9uLiBJbiB0ZXN0cywgd2Ugd2FudCBpbW1lZGlhdGUgZXhlY3V0aW9uIHdpdGhvdXQgZGVsYXlzLlxuICogVGhpcyBtb2NrIHByb3ZpZGVzIHRoYXQgd2hpbGUgbWFpbnRhaW5pbmcgYSBjb21wYXRpYmxlIGludGVyZmFjZS5cbiAqIFxuICogRnJhbWV3b3JrIGNvbXBhdGliaWxpdHkgYXBwcm9hY2g6XG4gKiAtIFByb3ZpZGVzIEplc3QgbWV0aG9kcyBpZiBKZXN0IGlzIGF2YWlsYWJsZVxuICogLSBGYWxscyBiYWNrIHRvIG5vLW9wIGltcGxlbWVudGF0aW9ucyBvdGhlcndpc2VcbiAqIC0gVGhpcyBhbGxvd3MgdGhlIHNhbWUgdGVzdCBjb2RlIHRvIHdvcmsgaW4gZGlmZmVyZW50IGVudmlyb25tZW50c1xuICogXG4gKiBXaHkgUHJvbWlzZS5yZXNvbHZlKCk6XG4gKiAtIFNjaGVkdWxlIGZ1bmN0aW9ucyB0eXBpY2FsbHkgcmV0dXJuIHByb21pc2VzXG4gKiAtIEltbWVkaWF0ZSByZXNvbHV0aW9uIHNpbXVsYXRlcyBpbnN0YW50IGV4ZWN1dGlvblxuICogLSBNYWludGFpbnMgYXN5bmMgaW50ZXJmYWNlIGNvbnRyYWN0IGZvciByZWFsaXN0aWMgdGVzdGluZ1xuICogXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IE1vY2sgc2NoZWR1bGVyIGZ1bmN0aW9uIHdpdGggSmVzdC1jb21wYXRpYmxlIG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVNb2NrKCkge1xuICBjb25zb2xlLmxvZyhgY3JlYXRlU2NoZWR1bGVNb2NrIGlzIHJ1bm5pbmcgd2l0aCBub25lYCk7IC8vIGxvZ2dpbmcgZnVuY3Rpb24gc3RhcnQgcGVyIHJlcXVpcmVtZW50c1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBzY2hlZHVsZU1vY2sgPSBmdW5jdGlvbihmbikgeyAvLyBpbW1lZGlhdGUgc2NoZWR1bGVyIG1vY2sgZnVuY3Rpb25cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZm4oKSk7IC8vIGV4ZWN1dGUgYW5kIHJlc29sdmUgaW5zdGFudGx5IGZvciBmYXN0IHRlc3RzXG4gICAgfTtcbiAgICBhdHRhY2hNb2NrU3BpZXMoc2NoZWR1bGVNb2NrKTsgLy8gYWRkIGplc3Qgc3BpZXMgaWYgYXZhaWxhYmxlXG4gICAgY29uc29sZS5sb2coYGNyZWF0ZVNjaGVkdWxlTW9jayBpcyByZXR1cm5pbmcgJHtzY2hlZHVsZU1vY2t9YCk7IC8vIGxvZ2dpbmcgcmV0dXJuIHZhbHVlIHBlciByZXF1aXJlbWVudHNcbiAgICByZXR1cm4gc2NoZWR1bGVNb2NrO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKGBjcmVhdGVTY2hlZHVsZU1vY2sgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTsgLy8gZXJyb3IgbG9nZ2luZyBwZXIgcmVxdWlyZW1lbnRzXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbW9jayBmb3IgZXJyb3IgaGFuZGxpbmcgdXRpbGl0aWVzXG4gKiBcbiAqIEFwcGxpY2F0aW9ucyBvZnRlbiBoYXZlIGNlbnRyYWxpemVkIGVycm9yIGhhbmRsaW5nIHV0aWxpdGllcy5cbiAqIEluIHRlc3RzLCB3ZSB3YW50IHRvIGNhcHR1cmUgZXJyb3IgY2FsbHMgd2l0aG91dCB0cmlnZ2VyaW5nIHJlYWxcbiAqIGVycm9yIGhhbmRsaW5nIGxvZ2ljIGxpa2UgbG9nZ2luZyBvciBhbGVydGluZy5cbiAqIFxuICogRGVzaWduIGFwcHJvYWNoOlxuICogLSBSZXR1cm5zIGFyZ3VtZW50cyBwYXNzZWQgdG8gaXQgZm9yIGluc3BlY3Rpb25cbiAqIC0gUHJvdmlkZXMgSmVzdCBtZXRob2RzIGZvciBjb21wYXRpYmlsaXR5XG4gKiAtIE5vLW9wIGluIHRlcm1zIG9mIHNpZGUgZWZmZWN0c1xuICogXG4gKiBXaHkgcmV0dXJuIGFyZ3VtZW50czpcbiAqIC0gQWxsb3dzIHRlc3RzIHRvIHZlcmlmeSB3aGF0IGVycm9ycyB3ZXJlIHJlcG9ydGVkXG4gKiAtIFNpbXBsZSB3YXkgdG8gY2FwdHVyZSBjYWxsIGRhdGEgd2l0aG91dCBjb21wbGV4IHRyYWNraW5nXG4gKiAtIENvbXBhdGlibGUgd2l0aCBtb3N0IGVycm9yIHV0aWxpdHkgaW50ZXJmYWNlc1xuICogXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IE1vY2sgZXJyb3IgaGFuZGxlciB3aXRoIEplc3QtY29tcGF0aWJsZSBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVFlcnJvcnNNb2NrKCkge1xuICBjb25zb2xlLmxvZyhgY3JlYXRlUWVycm9yc01vY2sgaXMgcnVubmluZyB3aXRoIG5vbmVgKTsgLy8gbG9nZ2luZyBmdW5jdGlvbiBzdGFydCBwZXIgcmVxdWlyZW1lbnRzXG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHFlcnJvcnNNb2NrID0gZnVuY3Rpb24oLi4uYXJncykgeyAvLyBjYXB0dXJlIGFyZ3VtZW50cyBmb3IgaW5zcGVjdGlvblxuICAgICAgcmV0dXJuIGFyZ3M7IC8vIHJldHVybiBhcmd1bWVudHMgZm9yIHRlc3QgaW5zcGVjdGlvblxuICAgIH07XG4gICAgYXR0YWNoTW9ja1NwaWVzKHFlcnJvcnNNb2NrKTsgLy8gYWRkIGplc3Qgc3BpZXMgaWYgYXZhaWxhYmxlXG4gICAgY29uc29sZS5sb2coYGNyZWF0ZVFlcnJvcnNNb2NrIGlzIHJldHVybmluZyAke3FlcnJvcnNNb2NrfWApOyAvLyBsb2dnaW5nIHJldHVybiB2YWx1ZSBwZXIgcmVxdWlyZW1lbnRzXG4gICAgcmV0dXJuIHFlcnJvcnNNb2NrO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKGBjcmVhdGVRZXJyb3JzTW9jayBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApOyAvLyBlcnJvciBsb2dnaW5nIHBlciByZXF1aXJlbWVudHNcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtb2NrIEhUVFAgYWRhcHRlciBmb3IgYXhpb3MgdGVzdGluZ1xuICogXG4gKiBUaGlzIHByb3ZpZGVzIGEgc2ltcGxlIEhUVFAgbW9jayB3aXRob3V0IGV4dGVybmFsIGRlcGVuZGVuY2llcyBsaWtlXG4gKiBheGlvcy1tb2NrLWFkYXB0ZXIuIEl0IGltcGxlbWVudHMgdGhlIG1pbmltdW0gaW50ZXJmYWNlIG5lZWRlZCBmb3JcbiAqIGJhc2ljIEhUVFAgdGVzdGluZyBzY2VuYXJpb3MuXG4gKiBcbiAqIERlc2lnbiBkZWNpc2lvbnM6XG4gKiAtIFNlbGYtY29udGFpbmVkOiBubyBleHRlcm5hbCBtb2NraW5nIGxpYnJhcnkgZGVwZW5kZW5jaWVzXG4gKiAtIFNpbXBsZSBpbnRlcmZhY2U6IGNvdmVycyBjb21tb24gR0VUL1BPU1Qgc2NlbmFyaW9zXG4gKiAtIFN0YXRlZnVsOiBzdG9yZXMgcmVwbHkgY29uZmlndXJhdGlvbnMgZm9yIGxhdGVyIHVzZVxuICogLSBSZXNldHRhYmxlOiBjYW4gY2xlYXIgc3RhdGUgYmV0d2VlbiB0ZXN0c1xuICogXG4gKiBXaHkgbm90IHVzZSBheGlvcy1tb2NrLWFkYXB0ZXI6XG4gKiAtIFJlZHVjZXMgZGVwZW5kZW5jaWVzIGZvciB0aGUgcXRlc3RzIG1vZHVsZVxuICogLSBTaW1wbGVyIGltcGxlbWVudGF0aW9uIGZvciBiYXNpYyB1c2UgY2FzZXNcbiAqIC0gTW9yZSBwcmVkaWN0YWJsZSBiZWhhdmlvciBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzXG4gKiBcbiAqIEByZXR1cm5zIHtPYmplY3R9IE1vY2sgYWRhcHRlciB3aXRoIG9uR2V0LCBvblBvc3QsIGFuZCByZXNldCBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUF4aW9zTW9jaygpIHtcbiAgcmV0dXJuIG1ha2VMb2dnZWRNb2NrKCdjcmVhdGVBeGlvc01vY2snLCAoKSA9PiB7IC8vKGxvZyBhbmQgc3B5IGhlbHBlcilcbiAgICBjb25zdCBtb2NrID0geyAvL2RlY2xhcmUgbW9jayBiZWZvcmUgYmluZGVyIHNvIGJpbmRlciBjYW4gcmVmZXJlbmNlIGl0XG4gICAgICAvKipcbiAgICAgICAqIENvbmZpZ3VyZSBtb2NrIHJlc3BvbnNlIGZvciBHRVQgcmVxdWVzdHMgdG8gYSBzcGVjaWZpYyBVUkxcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBVUkwgdG8gbW9ja1xuICAgICAgICogQHJldHVybnMge09iamVjdH0gUmVwbHkgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAqL1xuICAgIG9uR2V0OiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZXBseUJpbmRlcih1cmwpOyAvL2RlbGVnYXRlIHRvIHJlcGx5IGJpbmRlclxuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIG1vY2sgcmVzcG9uc2UgZm9yIFBPU1QgcmVxdWVzdHMgdG8gYSBzcGVjaWZpYyBVUkxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIHRvIG1vY2tcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXBseSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIG9uUG9zdDogZnVuY3Rpb24odXJsKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVwbHlCaW5kZXIodXJsKTsgLy91c2UgY29tbW9uIGJpbmRlciBmb3IgcG9zdFxuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogUmVzZXQgYWxsIGNvbmZpZ3VyZWQgbW9ja3NcbiAgICAgKiBFc3NlbnRpYWwgZm9yIHByZXZlbnRpbmcgdGVzdCBwb2xsdXRpb25cbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICBtb2NrLl9yZXBsaWVzID0ge307IC8vIChjbGVhciBzdG9yZWQgcmVwbGllcyBvbiBhZGFwdGVyKVxuICAgIH1cbiAgfTtcbiAgICBtb2NrLl9yZXBsaWVzID0ge307IC8vIChpbml0aWFsaXplIHJlcGx5IHN0b3JlIGZvciBhZGFwdGVyKVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcGx5QmluZGVyKHVybCl7IC8vaGVscGVyIGFmdGVyIG1vY2sgZXhpc3RzIHRvIGF2b2lkIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgIHJldHVybiB7IC8vcmV0dXJuIG9iamVjdCB3aXRoIHJlcGx5IG1ldGhvZFxuICAgICAgICByZXBseTogZnVuY3Rpb24oc3RhdHVzLCBkYXRhKXsgLy9zdG9yZSBzdGF0dXMgYW5kIGRhdGEgZm9yIHVybFxuICAgICAgICAgIG1vY2suX3JlcGxpZXNbdXJsXSA9IHsgc3RhdHVzLCBkYXRhIH07IC8vIChiaW5kIHJlc3BvbnNlIHRvIHVybClcbiAgICAgICAgICByZXR1cm4gbW9jazsgLy8gKGFsbG93IGNoYWluaW5nKVxuICAgICAgICB9XG4gICAgICB9OyAvL2Nsb3NlIHJldHVybmVkIG9iamVjdFxuICAgIH1cbiAgICByZXR1cm4gbW9jazsgLy8gKHJldHVybmVkIHRvIGhlbHBlciBmb3Igc3BpZXMpXG4gIH0pO1xufVxuXG4vKipcbiAqIFJlc2V0cyBhbGwgcHJvdmlkZWQgbW9ja3MgdG8gY2xlYW4gc3RhdGVcbiAqIFxuICogVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIHByb3ZpZGVzIGEgY2VudHJhbGl6ZWQgd2F5IHRvIHJlc2V0IG11bHRpcGxlXG4gKiBtb2NrcyBhdCBvbmNlLiBFc3NlbnRpYWwgZm9yIHRlc3QgY2xlYW51cCBhbmQgcHJldmVudGluZyBpbnRlcmZlcmVuY2VcbiAqIGJldHdlZW4gdGVzdCBjYXNlcy5cbiAqIFxuICogRGVmZW5zaXZlIHByb2dyYW1taW5nIGFwcHJvYWNoOlxuICogLSBDaGVja3MgZm9yIG1ldGhvZCBleGlzdGVuY2UgYmVmb3JlIGNhbGxpbmdcbiAqIC0gSGFuZGxlcyBkaWZmZXJlbnQgbW9jayB0eXBlcyBncmFjZWZ1bGx5XG4gKiAtIFdvbid0IHRocm93IGVycm9ycyBpZiBtb2NrcyBhcmUgdW5kZWZpbmVkIG9yIGluY29tcGxldGVcbiAqIFxuICogV2h5IGNlbnRyYWxpemVkIHJlc2V0OlxuICogLSBSZWR1Y2VzIGJvaWxlcnBsYXRlIGluIHRlc3QgdGVhcmRvd25cbiAqIC0gRW5zdXJlcyBjb25zaXN0ZW50IGNsZWFudXAgcGF0dGVybnNcbiAqIC0gRWFzaWVyIHRvIG1haW50YWluIHdoZW4gbW9jayBpbnRlcmZhY2VzIGNoYW5nZVxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gbW9jayAtIEhUVFAgbW9jayBhZGFwdGVyIHdpdGggcmVzZXQgbWV0aG9kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzY2hlZHVsZU1vY2sgLSBTY2hlZHVsZXIgbW9jayB3aXRoIEplc3QgbWV0aG9kc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcWVycm9yc01vY2sgLSBFcnJvciBoYW5kbGVyIG1vY2sgd2l0aCBKZXN0IG1ldGhvZHNcbiAqIEByZXR1cm5zIHtib29sZWFufSBBbHdheXMgcmV0dXJucyB0cnVlIHRvIGNvbmZpcm0gcmVzZXQgY29tcGxldGlvblxuICovXG5mdW5jdGlvbiByZXNldE1vY2tzKG1vY2ssIHNjaGVkdWxlTW9jaywgcWVycm9yc01vY2spIHtcbiAgcmV0dXJuIGV4ZWN1dGVXaXRoTG9ncygncmVzZXRNb2NrcycsICgpID0+IHsgLy8od3JhcCBtb2NrIHJlc2V0cyBpbiBsb2dnZXIpXG4gICAgaWYgKG1vY2sgJiYgbW9jay5yZXNldCkge1xuICAgICAgbW9jay5yZXNldCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVNb2NrICYmIHNjaGVkdWxlTW9jay5tb2NrQ2xlYXIpIHtcbiAgICAgIHNjaGVkdWxlTW9jay5tb2NrQ2xlYXIoKTtcbiAgICB9XG4gICAgaWYgKHFlcnJvcnNNb2NrICYmIHFlcnJvcnNNb2NrLm1vY2tDbGVhcikge1xuICAgICAgcWVycm9yc01vY2subW9ja0NsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvLyhjb25maXJtIGNvbXBsZXRpb24pXG4gIH0sICdtb2NrcycpO1xufVxuXG4vKipcbiAqIE9uZS1zdG9wIGluaXRpYWxpemF0aW9uIGZvciBzZWFyY2gvQVBJIHRlc3Rpbmcgc2NlbmFyaW9zXG4gKiBcbiAqIFRoaXMgY29udmVuaWVuY2UgZnVuY3Rpb24gc2V0cyB1cCBhIGNvbXBsZXRlIHRlc3QgZW52aXJvbm1lbnQgZm9yXG4gKiBhcHBsaWNhdGlvbnMgdGhhdCBtYWtlIEhUVFAgcmVxdWVzdHMgYW5kIHVzZSBzY2hlZHVsaW5nL2Vycm9yIGhhbmRsaW5nLlxuICogSXQgY29tYmluZXMgbXVsdGlwbGUgc2V0dXAgc3RlcHMgaW50byBhIHNpbmdsZSBjYWxsLlxuICogXG4gKiBXaGF0IGl0IHByb3ZpZGVzOlxuICogLSBDbGVhbiBtb2R1bGUgc3RhdGUgKEplc3QgbW9kdWxlIHJlc2V0KVxuICogLSBUZXN0IGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogLSBBbGwgY29tbW9uIG1vY2tzIGNvbmZpZ3VyZWQgYW5kIHJlYWR5XG4gKiBcbiAqIFVzZSBjYXNlOlxuICogLSBJbnRlZ3JhdGlvbiB0ZXN0cyBmb3Igc2VhcmNoIEFQSXNcbiAqIC0gVGVzdGluZyBhcHBsaWNhdGlvbnMgd2l0aCBtdWx0aXBsZSBleHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqIC0gU2NlbmFyaW9zIHdoZXJlIHlvdSBuZWVkIGZ1bGwgZW52aXJvbm1lbnQgY29udHJvbFxuICogXG4gKiBXaHkgY29tYmluZSB0aGVzZSBzcGVjaWZpYyBlbGVtZW50czpcbiAqIC0gQ29tbW9uIHBhdHRlcm4gaW4gQVBJIHRlc3RpbmdcbiAqIC0gUmVkdWNlcyB0ZXN0IHNldHVwIGJvaWxlcnBsYXRlXG4gKiAtIEVuc3VyZXMgY29uc2lzdGVudCB0ZXN0IGVudmlyb25tZW50XG4gKiBcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIGFsbCBjcmVhdGVkIG1vY2tzIGZvciBpbmRpdmlkdWFsIGNvbnRyb2xcbiAqL1xuZnVuY3Rpb24gaW5pdFNlYXJjaFRlc3QoKSB7XG4gIHJldHVybiBleGVjdXRlV2l0aExvZ3MoJ2luaXRTZWFyY2hUZXN0JywgKCkgPT4geyAvLyh3cmFwIGZ1bGwgaW5pdCBpbiBsb2dnZXIpXG4gICAgaWYgKHR5cGVvZiBqZXN0ICE9PSAndW5kZWZpbmVkJyAmJiBqZXN0LnJlc2V0TW9kdWxlcykge1xuICAgICAgamVzdC5yZXNldE1vZHVsZXMoKTtcbiAgICB9XG4gICAgc2V0VGVzdEVudigpO1xuICAgIGNvbnN0IHNjaGVkdWxlTW9jayA9IGNyZWF0ZVNjaGVkdWxlTW9jaygpO1xuICAgIGNvbnN0IHFlcnJvcnNNb2NrID0gY3JlYXRlUWVycm9yc01vY2soKTtcbiAgICBjb25zdCBtb2NrID0gY3JlYXRlQXhpb3NNb2NrKCk7XG4gICAgcmV0dXJuIHsgbW9jaywgc2NoZWR1bGVNb2NrLCBxZXJyb3JzTW9jayB9OyAvLyAocHJvdmlkZSBtb2NrcylcbiAgfSwgJ25vbmUnKTtcbn1cblxuLy8gZXhwb3J0IGFsbCB0ZXN0IGVudmlyb25tZW50IGZ1bmN0aW9ucyBhdCBib3R0b20gcGVyIHJlcXVpcmVtZW50c1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmF1bHRFbnYsIC8vIGRlZmF1bHQgdGVzdCBlbnZpcm9ubWVudCB2YWx1ZXNcbiAgc2V0VGVzdEVudiwgLy8gc2V0IHN0YW5kYXJkIHRlc3QgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gIHNhdmVFbnYsIC8vIGNhcHR1cmUgY3VycmVudCBlbnZpcm9ubWVudCBmb3IgcmVzdG9yYXRpb25cbiAgcmVzdG9yZUVudiwgLy8gcmVzdG9yZSBwcmV2aW91c2x5IHNhdmVkIGVudmlyb25tZW50XG4gIGF0dGFjaE1vY2tTcGllcywgLy8gYXR0YWNoIGplc3Qgc3B5IGhlbHBlcnMgdG8gbW9ja3NcbiAgbWFrZUxvZ2dlZE1vY2ssIC8vIGZhY3RvcnkgZm9yIGNyZWF0aW5nIGxvZ2dlZCBtb2Nrc1xuICBjcmVhdGVTY2hlZHVsZU1vY2ssIC8vIGNyZWF0ZSBzY2hlZHVsZXIvdGhyb3R0bGluZyBtb2NrXG4gIGNyZWF0ZVFlcnJvcnNNb2NrLCAvLyBjcmVhdGUgZXJyb3IgaGFuZGxlciBtb2NrXG4gIGNyZWF0ZUF4aW9zTW9jaywgLy8gY3JlYXRlIGh0dHAgY2xpZW50IG1vY2sgYWRhcHRlclxuICByZXNldE1vY2tzLCAvLyByZXNldCBtdWx0aXBsZSBtb2NrcyBhdCBvbmNlXG4gIGluaXRTZWFyY2hUZXN0IC8vIGNvbXBsZXRlIHNldHVwIGZvciBzZWFyY2gvYXBpIHRlc3Rpbmdcbn07XG4iXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtFQUFFQSxRQUFRO0VBQUVDLFNBQVM7RUFBRUMsZUFBZTtFQUFFQztBQUFXLENBQUMsR0FBR0MsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztBQUN6RixJQUFJQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLE1BQU0sRUFBRUosVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7O0FBRXhELE1BQU1LLFVBQVUsR0FBRztFQUFFO0VBQ25CQyxjQUFjLEVBQUUsS0FBSztFQUFFO0VBQ3ZCQyxTQUFTLEVBQUUsSUFBSTtFQUFFO0VBQ2pCQyxZQUFZLEVBQUUsT0FBTyxDQUFDO0FBQ3hCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxVQUFVQSxDQUFBLEVBQUc7RUFDcEJDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDJDQUEyQyxDQUFDLENBQUMsQ0FBQzs7RUFFMUQsSUFBSTtJQUNGO0lBQ0E7SUFDQTtJQUNBO0lBQ0FDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDWCxPQUFPLENBQUND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