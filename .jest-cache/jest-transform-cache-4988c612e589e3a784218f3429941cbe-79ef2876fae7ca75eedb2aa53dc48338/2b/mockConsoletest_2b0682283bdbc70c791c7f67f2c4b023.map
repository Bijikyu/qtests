{"file":"/home/runner/workspace/manual-tests/mockConsole.test.ts","mappings":"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","names":[],"sources":["/home/runner/workspace/manual-tests/mockConsole.test.ts"],"sourcesContent":["import { withMockConsole } from '../utils/testHelpers.js'; // import helper handling console spies\n\ntest('mockConsole captures calls and restores', async () => { // verify helper restores console\n  const recorded: any[] = []; // array for captured logs\n  await withMockConsole('log', spy => { // use helper to manage spy lifecycle\n    spy.mockImplementation((...args: any[]) => recorded.push(args)); // capture log calls\n    console.log('first'); // invoke mocked console\n    expect(spy.mock.calls.length).toBe(3); // spy tracks creation and call\n    expect(spy.mock.calls[2][0]).toBe('first'); // argument captured correctly\n  });\n  console.log('second'); // original console after helper cleanup\n  expect(recorded.length).toBe(2); // new expectation includes helper log\n});\n\ntest('mockConsole mockImplementation works', () => withMockConsole('log', spy => { // helper handles spy cleanup\n  const customOut: any[] = []; // capture overridden output\n  spy.mockImplementation((msg: any) => customOut.push(msg)); // replace console.log\n  console.log('override'); // trigger custom output\n  expect(customOut).toEqual(['override']); // custom function captured call\n  expect(spy.mock.calls.length).toBe(3); // spy tracked creation and call\n  expect(spy.mock.calls[2][0]).toBe('override'); // argument stored correctly\n}));\n\ntest('mockConsole tracks calls after reimplementation', () => withMockConsole('log', spy => { // helper manages spy between implementations\n  const firstOut: any[] = []; // capture first custom output\n  const secondOut: any[] = []; // capture second custom output\n  spy.mockImplementation((msg: any) => firstOut.push(msg)); // initial implementation\n  console.log('one'); // call using first implementation\n  spy.mockImplementation((msg: any) => secondOut.push(msg)); // change implementation\n  console.log('two'); // call using second implementation\n  expect(firstOut).toEqual(['one']); // first output captured\n  expect(secondOut).toEqual(['two']); // second output captured\n  expect(spy.mock.calls.length).toBe(4); // spy logged creation and two calls\n  expect(spy.mock.calls[2][0]).toBe('one'); // first call argument tracked\n  expect(spy.mock.calls[3][0]).toBe('two'); // second call argument tracked\n}));\n\ntest('mockRestore clears calls and resets method', async () => { // verify fallback clean up\n  const saved = (global as any).jest; // save jest reference for restoration\n  (global as any).jest = undefined; // force fallback path by removing jest\n  \n  // ES modules don't have require.cache - skip cache manipulation\n  const { mockConsole } = await import('../utils/mockConsole.js'); // dynamic import after change\n  const orig = console.log; // store original method for comparison\n  const spy = mockConsole('log'); // create manual spy using fallback\n  console.log('first'); // trigger captured call\n  expect(spy.mock.calls.length).toBe(2); // call history includes creation log\n  spy.mockRestore(); // run cleanup to restore and clear\n  console.log('second'); // ensure restored method runs without capturing\n  expect(console.log).toBe(orig); // method restored to original\n  const cleared = spy.mock.calls === null || spy.mock.calls.length === 0; // verify cleared history\n  expect(cleared).toBe(true); // array cleared or reference removed\n  (global as any).jest = saved; // restore jest global for remaining tests\n});"],"version":3}