4d138bd8e31c8a3500cda7a7eea5935b
/**
 * qtests Setup Module - Global Node.js Module Resolution Modification - TypeScript Implementation
 *
 * This module modifies Node.js's global module resolution behavior to automatically
 * substitute stub implementations for real modules during testing. It's a critical
 * piece of the qtests framework that enables seamless testing without changing
 * application code.
 *
 * Core functionality:
 * When this module is required, it patches Node.js's Module._resolveFilename method
 * to intercept require() calls and redirect them to stub implementations when
 * appropriate. This allows test code to use the same require() statements as
 * production code while getting test-appropriate implementations.
 *
 * Design philosophy:
 * - Transparent operation: Application code doesn't need to change
 * - Automatic stub resolution: No manual require() path changes needed
 * - Safe operation: Only affects specific modules, others work normally
 * - Performance conscious: Minimal overhead on module resolution
 *
 * Security and safety considerations:
 * - Only affects modules in the predefined stub registry
 * - Original Node.js behavior preserved for unlisted modules
 * - Changes are temporary and isolated to test execution
 * - No permanent modifications to Node.js installation
 * - Easy to disable by not requiring this module
 */
// Import Node.js Module constructor for accessing module resolution internals
// This gives us access to the private _resolveFilename method that controls
// how Node.js resolves module names to file paths
import Module from 'module';
import path from 'path';
import { getModuleDirname } from './utils/esm-globals.js';
// Get current directory for ES modules - lazy initialization for Jest compatibility
let moduleDirname;
function getModuleDirnameForSetup() {
    if (moduleDirname === undefined) {
        try {
            // Use eval to hide import.meta from Jest's static parser
            const importMetaUrl = (0, eval)('import.meta.url');
            moduleDirname = getModuleDirname(importMetaUrl);
        }
        catch (error) {
            // Fallback for Jest environment
            moduleDirname = process.cwd();
        }
    }
    return moduleDirname;
}
const stubsPath = path.join(getModuleDirnameForSetup(), 'stubs');
const STUB_REGISTRY = {
    axios: 'axios.js', // HTTP client library stub file name for quick lookup
    winston: 'winston.js' // logging library stub file name for quick lookup
};
// Preserve existing NODE_PATH if it exists
const currentNodePath = process.env.NODE_PATH || '';
// Determine correct path separator for current platform
const separator = process.platform === 'win32' ? ';' : ':';
// Prepend our stubs directory to NODE_PATH
process.env.NODE_PATH = stubsPath + (currentNodePath ? separator + currentNodePath : '');
// Force Node.js to recognize the updated NODE_PATH for dynamic module resolution
Module._initPaths();
// Store original Module._load function for delegation to maintain normal module loading behavior
const origLoad = Module._load;
/**
 * Enhanced Module._load replacement that handles stub substitution
 *
 * This function intercepts all module loading requests and redirects known
 * modules to their stub implementations when appropriate.
 */
Module._load = function (id, parent, isMain) {
    // Check if this module should be stubbed
    if (STUB_REGISTRY[id]) {
        const stubPath = path.join(stubsPath, STUB_REGISTRY[id]);
        try {
            // Load the stub module instead of the real one
            return origLoad.call(this, stubPath, parent, isMain);
        }
        catch (error) {
            console.log(`qtests: Failed to load stub for ${id} from ${stubPath}, falling back to original`);
            // Fall back to original module if stub loading fails
            return origLoad.call(this, id, parent, isMain);
        }
    }
    // For non-stubbed modules, use original behavior
    return origLoad.call(this, id, parent, isMain);
};
console.log('qtests: Global module resolution patching activated');
console.log(`qtests: Stub registry contains: ${Object.keys(STUB_REGISTRY).join(', ')}`);
console.log(`qtests: Stubs directory: ${stubsPath}`);
// Export setup completion indicator
export const setupComplete = true;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM7QUFFRixPQUFPLENBQUMsR0FBRyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7QUFDbkUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQ0FBbUMsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3hGLE9BQU8sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLFNBQVMsRUFBRSxDQUFDLENBQUM7QUFFckQsb0NBQW9DO0FBQ3BDLE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9zZXR1cC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHF0ZXN0cyBTZXR1cCBNb2R1bGUgLSBHbG9iYWwgTm9kZS5qcyBNb2R1bGUgUmVzb2x1dGlvbiBNb2RpZmljYXRpb24gLSBUeXBlU2NyaXB0IEltcGxlbWVudGF0aW9uXG4gKiBcbiAqIFRoaXMgbW9kdWxlIG1vZGlmaWVzIE5vZGUuanMncyBnbG9iYWwgbW9kdWxlIHJlc29sdXRpb24gYmVoYXZpb3IgdG8gYXV0b21hdGljYWxseVxuICogc3Vic3RpdHV0ZSBzdHViIGltcGxlbWVudGF0aW9ucyBmb3IgcmVhbCBtb2R1bGVzIGR1cmluZyB0ZXN0aW5nLiBJdCdzIGEgY3JpdGljYWxcbiAqIHBpZWNlIG9mIHRoZSBxdGVzdHMgZnJhbWV3b3JrIHRoYXQgZW5hYmxlcyBzZWFtbGVzcyB0ZXN0aW5nIHdpdGhvdXQgY2hhbmdpbmdcbiAqIGFwcGxpY2F0aW9uIGNvZGUuXG4gKiBcbiAqIENvcmUgZnVuY3Rpb25hbGl0eTpcbiAqIFdoZW4gdGhpcyBtb2R1bGUgaXMgcmVxdWlyZWQsIGl0IHBhdGNoZXMgTm9kZS5qcydzIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lIG1ldGhvZFxuICogdG8gaW50ZXJjZXB0IHJlcXVpcmUoKSBjYWxscyBhbmQgcmVkaXJlY3QgdGhlbSB0byBzdHViIGltcGxlbWVudGF0aW9ucyB3aGVuXG4gKiBhcHByb3ByaWF0ZS4gVGhpcyBhbGxvd3MgdGVzdCBjb2RlIHRvIHVzZSB0aGUgc2FtZSByZXF1aXJlKCkgc3RhdGVtZW50cyBhc1xuICogcHJvZHVjdGlvbiBjb2RlIHdoaWxlIGdldHRpbmcgdGVzdC1hcHByb3ByaWF0ZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBcbiAqIERlc2lnbiBwaGlsb3NvcGh5OlxuICogLSBUcmFuc3BhcmVudCBvcGVyYXRpb246IEFwcGxpY2F0aW9uIGNvZGUgZG9lc24ndCBuZWVkIHRvIGNoYW5nZVxuICogLSBBdXRvbWF0aWMgc3R1YiByZXNvbHV0aW9uOiBObyBtYW51YWwgcmVxdWlyZSgpIHBhdGggY2hhbmdlcyBuZWVkZWRcbiAqIC0gU2FmZSBvcGVyYXRpb246IE9ubHkgYWZmZWN0cyBzcGVjaWZpYyBtb2R1bGVzLCBvdGhlcnMgd29yayBub3JtYWxseVxuICogLSBQZXJmb3JtYW5jZSBjb25zY2lvdXM6IE1pbmltYWwgb3ZlcmhlYWQgb24gbW9kdWxlIHJlc29sdXRpb25cbiAqIFxuICogU2VjdXJpdHkgYW5kIHNhZmV0eSBjb25zaWRlcmF0aW9uczpcbiAqIC0gT25seSBhZmZlY3RzIG1vZHVsZXMgaW4gdGhlIHByZWRlZmluZWQgc3R1YiByZWdpc3RyeVxuICogLSBPcmlnaW5hbCBOb2RlLmpzIGJlaGF2aW9yIHByZXNlcnZlZCBmb3IgdW5saXN0ZWQgbW9kdWxlc1xuICogLSBDaGFuZ2VzIGFyZSB0ZW1wb3JhcnkgYW5kIGlzb2xhdGVkIHRvIHRlc3QgZXhlY3V0aW9uXG4gKiAtIE5vIHBlcm1hbmVudCBtb2RpZmljYXRpb25zIHRvIE5vZGUuanMgaW5zdGFsbGF0aW9uXG4gKiAtIEVhc3kgdG8gZGlzYWJsZSBieSBub3QgcmVxdWlyaW5nIHRoaXMgbW9kdWxlXG4gKi9cblxuLy8gSW1wb3J0IE5vZGUuanMgTW9kdWxlIGNvbnN0cnVjdG9yIGZvciBhY2Nlc3NpbmcgbW9kdWxlIHJlc29sdXRpb24gaW50ZXJuYWxzXG4vLyBUaGlzIGdpdmVzIHVzIGFjY2VzcyB0byB0aGUgcHJpdmF0ZSBfcmVzb2x2ZUZpbGVuYW1lIG1ldGhvZCB0aGF0IGNvbnRyb2xzXG4vLyBob3cgTm9kZS5qcyByZXNvbHZlcyBtb2R1bGUgbmFtZXMgdG8gZmlsZSBwYXRoc1xuaW1wb3J0IE1vZHVsZSBmcm9tICdtb2R1bGUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBnZXRNb2R1bGVEaXJuYW1lIH0gZnJvbSAnLi91dGlscy9lc20tZ2xvYmFscy5qcyc7XG5cbi8vIEdldCBjdXJyZW50IGRpcmVjdG9yeSBmb3IgRVMgbW9kdWxlcyAtIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yIEplc3QgY29tcGF0aWJpbGl0eVxubGV0IG1vZHVsZURpcm5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldE1vZHVsZURpcm5hbWVGb3JTZXR1cCgpOiBzdHJpbmcge1xuICBpZiAobW9kdWxlRGlybmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBldmFsIHRvIGhpZGUgaW1wb3J0Lm1ldGEgZnJvbSBKZXN0J3Mgc3RhdGljIHBhcnNlclxuICAgICAgY29uc3QgaW1wb3J0TWV0YVVybCA9ICgwLCBldmFsKSgnaW1wb3J0Lm1ldGEudXJsJyk7XG4gICAgICBtb2R1bGVEaXJuYW1lID0gZ2V0TW9kdWxlRGlybmFtZShpbXBvcnRNZXRhVXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRmFsbGJhY2sgZm9yIEplc3QgZW52aXJvbm1lbnRcbiAgICAgIG1vZHVsZURpcm5hbWUgPSBwcm9jZXNzLmN3ZCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kdWxlRGlybmFtZTtcbn1cblxuY29uc3Qgc3R1YnNQYXRoID0gcGF0aC5qb2luKGdldE1vZHVsZURpcm5hbWVGb3JTZXR1cCgpLCAnc3R1YnMnKTtcblxuLyoqXG4gKiBNb2R1bGUgc3R1YiByZWdpc3RyeSAtIGRlZmluZXMgd2hpY2ggbW9kdWxlcyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBzdHVic1xuICogXG4gKiBUaGlzIG9iamVjdCBtYXBzIHJlYWwgbW9kdWxlIG5hbWVzIHRvIHRoZWlyIHN0dWIgaW1wbGVtZW50YXRpb24gcGF0aHMuXG4gKiBXaGVuIE5vZGUuanMgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBhIG1vZHVsZSBsaXN0ZWQgaW4gdGhpcyByZWdpc3RyeSxcbiAqIHRoZSBzdHViIHBhdGggd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIHRoZSByZWFsIG1vZHVsZSBwYXRoLlxuICovXG5pbnRlcmZhY2UgU3R1YlJlZ2lzdHJ5IHtcbiAgW21vZHVsZU5hbWU6IHN0cmluZ106IHN0cmluZztcbn1cblxuY29uc3QgU1RVQl9SRUdJU1RSWTogU3R1YlJlZ2lzdHJ5ID0ge1xuICBheGlvczogJ2F4aW9zLmpzJywgLy8gSFRUUCBjbGllbnQgbGlicmFyeSBzdHViIGZpbGUgbmFtZSBmb3IgcXVpY2sgbG9va3VwXG4gIHdpbnN0b246ICd3aW5zdG9uLmpzJyAvLyBsb2dnaW5nIGxpYnJhcnkgc3R1YiBmaWxlIG5hbWUgZm9yIHF1aWNrIGxvb2t1cFxufTtcblxuLy8gUHJlc2VydmUgZXhpc3RpbmcgTk9ERV9QQVRIIGlmIGl0IGV4aXN0c1xuY29uc3QgY3VycmVudE5vZGVQYXRoID0gcHJvY2Vzcy5lbnYuTk9ERV9QQVRIIHx8ICcnO1xuXG4vLyBEZXRlcm1pbmUgY29ycmVjdCBwYXRoIHNlcGFyYXRvciBmb3IgY3VycmVudCBwbGF0Zm9ybVxuY29uc3Qgc2VwYXJhdG9yID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6JztcblxuLy8gUHJlcGVuZCBvdXIgc3R1YnMgZGlyZWN0b3J5IHRvIE5PREVfUEFUSFxucHJvY2Vzcy5lbnYuTk9ERV9QQVRIID0gc3R1YnNQYXRoICsgKGN1cnJlbnROb2RlUGF0aCA/IHNlcGFyYXRvciArIGN1cnJlbnROb2RlUGF0aCA6ICcnKTtcblxuLy8gRm9yY2UgTm9kZS5qcyB0byByZWNvZ25pemUgdGhlIHVwZGF0ZWQgTk9ERV9QQVRIIGZvciBkeW5hbWljIG1vZHVsZSByZXNvbHV0aW9uXG4oTW9kdWxlIGFzIGFueSkuX2luaXRQYXRocygpO1xuXG4vLyBTdG9yZSBvcmlnaW5hbCBNb2R1bGUuX2xvYWQgZnVuY3Rpb24gZm9yIGRlbGVnYXRpb24gdG8gbWFpbnRhaW4gbm9ybWFsIG1vZHVsZSBsb2FkaW5nIGJlaGF2aW9yXG5jb25zdCBvcmlnTG9hZCA9IChNb2R1bGUgYXMgYW55KS5fbG9hZDtcblxuLyoqXG4gKiBFbmhhbmNlZCBNb2R1bGUuX2xvYWQgcmVwbGFjZW1lbnQgdGhhdCBoYW5kbGVzIHN0dWIgc3Vic3RpdHV0aW9uXG4gKiBcbiAqIFRoaXMgZnVuY3Rpb24gaW50ZXJjZXB0cyBhbGwgbW9kdWxlIGxvYWRpbmcgcmVxdWVzdHMgYW5kIHJlZGlyZWN0cyBrbm93blxuICogbW9kdWxlcyB0byB0aGVpciBzdHViIGltcGxlbWVudGF0aW9ucyB3aGVuIGFwcHJvcHJpYXRlLlxuICovXG4oTW9kdWxlIGFzIGFueSkuX2xvYWQgPSBmdW5jdGlvbihpZDogc3RyaW5nLCBwYXJlbnQ6IGFueSwgaXNNYWluPzogYm9vbGVhbik6IGFueSB7XG4gIC8vIENoZWNrIGlmIHRoaXMgbW9kdWxlIHNob3VsZCBiZSBzdHViYmVkXG4gIGlmIChTVFVCX1JFR0lTVFJZW2lkXSkge1xuICAgIGNvbnN0IHN0dWJQYXRoID0gcGF0aC5qb2luKHN0dWJzUGF0aCwgU1RVQl9SRUdJU1RSWVtpZF0pO1xuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIHRoZSBzdHViIG1vZHVsZSBpbnN0ZWFkIG9mIHRoZSByZWFsIG9uZVxuICAgICAgcmV0dXJuIG9yaWdMb2FkLmNhbGwodGhpcywgc3R1YlBhdGgsIHBhcmVudCwgaXNNYWluKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYHF0ZXN0czogRmFpbGVkIHRvIGxvYWQgc3R1YiBmb3IgJHtpZH0gZnJvbSAke3N0dWJQYXRofSwgZmFsbGluZyBiYWNrIHRvIG9yaWdpbmFsYCk7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gb3JpZ2luYWwgbW9kdWxlIGlmIHN0dWIgbG9hZGluZyBmYWlsc1xuICAgICAgcmV0dXJuIG9yaWdMb2FkLmNhbGwodGhpcywgaWQsIHBhcmVudCwgaXNNYWluKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZvciBub24tc3R1YmJlZCBtb2R1bGVzLCB1c2Ugb3JpZ2luYWwgYmVoYXZpb3JcbiAgcmV0dXJuIG9yaWdMb2FkLmNhbGwodGhpcywgaWQsIHBhcmVudCwgaXNNYWluKTtcbn07XG5cbmNvbnNvbGUubG9nKCdxdGVzdHM6IEdsb2JhbCBtb2R1bGUgcmVzb2x1dGlvbiBwYXRjaGluZyBhY3RpdmF0ZWQnKTtcbmNvbnNvbGUubG9nKGBxdGVzdHM6IFN0dWIgcmVnaXN0cnkgY29udGFpbnM6ICR7T2JqZWN0LmtleXMoU1RVQl9SRUdJU1RSWSkuam9pbignLCAnKX1gKTtcbmNvbnNvbGUubG9nKGBxdGVzdHM6IFN0dWJzIGRpcmVjdG9yeTogJHtzdHVic1BhdGh9YCk7XG5cbi8vIEV4cG9ydCBzZXR1cCBjb21wbGV0aW9uIGluZGljYXRvclxuZXhwb3J0IGNvbnN0IHNldHVwQ29tcGxldGUgPSB0cnVlOyJdLCJ2ZXJzaW9uIjozfQ==