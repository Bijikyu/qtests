{"file":"/home/runner/workspace/utils/mockConsole.ts","mappings":";AAAA;;;;GAIG;;AAoBH,kCA0CC;AA7CD;;GAEG;AACH,SAAgB,WAAW,CAAC,MAAqB;IAC/C,OAAO,CAAC,GAAG,CAAC,+BAA+B,MAAM,EAAE,CAAC,CAAC;IAErD,IAAI,CAAC;QACH,yDAAyD;QACzD,8DAA8D;QAC9D,MAAM,CAAC,GAAS,UAAwC,CAAC,IAAI,CAAC;QAC9D,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC,EAAE,KAAK,UAAU,IAAI,OAAO,CAAC,CAAC,KAAK,KAAK,UAAU,EAAE,CAAC;YACrE,MAAM,OAAO,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,kBAAkB,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;YACtE,OAAO,CAAC,GAAG,CAAC,4BAA4B,OAAO,EAAE,CAAC,CAAC;YACnD,OAAO,OAAkB,CAAC;QAC5B,CAAC;QAED,0CAA0C;QAC1C,IAAI,cAAc,GAA6B,OAAO,CAAC,MAAM,CAAU,CAAC;QACxE,IAAI,KAAK,GAAY,EAAE,CAAC;QAExB,qCAAqC;QACrC,OAAO,CAAC,MAAM,CAAC,GAAG,UAAU,GAAG,IAAW;YACxC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnB,CAAU,CAAC;QAEX,MAAM,UAAU,GAAiB;YAC/B,IAAI,EAAE,EAAE,KAAK,EAAE;YACf,WAAW,EAAE;gBACX,OAAO,CAAC,MAAM,CAAC,GAAG,cAAuB,CAAC;gBAC1C,IAAI,KAAK;oBAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;gBAC5B,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;gBACvB,6BAA6B;gBAC7B,8DAA8D;gBAC9D,cAAc,GAAG,IAAW,CAAC;gBAC7B,8DAA8D;gBAC9D,KAAK,GAAG,IAAW,CAAC;YACtB,CAAC;SACF,CAAC;QAEF,OAAO,CAAC,GAAG,CAAC,4BAA4B,UAAU,EAAE,CAAC,CAAC;QACtD,OAAO,UAAU,CAAC;IACpB,CAAC;IAAC,OAAO,KAAU,EAAE,CAAC;QACpB,OAAO,CAAC,GAAG,CAAC,sBAAsB,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QACnD,MAAM,KAAK,CAAC;IACd,CAAC;AACH,CAAC;AAED,kBAAe,WAAW,CAAC","names":[],"sources":["/home/runner/workspace/utils/mockConsole.ts"],"sourcesContent":["/**\n * Console Mocking Utilities - TypeScript Implementation\n *\n * Provides console output capture for tests without polluting output.\n */\n\n// Type alias for supported console method names\ntype ConsoleMethod = 'log' | 'error' | 'warn' | 'info' | 'debug';\n\n// Minimal Jest spy interface subset we rely on\ninterface JestSpy<TArgs extends any[] = any[]> {\n  mock: { calls: TArgs[] };\n  mockRestore: () => void;\n}\n\n// Fallback mock object interface when Jest is not available\ninterface FallbackMock<TArgs extends any[] = any[]> {\n  mock: { calls: TArgs[] | null };\n  mockRestore: () => void;\n}\n\n/**\n * Create a mock console method that captures calls without output.\n */\nexport function mockConsole(method: ConsoleMethod): JestSpy | FallbackMock {\n  console.log(`mockConsole is running with ${method}`);\n\n  try {\n    // Prefer Jest spies when available for richer assertions\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const j: any = (globalThis as unknown as { jest?: any }).jest;\n    if (j && typeof j.fn === 'function' && typeof j.spyOn === 'function') {\n      const jestSpy = j.spyOn(console, method).mockImplementation(() => {});\n      console.log(`mockConsole is returning ${jestSpy}`);\n      return jestSpy as JestSpy;\n    }\n\n    // Fallback: manual capture without output\n    let originalMethod: (...args: any[]) => void = console[method] as never;\n    let calls: any[][] = [];\n\n    // Replace method with capturing stub\n    console[method] = function (...args: any[]) {\n      calls.push(args);\n    } as never;\n\n    const mockObject: FallbackMock = {\n      mock: { calls },\n      mockRestore: function () {\n        console[method] = originalMethod as never;\n        if (calls) calls.length = 0;\n        this.mock.calls = null;\n        // Drop references to help GC\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        originalMethod = null as any;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        calls = null as any;\n      }\n    };\n\n    console.log(`mockConsole is returning ${mockObject}`);\n    return mockObject;\n  } catch (error: any) {\n    console.log(`mockConsole error: ${error.message}`);\n    throw error;\n  }\n}\n\nexport default mockConsole;\n\n"],"version":3}