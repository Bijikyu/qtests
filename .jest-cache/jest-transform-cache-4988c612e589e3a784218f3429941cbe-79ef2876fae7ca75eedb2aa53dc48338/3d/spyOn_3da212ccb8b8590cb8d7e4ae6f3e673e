9c89bce63b5313156b4a4cf27321b71a
"use strict";
/**
 * Spy Functions - Method Replacement and Monitoring
 *
 * This module provides the ability to spy on existing object methods,
 * replacing them temporarily while tracking calls and providing restoration.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.spyOn = spyOn;
exports.restoreAllSpies = restoreAllSpies;
exports.restoreAllSpiesGlobally = restoreAllSpiesGlobally;
exports.spyOnWithGlobalTracking = spyOnWithGlobalTracking;
const mockFunction_js_1 = require("./mockFunction.js");
// Registry to track all active spies for cleanup
const activeSpies = new WeakMap();
/**
 * Create a spy on an object method
 * Replaces the method with a mock while preserving the original for restoration
 */
function spyOn(object, methodName) {
    const originalMethod = object[methodName];
    // Validate that we're spying on a function
    if (typeof originalMethod !== 'function') {
        throw new Error(`Cannot spy on property '${String(methodName)}' because it is not a function; received ${typeof originalMethod}`);
    }
    // Create a mock function that calls the original by default
    const mockFn = (0, mockFunction_js_1.fn)(function (...args) {
        return originalMethod.apply(this, args);
    });
    // Store original method for restoration
    if (!activeSpies.has(object)) {
        activeSpies.set(object, new Map());
    }
    const objectSpies = activeSpies.get(object);
    objectSpies.set(methodName, originalMethod);
    // Replace the method on the object
    object[methodName] = mockFn;
    // Create spy interface with restore capability
    const spy = Object.assign(mockFn, {
        mockRestore() {
            // Restore the original method
            object[methodName] = originalMethod;
            // Remove from active spies registry
            const objectSpies = activeSpies.get(object);
            if (objectSpies) {
                objectSpies.delete(methodName);
                if (objectSpies.size === 0) {
                    activeSpies.delete(object);
                }
            }
        }
    });
    return spy;
}
/**
 * Restore all spies on an object
 * Useful for cleanup in test teardown
 */
function restoreAllSpies(object) {
    const objectSpies = activeSpies.get(object);
    if (!objectSpies)
        return;
    for (const [methodName, originalMethod] of objectSpies.entries()) {
        object[methodName] = originalMethod;
    }
    activeSpies.delete(object);
}
/**
 * Restore all active spies across all objects
 * Useful for global test cleanup
 */
function restoreAllSpiesGlobally() {
    // We need to collect all objects first since restoring will modify the WeakMap
    const objectsToRestore = [];
    // Note: WeakMap doesn't have iteration, so we maintain a separate registry
    // This is a limitation - we'll track objects in a separate Set for cleanup
    globalSpyRegistry.forEach((spyMap, object) => {
        for (const [methodName, originalMethod] of spyMap.entries()) {
            object[methodName] = originalMethod;
        }
    });
    globalSpyRegistry.clear();
}
// Separate global registry for cleanup (since WeakMap isn't iterable)
const globalSpyRegistry = new Map();
/**
 * Enhanced spyOn that also registers in global cleanup registry
 */
function spyOnWithGlobalTracking(object, methodName) {
    const spy = spyOn(object, methodName);
    // Also register in global registry for cleanup
    if (!globalSpyRegistry.has(object)) {
        globalSpyRegistry.set(object, new Map());
    }
    const objectSpies = globalSpyRegistry.get(object);
    objectSpies.set(methodName, object[methodName]);
    // Override restore to also clean up global registry
    const originalRestore = spy.mockRestore;
    spy.mockRestore = function () {
        originalRestore.call(this);
        // Clean up global registry
        const globalObjectSpies = globalSpyRegistry.get(object);
        if (globalObjectSpies) {
            globalObjectSpies.delete(methodName);
            if (globalObjectSpies.size === 0) {
                globalSpyRegistry.delete(object);
            }
        }
    };
    return spy;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvbW9ja3Mvc3B5T24udHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHOztBQWlCSCxzQkErQ0M7QUFNRCwwQ0FTQztBQU1ELDBEQWFDO0FBUUQsMERBNkJDO0FBcklELHVEQUFrRDtBQVFsRCxpREFBaUQ7QUFDakQsTUFBTSxXQUFXLEdBQUcsSUFBSSxPQUFPLEVBQXFDLENBQUM7QUFFckU7OztHQUdHO0FBQ0gsU0FBZ0IsS0FBSyxDQUNuQixNQUFTLEVBQ1QsVUFBYTtJQUdiLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUUxQywyQ0FBMkM7SUFDM0MsSUFBSSxPQUFPLGNBQWMsS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUN6QyxNQUFNLElBQUksS0FBSyxDQUNiLDJCQUEyQixNQUFNLENBQUMsVUFBVSxDQUFDLDRDQUE0QyxPQUFPLGNBQWMsRUFBRSxDQUNqSCxDQUFDO0lBQ0osQ0FBQztJQUVELDREQUE0RDtJQUM1RCxNQUFNLE1BQU0sR0FBRyxJQUFBLG9CQUFFLEVBQUMsVUFBb0IsR0FBRyxJQUFXO1FBQ2xELE9BQU8sY0FBYyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFFSCx3Q0FBd0M7SUFDeEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUM3QixXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUNELE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFFLENBQUM7SUFDN0MsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFFNUMsbUNBQW1DO0lBQ2xDLE1BQWMsQ0FBQyxVQUFVLENBQUMsR0FBRyxNQUFNLENBQUM7SUFFckMsK0NBQStDO0lBQy9DLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO1FBQ2hDLFdBQVc7WUFDVCw4QkFBOEI7WUFDN0IsTUFBYyxDQUFDLFVBQVUsQ0FBQyxHQUFHLGNBQWMsQ0FBQztZQUU3QyxvQ0FBb0M7WUFDcEMsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM1QyxJQUFJLFdBQVcsRUFBRSxDQUFDO2dCQUNoQixXQUFXLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUMvQixJQUFJLFdBQVcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUM7b0JBQzNCLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzdCLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztLQUNGLENBQTJCLENBQUM7SUFFN0IsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLE1BQWM7SUFDNUMsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM1QyxJQUFJLENBQUMsV0FBVztRQUFFLE9BQU87SUFFekIsS0FBSyxNQUFNLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO1FBQ2hFLE1BQWMsQ0FBQyxVQUFVLENBQUMsR0FBRyxjQUFjLENBQUM7SUFDL0MsQ0FBQztJQUVELFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLHVCQUF1QjtJQUNyQywrRUFBK0U7SUFDL0UsTUFBTSxnQkFBZ0IsR0FBYSxFQUFFLENBQUM7SUFFdEMsMkVBQTJFO0lBQzNFLDJFQUEyRTtJQUMzRSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFDM0MsS0FBSyxNQUFNLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO1lBQzNELE1BQWMsQ0FBQyxVQUFVLENBQUMsR0FBRyxjQUFjLENBQUM7UUFDL0MsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsaUJBQWlCLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDNUIsQ0FBQztBQUVELHNFQUFzRTtBQUN0RSxNQUFNLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUFxQyxDQUFDO0FBRXZFOztHQUVHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQ3JDLE1BQVMsRUFDVCxVQUFhO0lBRWIsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztJQUV0QywrQ0FBK0M7SUFDL0MsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ25DLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFDRCxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFFLENBQUM7SUFDbkQsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUcsTUFBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFFekQsb0RBQW9EO0lBQ3BELE1BQU0sZUFBZSxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUM7SUFDeEMsR0FBRyxDQUFDLFdBQVcsR0FBRztRQUNoQixlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTNCLDJCQUEyQjtRQUMzQixNQUFNLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN4RCxJQUFJLGlCQUFpQixFQUFFLENBQUM7WUFDdEIsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3JDLElBQUksaUJBQWlCLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUNqQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbkMsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDLENBQUM7SUFFRixPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvbW9ja3Mvc3B5T24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTcHkgRnVuY3Rpb25zIC0gTWV0aG9kIFJlcGxhY2VtZW50IGFuZCBNb25pdG9yaW5nXG4gKiBcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHNweSBvbiBleGlzdGluZyBvYmplY3QgbWV0aG9kcyxcbiAqIHJlcGxhY2luZyB0aGVtIHRlbXBvcmFyaWx5IHdoaWxlIHRyYWNraW5nIGNhbGxzIGFuZCBwcm92aWRpbmcgcmVzdG9yYXRpb24uXG4gKi9cblxuaW1wb3J0IHsgZm4sIHR5cGUgTW9jayB9IGZyb20gJy4vbW9ja0Z1bmN0aW9uLmpzJztcblxuLy8gU3B5IGludGVyZmFjZSBleHRlbmRzIE1vY2sgd2l0aCByZXN0b3JhdGlvbiBjYXBhYmlsaXR5XG5leHBvcnQgaW50ZXJmYWNlIFNweTxUQXJncyBleHRlbmRzIGFueVtdID0gYW55W10sIFRSZXR1cm4gPSBhbnk+IFxuICBleHRlbmRzIE1vY2s8VEFyZ3MsIFRSZXR1cm4+IHtcbiAgbW9ja1Jlc3RvcmUoKTogdm9pZDtcbn1cblxuLy8gUmVnaXN0cnkgdG8gdHJhY2sgYWxsIGFjdGl2ZSBzcGllcyBmb3IgY2xlYW51cFxuY29uc3QgYWN0aXZlU3BpZXMgPSBuZXcgV2Vha01hcDxvYmplY3QsIE1hcDxzdHJpbmcgfCBzeW1ib2wsIGFueT4+KCk7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3B5IG9uIGFuIG9iamVjdCBtZXRob2RcbiAqIFJlcGxhY2VzIHRoZSBtZXRob2Qgd2l0aCBhIG1vY2sgd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgZm9yIHJlc3RvcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHlPbjxUIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgVD4oXG4gIG9iamVjdDogVCxcbiAgbWV0aG9kTmFtZTogS1xuKTogU3B5PGFueVtdLCBhbnk+ICYgVFtLXSB7XG4gIFxuICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IG9iamVjdFttZXRob2ROYW1lXTtcbiAgXG4gIC8vIFZhbGlkYXRlIHRoYXQgd2UncmUgc3B5aW5nIG9uIGEgZnVuY3Rpb25cbiAgaWYgKHR5cGVvZiBvcmlnaW5hbE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3Qgc3B5IG9uIHByb3BlcnR5ICcke1N0cmluZyhtZXRob2ROYW1lKX0nIGJlY2F1c2UgaXQgaXMgbm90IGEgZnVuY3Rpb247IHJlY2VpdmVkICR7dHlwZW9mIG9yaWdpbmFsTWV0aG9kfWBcbiAgICApO1xuICB9XG4gIFxuICAvLyBDcmVhdGUgYSBtb2NrIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIGJ5IGRlZmF1bHRcbiAgY29uc3QgbW9ja0ZuID0gZm4oZnVuY3Rpb24odGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG4gIFxuICAvLyBTdG9yZSBvcmlnaW5hbCBtZXRob2QgZm9yIHJlc3RvcmF0aW9uXG4gIGlmICghYWN0aXZlU3BpZXMuaGFzKG9iamVjdCkpIHtcbiAgICBhY3RpdmVTcGllcy5zZXQob2JqZWN0LCBuZXcgTWFwKCkpO1xuICB9XG4gIGNvbnN0IG9iamVjdFNwaWVzID0gYWN0aXZlU3BpZXMuZ2V0KG9iamVjdCkhO1xuICBvYmplY3RTcGllcy5zZXQobWV0aG9kTmFtZSwgb3JpZ2luYWxNZXRob2QpO1xuICBcbiAgLy8gUmVwbGFjZSB0aGUgbWV0aG9kIG9uIHRoZSBvYmplY3RcbiAgKG9iamVjdCBhcyBhbnkpW21ldGhvZE5hbWVdID0gbW9ja0ZuO1xuICBcbiAgLy8gQ3JlYXRlIHNweSBpbnRlcmZhY2Ugd2l0aCByZXN0b3JlIGNhcGFiaWxpdHlcbiAgY29uc3Qgc3B5ID0gT2JqZWN0LmFzc2lnbihtb2NrRm4sIHtcbiAgICBtb2NrUmVzdG9yZSgpIHtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgKG9iamVjdCBhcyBhbnkpW21ldGhvZE5hbWVdID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGFjdGl2ZSBzcGllcyByZWdpc3RyeVxuICAgICAgY29uc3Qgb2JqZWN0U3BpZXMgPSBhY3RpdmVTcGllcy5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChvYmplY3RTcGllcykge1xuICAgICAgICBvYmplY3RTcGllcy5kZWxldGUobWV0aG9kTmFtZSk7XG4gICAgICAgIGlmIChvYmplY3RTcGllcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgYWN0aXZlU3BpZXMuZGVsZXRlKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pIGFzIFNweTxhbnlbXSwgYW55PiAmIFRbS107XG4gIFxuICByZXR1cm4gc3B5O1xufVxuXG4vKipcbiAqIFJlc3RvcmUgYWxsIHNwaWVzIG9uIGFuIG9iamVjdFxuICogVXNlZnVsIGZvciBjbGVhbnVwIGluIHRlc3QgdGVhcmRvd25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVBbGxTcGllcyhvYmplY3Q6IG9iamVjdCk6IHZvaWQge1xuICBjb25zdCBvYmplY3RTcGllcyA9IGFjdGl2ZVNwaWVzLmdldChvYmplY3QpO1xuICBpZiAoIW9iamVjdFNwaWVzKSByZXR1cm47XG4gIFxuICBmb3IgKGNvbnN0IFttZXRob2ROYW1lLCBvcmlnaW5hbE1ldGhvZF0gb2Ygb2JqZWN0U3BpZXMuZW50cmllcygpKSB7XG4gICAgKG9iamVjdCBhcyBhbnkpW21ldGhvZE5hbWVdID0gb3JpZ2luYWxNZXRob2Q7XG4gIH1cbiAgXG4gIGFjdGl2ZVNwaWVzLmRlbGV0ZShvYmplY3QpO1xufVxuXG4vKipcbiAqIFJlc3RvcmUgYWxsIGFjdGl2ZSBzcGllcyBhY3Jvc3MgYWxsIG9iamVjdHNcbiAqIFVzZWZ1bCBmb3IgZ2xvYmFsIHRlc3QgY2xlYW51cFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZUFsbFNwaWVzR2xvYmFsbHkoKTogdm9pZCB7XG4gIC8vIFdlIG5lZWQgdG8gY29sbGVjdCBhbGwgb2JqZWN0cyBmaXJzdCBzaW5jZSByZXN0b3Jpbmcgd2lsbCBtb2RpZnkgdGhlIFdlYWtNYXBcbiAgY29uc3Qgb2JqZWN0c1RvUmVzdG9yZTogb2JqZWN0W10gPSBbXTtcbiAgXG4gIC8vIE5vdGU6IFdlYWtNYXAgZG9lc24ndCBoYXZlIGl0ZXJhdGlvbiwgc28gd2UgbWFpbnRhaW4gYSBzZXBhcmF0ZSByZWdpc3RyeVxuICAvLyBUaGlzIGlzIGEgbGltaXRhdGlvbiAtIHdlJ2xsIHRyYWNrIG9iamVjdHMgaW4gYSBzZXBhcmF0ZSBTZXQgZm9yIGNsZWFudXBcbiAgZ2xvYmFsU3B5UmVnaXN0cnkuZm9yRWFjaCgoc3B5TWFwLCBvYmplY3QpID0+IHtcbiAgICBmb3IgKGNvbnN0IFttZXRob2ROYW1lLCBvcmlnaW5hbE1ldGhvZF0gb2Ygc3B5TWFwLmVudHJpZXMoKSkge1xuICAgICAgKG9iamVjdCBhcyBhbnkpW21ldGhvZE5hbWVdID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgfVxuICB9KTtcbiAgXG4gIGdsb2JhbFNweVJlZ2lzdHJ5LmNsZWFyKCk7XG59XG5cbi8vIFNlcGFyYXRlIGdsb2JhbCByZWdpc3RyeSBmb3IgY2xlYW51cCAoc2luY2UgV2Vha01hcCBpc24ndCBpdGVyYWJsZSlcbmNvbnN0IGdsb2JhbFNweVJlZ2lzdHJ5ID0gbmV3IE1hcDxvYmplY3QsIE1hcDxzdHJpbmcgfCBzeW1ib2wsIGFueT4+KCk7XG5cbi8qKlxuICogRW5oYW5jZWQgc3B5T24gdGhhdCBhbHNvIHJlZ2lzdGVycyBpbiBnbG9iYWwgY2xlYW51cCByZWdpc3RyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3B5T25XaXRoR2xvYmFsVHJhY2tpbmc8VCBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIFQ+KFxuICBvYmplY3Q6IFQsXG4gIG1ldGhvZE5hbWU6IEtcbik6IFNweTxhbnlbXSwgYW55PiAmIFRbS10ge1xuICBjb25zdCBzcHkgPSBzcHlPbihvYmplY3QsIG1ldGhvZE5hbWUpO1xuICBcbiAgLy8gQWxzbyByZWdpc3RlciBpbiBnbG9iYWwgcmVnaXN0cnkgZm9yIGNsZWFudXBcbiAgaWYgKCFnbG9iYWxTcHlSZWdpc3RyeS5oYXMob2JqZWN0KSkge1xuICAgIGdsb2JhbFNweVJlZ2lzdHJ5LnNldChvYmplY3QsIG5ldyBNYXAoKSk7XG4gIH1cbiAgY29uc3Qgb2JqZWN0U3BpZXMgPSBnbG9iYWxTcHlSZWdpc3RyeS5nZXQob2JqZWN0KSE7XG4gIG9iamVjdFNwaWVzLnNldChtZXRob2ROYW1lLCAob2JqZWN0IGFzIGFueSlbbWV0aG9kTmFtZV0pO1xuICBcbiAgLy8gT3ZlcnJpZGUgcmVzdG9yZSB0byBhbHNvIGNsZWFuIHVwIGdsb2JhbCByZWdpc3RyeVxuICBjb25zdCBvcmlnaW5hbFJlc3RvcmUgPSBzcHkubW9ja1Jlc3RvcmU7XG4gIHNweS5tb2NrUmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICAgIG9yaWdpbmFsUmVzdG9yZS5jYWxsKHRoaXMpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGdsb2JhbCByZWdpc3RyeVxuICAgIGNvbnN0IGdsb2JhbE9iamVjdFNwaWVzID0gZ2xvYmFsU3B5UmVnaXN0cnkuZ2V0KG9iamVjdCk7XG4gICAgaWYgKGdsb2JhbE9iamVjdFNwaWVzKSB7XG4gICAgICBnbG9iYWxPYmplY3RTcGllcy5kZWxldGUobWV0aG9kTmFtZSk7XG4gICAgICBpZiAoZ2xvYmFsT2JqZWN0U3BpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBnbG9iYWxTcHlSZWdpc3RyeS5kZWxldGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICByZXR1cm4gc3B5O1xufSJdLCJ2ZXJzaW9uIjozfQ==