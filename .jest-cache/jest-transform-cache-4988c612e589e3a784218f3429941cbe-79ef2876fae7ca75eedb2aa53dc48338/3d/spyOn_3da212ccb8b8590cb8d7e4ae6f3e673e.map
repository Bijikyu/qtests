{"file":"/home/runner/workspace/lib/mocks/spyOn.ts","mappings":"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","names":[],"sources":["/home/runner/workspace/lib/mocks/spyOn.ts"],"sourcesContent":["/**\n * Spy Functions - Method Replacement and Monitoring\n * \n * This module provides the ability to spy on existing object methods,\n * replacing them temporarily while tracking calls and providing restoration.\n */\n\nimport { fn, type Mock } from './mockFunction.js';\n\n// Spy interface extends Mock with restoration capability\nexport interface Spy<TArgs extends any[] = any[], TReturn = any> \n  extends Mock<TArgs, TReturn> {\n  mockRestore(): void;\n}\n\n// Registry to track all active spies for cleanup\nconst activeSpies = new WeakMap<object, Map<string | symbol, any>>();\n\n/**\n * Create a spy on an object method\n * Replaces the method with a mock while preserving the original for restoration\n */\nexport function spyOn<T extends object, K extends keyof T>(\n  object: T,\n  methodName: K\n): Spy<any[], any> & T[K] {\n  \n  const originalMethod = object[methodName];\n  \n  // Validate that we're spying on a function\n  if (typeof originalMethod !== 'function') {\n    throw new Error(\n      `Cannot spy on property '${String(methodName)}' because it is not a function; received ${typeof originalMethod}`\n    );\n  }\n  \n  // Create a mock function that calls the original by default\n  const mockFn = fn(function(this: any, ...args: any[]) {\n    return originalMethod.apply(this, args);\n  });\n  \n  // Store original method for restoration\n  if (!activeSpies.has(object)) {\n    activeSpies.set(object, new Map());\n  }\n  const objectSpies = activeSpies.get(object)!;\n  objectSpies.set(methodName, originalMethod);\n  \n  // Replace the method on the object\n  (object as any)[methodName] = mockFn;\n  \n  // Create spy interface with restore capability\n  const spy = Object.assign(mockFn, {\n    mockRestore() {\n      // Restore the original method\n      (object as any)[methodName] = originalMethod;\n      \n      // Remove from active spies registry\n      const objectSpies = activeSpies.get(object);\n      if (objectSpies) {\n        objectSpies.delete(methodName);\n        if (objectSpies.size === 0) {\n          activeSpies.delete(object);\n        }\n      }\n    }\n  }) as Spy<any[], any> & T[K];\n  \n  return spy;\n}\n\n/**\n * Restore all spies on an object\n * Useful for cleanup in test teardown\n */\nexport function restoreAllSpies(object: object): void {\n  const objectSpies = activeSpies.get(object);\n  if (!objectSpies) return;\n  \n  for (const [methodName, originalMethod] of objectSpies.entries()) {\n    (object as any)[methodName] = originalMethod;\n  }\n  \n  activeSpies.delete(object);\n}\n\n/**\n * Restore all active spies across all objects\n * Useful for global test cleanup\n */\nexport function restoreAllSpiesGlobally(): void {\n  // We need to collect all objects first since restoring will modify the WeakMap\n  const objectsToRestore: object[] = [];\n  \n  // Note: WeakMap doesn't have iteration, so we maintain a separate registry\n  // This is a limitation - we'll track objects in a separate Set for cleanup\n  globalSpyRegistry.forEach((spyMap, object) => {\n    for (const [methodName, originalMethod] of spyMap.entries()) {\n      (object as any)[methodName] = originalMethod;\n    }\n  });\n  \n  globalSpyRegistry.clear();\n}\n\n// Separate global registry for cleanup (since WeakMap isn't iterable)\nconst globalSpyRegistry = new Map<object, Map<string | symbol, any>>();\n\n/**\n * Enhanced spyOn that also registers in global cleanup registry\n */\nexport function spyOnWithGlobalTracking<T extends object, K extends keyof T>(\n  object: T,\n  methodName: K\n): Spy<any[], any> & T[K] {\n  const spy = spyOn(object, methodName);\n  \n  // Also register in global registry for cleanup\n  if (!globalSpyRegistry.has(object)) {\n    globalSpyRegistry.set(object, new Map());\n  }\n  const objectSpies = globalSpyRegistry.get(object)!;\n  objectSpies.set(methodName, (object as any)[methodName]);\n  \n  // Override restore to also clean up global registry\n  const originalRestore = spy.mockRestore;\n  spy.mockRestore = function() {\n    originalRestore.call(this);\n    \n    // Clean up global registry\n    const globalObjectSpies = globalSpyRegistry.get(object);\n    if (globalObjectSpies) {\n      globalObjectSpies.delete(methodName);\n      if (globalObjectSpies.size === 0) {\n        globalSpyRegistry.delete(object);\n      }\n    }\n  };\n  \n  return spy;\n}"],"version":3}