fd72c2829fc581d1fe78cd844865d7cf
/**
 * Test Generator for qtests Framework - TypeScript Implementation
 *
 * Automatically generates unit tests and API tests by scanning source code.
 * Analyzes JavaScript/TypeScript files to detect exports, imports, and API routes,
 * then creates appropriate test files with proper structure and mocking.
 *
 * Features:
 * - Unit test generation for exported functions/classes
 * - API test generation for Express routes
 * - Automatic mock setup for known libraries
 * - Jest configuration scaffolding
 * - Support for qtests framework integration
 * - TypeScript ES module only (no version duplication)
 */
import fs from 'fs';
import path from 'path';
import { getModuleDirname } from '../utils/esm-globals.js';
// ES Module __dirname equivalent - lazy initialization to avoid Jest issues
let moduleDirname;
function getModuleDirnameForTestGenerator() {
    if (moduleDirname === undefined) {
        // Use a try-catch to handle Jest environment gracefully
        try {
            // Use eval to hide import.meta from Jest's static parser
            const importMetaUrl = (0, eval)('import.meta.url');
            moduleDirname = getModuleDirname(importMetaUrl);
        }
        catch (error) {
            // Fallback for Jest environment
            moduleDirname = process.cwd();
        }
    }
    return moduleDirname;
}
// Configuration constants - TypeScript ES module only
const DEFAULT_CONFIG = {
    SRC_DIR: '.',
    TEST_DIR: 'generated-tests',
    KNOWN_MOCKS: ['axios', 'node-fetch', 'pg', 'mongoose', 'fs', 'redis'],
    VALID_EXTS: ['.ts', '.js', '.tsx', '.jsx']
};
// Regex patterns for code analysis - Enhanced for both ES modules and CommonJS
const PATTERNS = {
    qtests: /from ['"]qtests['"]|require\(['"]qtests['"]\)/,
    api: /\b(app|router)\.(get|post|put|delete|patch)\s*\(\s*['"`]([^'"`]+)['"`]/gi,
    // ES module exports: export const, export function, export class
    exportsES: /^\s*export\s+(?:const|function|class)\s+([a-zA-Z0-9_]+)/gm,
    // ES module named exports: export { name1, name2, name3 }
    exportsNamed: /export\s*\{\s*([^}]+)\s*\}/g,
    // ES module default exports: export default SomeName
    exportsDefault: /export\s+default\s+([a-zA-Z0-9_]+)/g,
    // CommonJS exports: module.exports = {}, module.exports.name =, exports.name =
    exportsCommonJS: /(?:module\.exports\.([a-zA-Z0-9_]+)\s*=|exports\.([a-zA-Z0-9_]+)\s*=|module\.exports\s*=\s*([a-zA-Z0-9_]+))/gm,
    // Function declarations that might be exported
    functionDeclarations: /^\s*(?:async\s+)?function\s+([a-zA-Z0-9_]+)\s*\(/gm,
    // Class declarations that might be exported
    classDeclarations: /^\s*class\s+([a-zA-Z0-9_]+)/gm,
    imports: /from ['"]([^'"]+)['"]|require\(['"]([^'"]+)['"]\)/g
};
class TestGenerator {
    constructor(options = {}) {
        this.config = { ...DEFAULT_CONFIG, ...options };
        this.scanned = [];
        this.isESModule = this.detectESModule(); // Detect module type once during initialization
    }
    /**
     * Detect if the current project uses ES modules or CommonJS
     * Since we're now "TypeScript ES module only", this defaults to true for TypeScript projects
     */
    detectESModule() {
        try {
            // Check package.json for explicit "type": "module"
            const packagePath = path.resolve(process.cwd(), 'package.json');
            if (fs.existsSync(packagePath)) {
                const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
                if (packageJson.type === 'module') {
                    return true;
                }
                // For TypeScript ES module only approach, prefer ES modules when TypeScript is detected
                if (packageJson.devDependencies?.typescript || packageJson.dependencies?.typescript) {
                    return true;
                }
            }
            // Check for ES module patterns in source files (excluding test files and node_modules)
            const sourceFiles = this.walkProject()
                .filter(file => {
                const ext = path.extname(file);
                const isValidExt = this.config.VALID_EXTS.includes(ext);
                const isTestFile = this.isTestFile(path.basename(file));
                const isNodeModules = file.includes('node_modules');
                return isValidExt && !isTestFile && !isNodeModules;
            })
                .slice(0, 10); // Sample first 10 files for performance
            let esModuleCount = 0;
            let commonJSCount = 0;
            for (const file of sourceFiles) {
                try {
                    const content = fs.readFileSync(file, 'utf8');
                    // Look for ES module patterns (import OR export statements)
                    if (content.includes('import ') || content.includes('export ')) {
                        esModuleCount++;
                    }
                    // Look for CommonJS patterns
                    if (content.includes('require(') || content.includes('module.exports')) {
                        commonJSCount++;
                    }
                }
                catch (error) {
                    // Skip files we can't read
                    continue;
                }
            }
            // For TypeScript ES module only approach, prefer ES modules when equal or when TypeScript files are present
            if (esModuleCount === 0 && commonJSCount === 0) {
                return true; // Default to ES modules for TypeScript ES module only approach
            }
            if (esModuleCount === 0) {
                return false; // No ES module patterns found, default to CommonJS
            }
            return esModuleCount >= commonJSCount; // Changed from > to >= to prefer ES modules
        }
        catch (error) {
            // Default to ES modules for TypeScript ES module only approach
            return true;
        }
    }
    /**
     * Check if directory should be skipped during discovery
     */
    shouldSkipDirectory(dirName) {
        const skipPatterns = [
            'node_modules', '.git', '.next', 'dist', 'build', 'coverage',
            '.vscode', '.idea', 'docs', 'documentation', 'assets', 'public', 'static',
            '.replit_cache', '.config', '.npm', 'logs'
        ];
        return skipPatterns.includes(dirName) || dirName.startsWith('.');
    }
    /**
     * Walk entire project directory structure, respecting skip patterns
     */
    walkProject() {
        const currentDir = process.cwd();
        return this.walkRecursive(currentDir);
    }
    /**
     * Recursively walk directory and return all file paths, skipping irrelevant directories
     */
    walkRecursive(dir) {
        if (!fs.existsSync(dir)) {
            return [];
        }
        return fs.readdirSync(dir, { withFileTypes: true }).flatMap(entry => {
            const full = path.resolve(dir, entry.name);
            if (entry.isDirectory()) {
                // Skip directories that shouldn't contain tests or source files
                if (this.shouldSkipDirectory(entry.name)) {
                    return [];
                }
                return this.walkRecursive(full);
            }
            else {
                return [full];
            }
        });
    }
    /**
     * Legacy walk method for backwards compatibility (walks single directory)
     */
    walk(dir) {
        if (!fs.existsSync(dir)) {
            return [];
        }
        return fs.readdirSync(dir, { withFileTypes: true }).flatMap(entry => {
            const full = path.resolve(dir, entry.name);
            return entry.isDirectory() ? this.walk(full) : [full];
        });
    }
    /**
     * Categorize discovered files into source files and existing tests
     */
    categorizeFiles(files) {
        const sourceFiles = [];
        const existingTests = [];
        files.forEach(file => {
            const ext = path.extname(file);
            const basename = path.basename(file);
            // Skip files with invalid extensions
            if (!this.config.VALID_EXTS.includes(ext)) {
                return;
            }
            // Check if this is a test file
            if (this.isTestFile(basename)) {
                existingTests.push(file);
            }
            else {
                // Check if this source file already has a corresponding test
                const hasTest = this.hasCorrespondingTest(file, files);
                if (!hasTest) {
                    sourceFiles.push(file);
                }
            }
        });
        return { sourceFiles, existingTests };
    }
    /**
     * Check if filename indicates it's a test file
     */
    isTestFile(filename) {
        const testPatterns = [
            /\.test\./,
            /\.spec\./,
            /_test\./,
            /_spec\./,
            /\.e2e\./,
            /\.integration\./
        ];
        return testPatterns.some(pattern => pattern.test(filename));
    }
    /**
     * Check if a source file has a corresponding test file
     */
    hasCorrespondingTest(sourceFile, allFiles) {
        const dir = path.dirname(sourceFile);
        const basename = path.basename(sourceFile, path.extname(sourceFile));
        const ext = path.extname(sourceFile);
        // Common test file patterns to look for - TypeScript ES module only
        const testPatterns = [
            `${basename}.test.ts`,
            `${basename}GeneratedTest.test.ts`, // Generated unit tests  
            `${basename}.spec.ts`,
            `${basename}_test.ts`,
            `${basename}_spec.ts`,
            `${basename}.test${ext}`,
            `${basename}.spec${ext}`
        ];
        // Look for test files in the same directory
        const sameDirectoryTests = testPatterns.map(pattern => path.join(dir, pattern));
        // Look for test files in common test directories
        const testDirectories = ['tests', 'test', '__tests__', 'spec'];
        const testDirectoryTests = testDirectories.flatMap(testDir => {
            const testPath = path.join(dir, testDir);
            return testPatterns.map(pattern => path.join(testPath, pattern));
        });
        // Check if any of these test files exist
        const allTestPaths = [...sameDirectoryTests, ...testDirectoryTests];
        // Normalize paths for comparison - convert both to absolute paths
        const normalizedAllFiles = allFiles.map(file => path.resolve(file));
        const normalizedTestPaths = allTestPaths.map(testPath => path.resolve(testPath));
        return normalizedTestPaths.some(testPath => normalizedAllFiles.includes(testPath));
    }
    /**
     * Generate test file path based on source file and test type
     * TypeScript ES module only - always generates .ts test files
     */
    getRelativeTestPath(file, type = 'unit') {
        const dir = path.dirname(file);
        const basename = path.basename(file, path.extname(file));
        if (type === 'unit') {
            // For unit tests, place them alongside the source file with GeneratedTest naming
            return path.join(dir, `${basename}GeneratedTest.test.ts`);
        }
        else {
            // For API/integration tests, use the configured test directory with .ts extension
            const rel = path.relative(process.cwd(), file);
            return path.join(this.config.TEST_DIR, rel.replace(/\.[tj]sx?$/, '.test.ts').replace(/[\\/]/g, '__'));
        }
    }
    /**
     * Create directory if it doesn't exist
     */
    createDir(p) {
        const dir = path.dirname(p);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    }
    /**
     * Write file only if it doesn't already exist
     */
    writeIfMissing(p, content) {
        if (!fs.existsSync(p)) {
            this.createDir(p);
            fs.writeFileSync(p, content, 'utf8');
            return true;
        }
        return false;
    }
    /**
     * Extract imported modules from file content - Enhanced for both ES modules and CommonJS
     */
    getUsedModules(content) {
        return [...content.matchAll(PATTERNS.imports)]
            .map(m => m[1] || m[2]) // m[1] for ES modules, m[2] for CommonJS
            .filter(x => x && !x.startsWith('.') && !x.startsWith('/'));
    }
    /**
     * Generate unit test content for a file - TypeScript ES module only
     */
    createUnitTest(file, exports, usesQtests, mocks) {
        const basename = path.basename(file, path.extname(file));
        const ext = path.extname(file);
        const lines = [
            `// Lightweight unit test for ${path.basename(file)} - TypeScript ES module`,
            ``
        ];
        // TypeScript ES module imports
        if (usesQtests) {
            lines.push(`import { test, mockConsole } from 'qtests';`);
            lines.push(`// NOTE: Use mockConsole directly, avoid complex async patterns`);
        }
        // Lightweight mock setup for TypeScript
        if (mocks.length > 0) {
            lines.push(`// Lightweight mock setup - TypeScript compatible`);
            mocks.forEach(lib => {
                lines.push(`jest.mock('${lib}', () => ({`);
                lines.push(`  __esModule: true,`);
                lines.push(`  default: jest.fn(() => 'mock-${lib}'),`);
                lines.push(`}));`);
            });
            lines.push(``);
        }
        // TypeScript test suite
        lines.push(`describe('${path.basename(file)} basic exports', () => {`);
        // Single lightweight test for TypeScript ES modules
        lines.push(`  test('module loads without errors', async () => {`);
        lines.push(`    // TypeScript ES module dynamic import`);
        lines.push(`    const module = await import('./${basename}${ext}');`);
        lines.push(`    expect(module).toBeDefined();`);
        lines.push(`    expect(typeof module).toBe('object');`);
        if (exports.length > 0) {
            lines.push(`    // Check for expected exports`);
            exports.slice(0, 3).forEach(exportName => {
                lines.push(`    expect(module.${exportName}).toBeDefined();`);
            });
        }
        lines.push(`  });`);
        lines.push(`});`);
        lines.push('');
        return lines.join('\n');
    }
    /**
     * Generate API test content for an endpoint - TypeScript ES module only
     */
    createApiTest(method, route) {
        const lines = [
            `// Auto-generated API test for ${method.toUpperCase()} ${route} - TypeScript ES module`,
            `// PARALLEL-SAFE DESIGN: This test avoids race conditions`,
            ``
        ];
        // Generate unique test session for API isolation
        lines.push(`// Unique API test session for parallel execution safety`);
        lines.push(`const apiTestSession = \`\${process.hrtime.bigint()}-\${Math.random().toString(36).substr(2, 9)}\`;`);
        lines.push(`const uniqueRoute = '${route}' + ('${route}'.includes('?') ? '&' : '?') + 'testSession=' + apiTestSession;`);
        lines.push(``);
        // TypeScript ES module import
        lines.push(`import * as httpTest from '../utils/httpTest.js';`, '');
        // TypeScript test suite
        lines.push(`describe(\`${method.toUpperCase()} ${route} [API-\${apiTestSession}]\`, () => {`);
        lines.push(`  // Test data factory for unique request/response data`);
        lines.push(`  const createUniqueTestData = () => ({`);
        lines.push(`    sessionId: apiTestSession,`);
        lines.push(`    requestId: \`req-\${Date.now()}-\${Math.random().toString(36).substr(2, 6)}\`,`);
        lines.push(`    timestamp: new Date().toISOString(),`);
        lines.push(`  });`);
        lines.push(``);
        lines.push(`  test('should succeed with unique test data', async () => {`);
        lines.push(`    const testData = createUniqueTestData();`);
        lines.push(`    const app = httpTest.createMockApp();`);
        lines.push(`    `);
        lines.push(`    app.${method.toLowerCase()}(uniqueRoute, (req, res) => {`);
        lines.push(`      res.statusCode = 200;`);
        lines.push(`      res.setHeader('content-type', 'application/json');`);
        lines.push(`      res.end(JSON.stringify({ `);
        lines.push(`        success: true, `);
        lines.push(`        testSession: apiTestSession,`);
        lines.push(`        requestId: testData.requestId`);
        lines.push(`      }));`);
        lines.push(`    });`);
        lines.push(`    `);
        lines.push(`    const res = await httpTest.supertest(app)`);
        lines.push(`      .${method.toLowerCase()}(uniqueRoute)`);
        lines.push(`      .send(testData)`);
        lines.push(`      .expect(200);`);
        lines.push(`    `);
        lines.push(`    expect(res.body.success).toBe(true);`);
        lines.push(`    expect(res.body.testSession).toBe(apiTestSession);`);
        lines.push('  });');
        lines.push('});\n');
        return lines.join('\n');
    }
    /**
     * Intelligently extract exports from both ES modules and CommonJS
     */
    extractExports(content) {
        const exports = new Set();
        // Remove comments to avoid false positives
        const cleanContent = content
            .replace(/\/\*[\s\S]*?\*\//g, '') // Remove /* */ comments
            .replace(/\/\/.*$/gm, ''); // Remove // comments
        // Extract ES module exports (export const/function/class)
        const esExports = [...cleanContent.matchAll(PATTERNS.exportsES)];
        esExports.forEach(match => {
            if (match[1])
                exports.add(match[1]);
        });
        // Extract ES module named exports: export { name1, name2, name3 }
        const namedExports = [...cleanContent.matchAll(PATTERNS.exportsNamed)];
        namedExports.forEach(match => {
            if (match[1]) {
                // Parse the named exports list
                const exportList = match[1].split(',').map(name => name.trim());
                exportList.forEach(name => {
                    // Handle potential aliases: "name as alias" -> use "name"
                    const cleanName = name.split(' as ')[0].trim();
                    if (cleanName && /^[a-zA-Z0-9_]+$/.test(cleanName)) {
                        exports.add(cleanName);
                    }
                });
            }
        });
        // Extract ES module default exports: export default SomeName
        const defaultExports = [...cleanContent.matchAll(PATTERNS.exportsDefault)];
        defaultExports.forEach(match => {
            if (match[1])
                exports.add(match[1]);
        });
        // Extract CommonJS exports
        const commonJSExports = [...cleanContent.matchAll(PATTERNS.exportsCommonJS)];
        commonJSExports.forEach(match => {
            // match[1] = module.exports.name, match[2] = exports.name, match[3] = single assignment
            for (let i = 1; i <= 3; i++) {
                if (match[i])
                    exports.add(match[i]);
            }
        });
        // Handle module.exports = { name1, name2, ... } pattern
        const objectExportMatch = cleanContent.match(/module\.exports\s*=\s*\{([^}]+)\}/);
        if (objectExportMatch) {
            const objectContent = objectExportMatch[1];
            const propertyMatches = objectContent.matchAll(/\b(\w+)(?:\s*:\s*\w+)?\s*[,}]/g);
            for (const match of propertyMatches) {
                if (match[1])
                    exports.add(match[1]);
            }
        }
        return Array.from(exports).filter(name => name && name.length > 0);
    }
    /**
     * Analyze a single file and generate appropriate tests - TypeScript ES module only
     */
    analyze(file) {
        const ext = path.extname(file);
        if (!this.config.VALID_EXTS.includes(ext)) {
            return;
        }
        const content = fs.readFileSync(file, 'utf8');
        const usesQtests = PATTERNS.qtests.test(content);
        const imports = this.getUsedModules(content);
        const mockTargets = imports.filter(i => this.config.KNOWN_MOCKS.includes(i) && i !== 'qtests');
        // Use intelligent export detection for both ES modules and CommonJS
        const exports = this.extractExports(content);
        if (exports.length > 0) {
            const testPath = this.getRelativeTestPath(file, 'unit');
            const created = this.writeIfMissing(testPath, this.createUnitTest(file, exports, usesQtests, mockTargets));
            if (created) {
                this.scanned.push({
                    type: 'unit',
                    file: path.relative('.', testPath)
                });
            }
        }
        // Generate API tests for detected routes - TypeScript only
        const apis = [...content.matchAll(PATTERNS.api)];
        for (const [, , method, route] of apis) {
            const testPath = this.getRelativeTestPath(file, 'api')
                .replace(/\.test\.ts$/, `__${method.toLowerCase()}.test.ts`);
            const created = this.writeIfMissing(testPath, this.createApiTest(method, route));
            if (created) {
                this.scanned.push({
                    type: 'api',
                    file: path.relative('.', testPath)
                });
            }
        }
    }
    /**
     * Create Jest configuration and setup files - TypeScript ES Module only
     */
    scaffoldJestSetup() {
        // Generate Jest config for TypeScript ES modules
        const config = `
// jest.config.js - TypeScript ES Module configuration
export default {
  preset: 'ts-jest/presets/default-esm',
  extensionsToTreatAsEsm: ['.ts'],
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/jest-setup.ts'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  roots: ['<rootDir>'],
  testMatch: [
    '**/*.test.ts',           // Standard tests anywhere
    '**/*.GeneratedTest.test.ts', // Generated unit tests next to source files  
    '**/manual-tests/**/*.test.ts',     // Manual framework tests
    '**/generated-tests/**/*.test.ts'   // Generated integration tests
  ],
  transform: {
    '^.+\\.tsx?$': ['ts-jest', {
      useESM: true,
      isolatedModules: true
    }]
  },
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
    '^qtests/(.*)$': '<rootDir>/$1'  // Allow qtests to import from itself during testing
  }
};
`.trim();
        // Generate TypeScript ES module setup
        const setup = `
// setup.ts - TypeScript ES Module setup (PARALLEL-SAFE)
import 'jest';

// Global test configuration for TypeScript ES modules
beforeAll(() => {
  // Set test environment
  process.env.NODE_ENV = 'test';
  
  // Configure test timeouts
  jest.setTimeout(10000);
});

// Cleanup after each test to prevent interference
afterEach(() => {
  // Clear all mocks
  jest.clearAllMocks();
});
`.trim();
        this.writeIfMissing('jest.config.js', config);
        this.writeIfMissing('setup.ts', setup);
    }
    /**
     * Generate qtests test runner file - TypeScript ES module compatible
     */
    generateQtestsRunner() {
        try {
            // Read the existing qtests-runner.ts as template
            const templatePath = path.join(getModuleDirnameForTestGenerator(), '..', 'qtests-runner.ts');
            let template = '';
            if (fs.existsSync(templatePath)) {
                template = fs.readFileSync(templatePath, 'utf8');
            }
            else {
                // Fallback template for TypeScript ES modules with correct Jest configuration
                template = `
// Generated qtests runner - TypeScript ES module compatible
import { spawn } from 'child_process';
import path from 'path';

// Run tests with TypeScript support and correct Jest arguments
const args = process.argv.slice(2);
const testProcess = spawn('jest', args, {
  stdio: 'inherit',
  shell: true
});

testProcess.on('exit', (code) => {
  process.exit(code || 0);
});
`.trim();
            }
            // Always overwrite qtests-runner.ts to ensure latest functionality and TypeScript compliance
            const outputPath = path.join(process.cwd(), 'qtests-runner.ts');
            fs.writeFileSync(outputPath, template, 'utf8');
            console.log('âœ… Generated qtests-runner.ts for TypeScript ES modules');
        }
        catch (error) {
            console.error('Failed to generate qtests-runner.ts:', error.message);
        }
    }
    /**
     * Update package.json test script to use qtests-runner.ts
     */
    updatePackageJsonTestScript() {
        try {
            const packagePath = path.join(process.cwd(), 'package.json');
            if (!fs.existsSync(packagePath)) {
                console.log('âš ï¸  package.json not found, skipping test script update');
                return;
            }
            const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
            if (!packageJson.scripts) {
                packageJson.scripts = {};
            }
            packageJson.scripts.test = 'npx tsx qtests-runner.ts';
            fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2), 'utf8');
            console.log('âœ… Updated package.json test script to use qtests-runner.ts');
        }
        catch (error) {
            console.log('âš ï¸  Could not update package.json:', error.message);
        }
    }
    /**
     * Scan for files without tests and generate them - TypeScript ES module only
     */
    async generateTestFiles() {
        console.log('ðŸ” Scanning for files that need TypeScript tests...');
        const allFiles = this.walkProject();
        const { sourceFiles } = this.categorizeFiles(allFiles);
        console.log(`ðŸ“ Found ${sourceFiles.length} source files without tests`);
        if (sourceFiles.length === 0) {
            console.log('âœ… All source files already have corresponding tests');
            return;
        }
        // Generate tests for each source file
        for (const file of sourceFiles) {
            this.analyze(file);
        }
        // Always set up Jest configuration and runner to ensure they're up-to-date
        this.scaffoldJestSetup();
        this.generateQtestsRunner();
        this.updatePackageJsonTestScript();
        console.log(`ðŸ“ Generated ${this.scanned.length} TypeScript test files:`);
        this.scanned.forEach(test => {
            console.log(`   ${test.type}: ${test.file}`);
        });
    }
    /**
     * Get scan results
     */
    getResults() {
        return this.scanned;
    }
}
// Export the TestGenerator class using ES module syntax
export { TestGenerator };
export default TestGenerator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzFFLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQy9DLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0NBQ0Y7QUFFRCx3REFBd0Q7QUFDeEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxDQUFDO0FBQ3pCLGVBQWUsYUFBYSxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvbGliL3Rlc3RHZW5lcmF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0IEdlbmVyYXRvciBmb3IgcXRlc3RzIEZyYW1ld29yayAtIFR5cGVTY3JpcHQgSW1wbGVtZW50YXRpb25cbiAqIFxuICogQXV0b21hdGljYWxseSBnZW5lcmF0ZXMgdW5pdCB0ZXN0cyBhbmQgQVBJIHRlc3RzIGJ5IHNjYW5uaW5nIHNvdXJjZSBjb2RlLlxuICogQW5hbHl6ZXMgSmF2YVNjcmlwdC9UeXBlU2NyaXB0IGZpbGVzIHRvIGRldGVjdCBleHBvcnRzLCBpbXBvcnRzLCBhbmQgQVBJIHJvdXRlcyxcbiAqIHRoZW4gY3JlYXRlcyBhcHByb3ByaWF0ZSB0ZXN0IGZpbGVzIHdpdGggcHJvcGVyIHN0cnVjdHVyZSBhbmQgbW9ja2luZy5cbiAqIFxuICogRmVhdHVyZXM6XG4gKiAtIFVuaXQgdGVzdCBnZW5lcmF0aW9uIGZvciBleHBvcnRlZCBmdW5jdGlvbnMvY2xhc3Nlc1xuICogLSBBUEkgdGVzdCBnZW5lcmF0aW9uIGZvciBFeHByZXNzIHJvdXRlc1xuICogLSBBdXRvbWF0aWMgbW9jayBzZXR1cCBmb3Iga25vd24gbGlicmFyaWVzXG4gKiAtIEplc3QgY29uZmlndXJhdGlvbiBzY2FmZm9sZGluZ1xuICogLSBTdXBwb3J0IGZvciBxdGVzdHMgZnJhbWV3b3JrIGludGVncmF0aW9uXG4gKiAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgKG5vIHZlcnNpb24gZHVwbGljYXRpb24pXG4gKi9cblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZ2V0TW9kdWxlRGlybmFtZSB9IGZyb20gJy4uL3V0aWxzL2VzbS1nbG9iYWxzLmpzJztcblxuLy8gRVMgTW9kdWxlIF9fZGlybmFtZSBlcXVpdmFsZW50IC0gbGF6eSBpbml0aWFsaXphdGlvbiB0byBhdm9pZCBKZXN0IGlzc3Vlc1xubGV0IG1vZHVsZURpcm5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldE1vZHVsZURpcm5hbWVGb3JUZXN0R2VuZXJhdG9yKCk6IHN0cmluZyB7XG4gIGlmIChtb2R1bGVEaXJuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBVc2UgYSB0cnktY2F0Y2ggdG8gaGFuZGxlIEplc3QgZW52aXJvbm1lbnQgZ3JhY2VmdWxseVxuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgZXZhbCB0byBoaWRlIGltcG9ydC5tZXRhIGZyb20gSmVzdCdzIHN0YXRpYyBwYXJzZXJcbiAgICAgIGNvbnN0IGltcG9ydE1ldGFVcmwgPSAoMCwgZXZhbCkoJ2ltcG9ydC5tZXRhLnVybCcpO1xuICAgICAgbW9kdWxlRGlybmFtZSA9IGdldE1vZHVsZURpcm5hbWUoaW1wb3J0TWV0YVVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEZhbGxiYWNrIGZvciBKZXN0IGVudmlyb25tZW50XG4gICAgICBtb2R1bGVEaXJuYW1lID0gcHJvY2Vzcy5jd2QoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZHVsZURpcm5hbWU7XG59XG5cbi8vIFR5cGUgZGVmaW5pdGlvbnNcbmludGVyZmFjZSBUZXN0R2VuZXJhdG9yQ29uZmlnIHtcbiAgU1JDX0RJUjogc3RyaW5nO1xuICBURVNUX0RJUjogc3RyaW5nO1xuICBLTk9XTl9NT0NLUzogc3RyaW5nW107XG4gIFZBTElEX0VYVFM6IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgU2Nhbm5lZFRlc3Qge1xuICB0eXBlOiAndW5pdCcgfCAnYXBpJztcbiAgZmlsZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmlsZUNhdGVnb3JpemF0aW9uIHtcbiAgc291cmNlRmlsZXM6IHN0cmluZ1tdO1xuICBleGlzdGluZ1Rlc3RzOiBzdHJpbmdbXTtcbn1cblxuLy8gQ29uZmlndXJhdGlvbiBjb25zdGFudHMgLSBUeXBlU2NyaXB0IEVTIG1vZHVsZSBvbmx5XG5jb25zdCBERUZBVUxUX0NPTkZJRzogVGVzdEdlbmVyYXRvckNvbmZpZyA9IHtcbiAgU1JDX0RJUjogJy4nLFxuICBURVNUX0RJUjogJ2dlbmVyYXRlZC10ZXN0cycsXG4gIEtOT1dOX01PQ0tTOiBbJ2F4aW9zJywgJ25vZGUtZmV0Y2gnLCAncGcnLCAnbW9uZ29vc2UnLCAnZnMnLCAncmVkaXMnXSxcbiAgVkFMSURfRVhUUzogWycudHMnLCAnLmpzJywgJy50c3gnLCAnLmpzeCddXG59O1xuXG4vLyBSZWdleCBwYXR0ZXJucyBmb3IgY29kZSBhbmFseXNpcyAtIEVuaGFuY2VkIGZvciBib3RoIEVTIG1vZHVsZXMgYW5kIENvbW1vbkpTXG5jb25zdCBQQVRURVJOUyA9IHtcbiAgcXRlc3RzOiAvZnJvbSBbJ1wiXXF0ZXN0c1snXCJdfHJlcXVpcmVcXChbJ1wiXXF0ZXN0c1snXCJdXFwpLyxcbiAgYXBpOiAvXFxiKGFwcHxyb3V0ZXIpXFwuKGdldHxwb3N0fHB1dHxkZWxldGV8cGF0Y2gpXFxzKlxcKFxccypbJ1wiYF0oW14nXCJgXSspWydcImBdL2dpLFxuICAvLyBFUyBtb2R1bGUgZXhwb3J0czogZXhwb3J0IGNvbnN0LCBleHBvcnQgZnVuY3Rpb24sIGV4cG9ydCBjbGFzc1xuICBleHBvcnRzRVM6IC9eXFxzKmV4cG9ydFxccysoPzpjb25zdHxmdW5jdGlvbnxjbGFzcylcXHMrKFthLXpBLVowLTlfXSspL2dtLFxuICAvLyBFUyBtb2R1bGUgbmFtZWQgZXhwb3J0czogZXhwb3J0IHsgbmFtZTEsIG5hbWUyLCBuYW1lMyB9XG4gIGV4cG9ydHNOYW1lZDogL2V4cG9ydFxccypcXHtcXHMqKFtefV0rKVxccypcXH0vZyxcbiAgLy8gRVMgbW9kdWxlIGRlZmF1bHQgZXhwb3J0czogZXhwb3J0IGRlZmF1bHQgU29tZU5hbWVcbiAgZXhwb3J0c0RlZmF1bHQ6IC9leHBvcnRcXHMrZGVmYXVsdFxccysoW2EtekEtWjAtOV9dKykvZyxcbiAgLy8gQ29tbW9uSlMgZXhwb3J0czogbW9kdWxlLmV4cG9ydHMgPSB7fSwgbW9kdWxlLmV4cG9ydHMubmFtZSA9LCBleHBvcnRzLm5hbWUgPVxuICBleHBvcnRzQ29tbW9uSlM6IC8oPzptb2R1bGVcXC5leHBvcnRzXFwuKFthLXpBLVowLTlfXSspXFxzKj18ZXhwb3J0c1xcLihbYS16QS1aMC05X10rKVxccyo9fG1vZHVsZVxcLmV4cG9ydHNcXHMqPVxccyooW2EtekEtWjAtOV9dKykpL2dtLFxuICAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvbnMgdGhhdCBtaWdodCBiZSBleHBvcnRlZFxuICBmdW5jdGlvbkRlY2xhcmF0aW9uczogL15cXHMqKD86YXN5bmNcXHMrKT9mdW5jdGlvblxccysoW2EtekEtWjAtOV9dKylcXHMqXFwoL2dtLFxuICAvLyBDbGFzcyBkZWNsYXJhdGlvbnMgdGhhdCBtaWdodCBiZSBleHBvcnRlZFxuICBjbGFzc0RlY2xhcmF0aW9uczogL15cXHMqY2xhc3NcXHMrKFthLXpBLVowLTlfXSspL2dtLFxuICBpbXBvcnRzOiAvZnJvbSBbJ1wiXShbXidcIl0rKVsnXCJdfHJlcXVpcmVcXChbJ1wiXShbXidcIl0rKVsnXCJdXFwpL2dcbn07XG5cbmNsYXNzIFRlc3RHZW5lcmF0b3Ige1xuICBwcml2YXRlIGNvbmZpZzogVGVzdEdlbmVyYXRvckNvbmZpZztcbiAgcHJpdmF0ZSBzY2FubmVkOiBTY2FubmVkVGVzdFtdO1xuICBwcml2YXRlIGlzRVNNb2R1bGU6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxUZXN0R2VuZXJhdG9yQ29uZmlnPiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLkRFRkFVTFRfQ09ORklHLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5zY2FubmVkID0gW107XG4gICAgdGhpcy5pc0VTTW9kdWxlID0gdGhpcy5kZXRlY3RFU01vZHVsZSgpOyAvLyBEZXRlY3QgbW9kdWxlIHR5cGUgb25jZSBkdXJpbmcgaW5pdGlhbGl6YXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgdGhlIGN1cnJlbnQgcHJvamVjdCB1c2VzIEVTIG1vZHVsZXMgb3IgQ29tbW9uSlNcbiAgICogU2luY2Ugd2UncmUgbm93IFwiVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVwiLCB0aGlzIGRlZmF1bHRzIHRvIHRydWUgZm9yIFR5cGVTY3JpcHQgcHJvamVjdHNcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0RVNNb2R1bGUoKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIHBhY2thZ2UuanNvbiBmb3IgZXhwbGljaXQgXCJ0eXBlXCI6IFwibW9kdWxlXCJcbiAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICdwYWNrYWdlLmpzb24nKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBhY2thZ2VQYXRoKSkge1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgaWYgKHBhY2thZ2VKc29uLnR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2gsIHByZWZlciBFUyBtb2R1bGVzIHdoZW4gVHlwZVNjcmlwdCBpcyBkZXRlY3RlZFxuICAgICAgICBpZiAocGFja2FnZUpzb24uZGV2RGVwZW5kZW5jaWVzPy50eXBlc2NyaXB0IHx8IHBhY2thZ2VKc29uLmRlcGVuZGVuY2llcz8udHlwZXNjcmlwdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBFUyBtb2R1bGUgcGF0dGVybnMgaW4gc291cmNlIGZpbGVzIChleGNsdWRpbmcgdGVzdCBmaWxlcyBhbmQgbm9kZV9tb2R1bGVzKVxuICAgICAgY29uc3Qgc291cmNlRmlsZXMgPSB0aGlzLndhbGtQcm9qZWN0KClcbiAgICAgICAgLmZpbHRlcihmaWxlID0+IHtcbiAgICAgICAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZmlsZSk7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZEV4dCA9IHRoaXMuY29uZmlnLlZBTElEX0VYVFMuaW5jbHVkZXMoZXh0KTtcbiAgICAgICAgICBjb25zdCBpc1Rlc3RGaWxlID0gdGhpcy5pc1Rlc3RGaWxlKHBhdGguYmFzZW5hbWUoZmlsZSkpO1xuICAgICAgICAgIGNvbnN0IGlzTm9kZU1vZHVsZXMgPSBmaWxlLmluY2x1ZGVzKCdub2RlX21vZHVsZXMnKTtcbiAgICAgICAgICByZXR1cm4gaXNWYWxpZEV4dCAmJiAhaXNUZXN0RmlsZSAmJiAhaXNOb2RlTW9kdWxlcztcbiAgICAgICAgfSlcbiAgICAgICAgLnNsaWNlKDAsIDEwKTsgLy8gU2FtcGxlIGZpcnN0IDEwIGZpbGVzIGZvciBwZXJmb3JtYW5jZVxuICAgICAgXG4gICAgICBsZXQgZXNNb2R1bGVDb3VudCA9IDA7XG4gICAgICBsZXQgY29tbW9uSlNDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBzb3VyY2VGaWxlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICAgICAgICAvLyBMb29rIGZvciBFUyBtb2R1bGUgcGF0dGVybnMgKGltcG9ydCBPUiBleHBvcnQgc3RhdGVtZW50cylcbiAgICAgICAgICBpZiAoY29udGVudC5pbmNsdWRlcygnaW1wb3J0ICcpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ2V4cG9ydCAnKSkge1xuICAgICAgICAgICAgZXNNb2R1bGVDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBMb29rIGZvciBDb21tb25KUyBwYXR0ZXJuc1xuICAgICAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdyZXF1aXJlKCcpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ21vZHVsZS5leHBvcnRzJykpIHtcbiAgICAgICAgICAgIGNvbW1vbkpTQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gU2tpcCBmaWxlcyB3ZSBjYW4ndCByZWFkXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2gsIHByZWZlciBFUyBtb2R1bGVzIHdoZW4gZXF1YWwgb3Igd2hlbiBUeXBlU2NyaXB0IGZpbGVzIGFyZSBwcmVzZW50XG4gICAgICBpZiAoZXNNb2R1bGVDb3VudCA9PT0gMCAmJiBjb21tb25KU0NvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBEZWZhdWx0IHRvIEVTIG1vZHVsZXMgZm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2hcbiAgICAgIH1cbiAgICAgIGlmIChlc01vZHVsZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gRVMgbW9kdWxlIHBhdHRlcm5zIGZvdW5kLCBkZWZhdWx0IHRvIENvbW1vbkpTXG4gICAgICB9XG4gICAgICByZXR1cm4gZXNNb2R1bGVDb3VudCA+PSBjb21tb25KU0NvdW50OyAvLyBDaGFuZ2VkIGZyb20gPiB0byA+PSB0byBwcmVmZXIgRVMgbW9kdWxlc1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIEVTIG1vZHVsZXMgZm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2hcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBkaXJlY3Rvcnkgc2hvdWxkIGJlIHNraXBwZWQgZHVyaW5nIGRpc2NvdmVyeVxuICAgKi9cbiAgcHJpdmF0ZSBzaG91bGRTa2lwRGlyZWN0b3J5KGRpck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHNraXBQYXR0ZXJucyA9IFtcbiAgICAgICdub2RlX21vZHVsZXMnLCAnLmdpdCcsICcubmV4dCcsICdkaXN0JywgJ2J1aWxkJywgJ2NvdmVyYWdlJyxcbiAgICAgICcudnNjb2RlJywgJy5pZGVhJywgJ2RvY3MnLCAnZG9jdW1lbnRhdGlvbicsICdhc3NldHMnLCAncHVibGljJywgJ3N0YXRpYycsXG4gICAgICAnLnJlcGxpdF9jYWNoZScsICcuY29uZmlnJywgJy5ucG0nLCAnbG9ncydcbiAgICBdO1xuICAgIHJldHVybiBza2lwUGF0dGVybnMuaW5jbHVkZXMoZGlyTmFtZSkgfHwgZGlyTmFtZS5zdGFydHNXaXRoKCcuJyk7XG4gIH1cblxuICAvKipcbiAgICogV2FsayBlbnRpcmUgcHJvamVjdCBkaXJlY3Rvcnkgc3RydWN0dXJlLCByZXNwZWN0aW5nIHNraXAgcGF0dGVybnNcbiAgICovXG4gIHByaXZhdGUgd2Fsa1Byb2plY3QoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGN1cnJlbnREaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICAgIHJldHVybiB0aGlzLndhbGtSZWN1cnNpdmUoY3VycmVudERpcik7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayBkaXJlY3RvcnkgYW5kIHJldHVybiBhbGwgZmlsZSBwYXRocywgc2tpcHBpbmcgaXJyZWxldmFudCBkaXJlY3Rvcmllc1xuICAgKi9cbiAgcHJpdmF0ZSB3YWxrUmVjdXJzaXZlKGRpcjogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmcy5yZWFkZGlyU3luYyhkaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KS5mbGF0TWFwKGVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGZ1bGwgPSBwYXRoLnJlc29sdmUoZGlyLCBlbnRyeS5uYW1lKTtcbiAgICAgIFxuICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgLy8gU2tpcCBkaXJlY3RvcmllcyB0aGF0IHNob3VsZG4ndCBjb250YWluIHRlc3RzIG9yIHNvdXJjZSBmaWxlc1xuICAgICAgICBpZiAodGhpcy5zaG91bGRTa2lwRGlyZWN0b3J5KGVudHJ5Lm5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGtSZWN1cnNpdmUoZnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2Z1bGxdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExlZ2FjeSB3YWxrIG1ldGhvZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKHdhbGtzIHNpbmdsZSBkaXJlY3RvcnkpXG4gICAqL1xuICBwcml2YXRlIHdhbGsoZGlyOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZzLnJlYWRkaXJTeW5jKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pLmZsYXRNYXAoZW50cnkgPT4ge1xuICAgICAgY29uc3QgZnVsbCA9IHBhdGgucmVzb2x2ZShkaXIsIGVudHJ5Lm5hbWUpO1xuICAgICAgcmV0dXJuIGVudHJ5LmlzRGlyZWN0b3J5KCkgPyB0aGlzLndhbGsoZnVsbCkgOiBbZnVsbF07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2F0ZWdvcml6ZSBkaXNjb3ZlcmVkIGZpbGVzIGludG8gc291cmNlIGZpbGVzIGFuZCBleGlzdGluZyB0ZXN0c1xuICAgKi9cbiAgcHJpdmF0ZSBjYXRlZ29yaXplRmlsZXMoZmlsZXM6IHN0cmluZ1tdKTogRmlsZUNhdGVnb3JpemF0aW9uIHtcbiAgICBjb25zdCBzb3VyY2VGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBleGlzdGluZ1Rlc3RzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZmlsZSk7XG4gICAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFNraXAgZmlsZXMgd2l0aCBpbnZhbGlkIGV4dGVuc2lvbnNcbiAgICAgIGlmICghdGhpcy5jb25maWcuVkFMSURfRVhUUy5pbmNsdWRlcyhleHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHRlc3QgZmlsZVxuICAgICAgaWYgKHRoaXMuaXNUZXN0RmlsZShiYXNlbmFtZSkpIHtcbiAgICAgICAgZXhpc3RpbmdUZXN0cy5wdXNoKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzb3VyY2UgZmlsZSBhbHJlYWR5IGhhcyBhIGNvcnJlc3BvbmRpbmcgdGVzdFxuICAgICAgICBjb25zdCBoYXNUZXN0ID0gdGhpcy5oYXNDb3JyZXNwb25kaW5nVGVzdChmaWxlLCBmaWxlcyk7XG4gICAgICAgIGlmICghaGFzVGVzdCkge1xuICAgICAgICAgIHNvdXJjZUZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4geyBzb3VyY2VGaWxlcywgZXhpc3RpbmdUZXN0cyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGZpbGVuYW1lIGluZGljYXRlcyBpdCdzIGEgdGVzdCBmaWxlXG4gICAqL1xuICBwcml2YXRlIGlzVGVzdEZpbGUoZmlsZW5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRlc3RQYXR0ZXJucyA9IFtcbiAgICAgIC9cXC50ZXN0XFwuLyxcbiAgICAgIC9cXC5zcGVjXFwuLyxcbiAgICAgIC9fdGVzdFxcLi8sXG4gICAgICAvX3NwZWNcXC4vLFxuICAgICAgL1xcLmUyZVxcLi8sXG4gICAgICAvXFwuaW50ZWdyYXRpb25cXC4vXG4gICAgXTtcbiAgICBcbiAgICByZXR1cm4gdGVzdFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoZmlsZW5hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHNvdXJjZSBmaWxlIGhhcyBhIGNvcnJlc3BvbmRpbmcgdGVzdCBmaWxlXG4gICAqL1xuICBwcml2YXRlIGhhc0NvcnJlc3BvbmRpbmdUZXN0KHNvdXJjZUZpbGU6IHN0cmluZywgYWxsRmlsZXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKHNvdXJjZUZpbGUpO1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShzb3VyY2VGaWxlLCBwYXRoLmV4dG5hbWUoc291cmNlRmlsZSkpO1xuICAgIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShzb3VyY2VGaWxlKTtcbiAgICBcbiAgICAvLyBDb21tb24gdGVzdCBmaWxlIHBhdHRlcm5zIHRvIGxvb2sgZm9yIC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVxuICAgIGNvbnN0IHRlc3RQYXR0ZXJucyA9IFtcbiAgICAgIGAke2Jhc2VuYW1lfS50ZXN0LnRzYCxcbiAgICAgIGAke2Jhc2VuYW1lfUdlbmVyYXRlZFRlc3QudGVzdC50c2AsICAvLyBHZW5lcmF0ZWQgdW5pdCB0ZXN0cyAgXG4gICAgICBgJHtiYXNlbmFtZX0uc3BlYy50c2AsXG4gICAgICBgJHtiYXNlbmFtZX1fdGVzdC50c2AsXG4gICAgICBgJHtiYXNlbmFtZX1fc3BlYy50c2AsXG4gICAgICBgJHtiYXNlbmFtZX0udGVzdCR7ZXh0fWAsXG4gICAgICBgJHtiYXNlbmFtZX0uc3BlYyR7ZXh0fWBcbiAgICBdO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIHRlc3QgZmlsZXMgaW4gdGhlIHNhbWUgZGlyZWN0b3J5XG4gICAgY29uc3Qgc2FtZURpcmVjdG9yeVRlc3RzID0gdGVzdFBhdHRlcm5zLm1hcChwYXR0ZXJuID0+IFxuICAgICAgcGF0aC5qb2luKGRpciwgcGF0dGVybilcbiAgICApO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIHRlc3QgZmlsZXMgaW4gY29tbW9uIHRlc3QgZGlyZWN0b3JpZXNcbiAgICBjb25zdCB0ZXN0RGlyZWN0b3JpZXMgPSBbJ3Rlc3RzJywgJ3Rlc3QnLCAnX190ZXN0c19fJywgJ3NwZWMnXTtcbiAgICBjb25zdCB0ZXN0RGlyZWN0b3J5VGVzdHMgPSB0ZXN0RGlyZWN0b3JpZXMuZmxhdE1hcCh0ZXN0RGlyID0+IHtcbiAgICAgIGNvbnN0IHRlc3RQYXRoID0gcGF0aC5qb2luKGRpciwgdGVzdERpcik7XG4gICAgICByZXR1cm4gdGVzdFBhdHRlcm5zLm1hcChwYXR0ZXJuID0+IHBhdGguam9pbih0ZXN0UGF0aCwgcGF0dGVybikpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGVzZSB0ZXN0IGZpbGVzIGV4aXN0XG4gICAgY29uc3QgYWxsVGVzdFBhdGhzID0gWy4uLnNhbWVEaXJlY3RvcnlUZXN0cywgLi4udGVzdERpcmVjdG9yeVRlc3RzXTtcbiAgICBcbiAgICAvLyBOb3JtYWxpemUgcGF0aHMgZm9yIGNvbXBhcmlzb24gLSBjb252ZXJ0IGJvdGggdG8gYWJzb2x1dGUgcGF0aHNcbiAgICBjb25zdCBub3JtYWxpemVkQWxsRmlsZXMgPSBhbGxGaWxlcy5tYXAoZmlsZSA9PiBwYXRoLnJlc29sdmUoZmlsZSkpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUZXN0UGF0aHMgPSBhbGxUZXN0UGF0aHMubWFwKHRlc3RQYXRoID0+IHBhdGgucmVzb2x2ZSh0ZXN0UGF0aCkpO1xuICAgIFxuICAgIHJldHVybiBub3JtYWxpemVkVGVzdFBhdGhzLnNvbWUodGVzdFBhdGggPT4gXG4gICAgICBub3JtYWxpemVkQWxsRmlsZXMuaW5jbHVkZXModGVzdFBhdGgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSB0ZXN0IGZpbGUgcGF0aCBiYXNlZCBvbiBzb3VyY2UgZmlsZSBhbmQgdGVzdCB0eXBlXG4gICAqIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgLSBhbHdheXMgZ2VuZXJhdGVzIC50cyB0ZXN0IGZpbGVzXG4gICAqL1xuICBwcml2YXRlIGdldFJlbGF0aXZlVGVzdFBhdGgoZmlsZTogc3RyaW5nLCB0eXBlOiAndW5pdCcgfCAnYXBpJyA9ICd1bml0Jyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlLCBwYXRoLmV4dG5hbWUoZmlsZSkpO1xuICAgIFxuICAgIGlmICh0eXBlID09PSAndW5pdCcpIHtcbiAgICAgIC8vIEZvciB1bml0IHRlc3RzLCBwbGFjZSB0aGVtIGFsb25nc2lkZSB0aGUgc291cmNlIGZpbGUgd2l0aCBHZW5lcmF0ZWRUZXN0IG5hbWluZ1xuICAgICAgcmV0dXJuIHBhdGguam9pbihkaXIsIGAke2Jhc2VuYW1lfUdlbmVyYXRlZFRlc3QudGVzdC50c2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgQVBJL2ludGVncmF0aW9uIHRlc3RzLCB1c2UgdGhlIGNvbmZpZ3VyZWQgdGVzdCBkaXJlY3Rvcnkgd2l0aCAudHMgZXh0ZW5zaW9uXG4gICAgICBjb25zdCByZWwgPSBwYXRoLnJlbGF0aXZlKHByb2Nlc3MuY3dkKCksIGZpbGUpO1xuICAgICAgcmV0dXJuIHBhdGguam9pbih0aGlzLmNvbmZpZy5URVNUX0RJUiwgcmVsLnJlcGxhY2UoL1xcLlt0al1zeD8kLywgJy50ZXN0LnRzJykucmVwbGFjZSgvW1xcXFwvXS9nLCAnX18nKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVEaXIocDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKHApO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgICBmcy5ta2RpclN5bmMoZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgZmlsZSBvbmx5IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgKi9cbiAgcHJpdmF0ZSB3cml0ZUlmTWlzc2luZyhwOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhwKSkge1xuICAgICAgdGhpcy5jcmVhdGVEaXIocCk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHAsIGNvbnRlbnQsICd1dGY4Jyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgaW1wb3J0ZWQgbW9kdWxlcyBmcm9tIGZpbGUgY29udGVudCAtIEVuaGFuY2VkIGZvciBib3RoIEVTIG1vZHVsZXMgYW5kIENvbW1vbkpTXG4gICAqL1xuICBwcml2YXRlIGdldFVzZWRNb2R1bGVzKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLmNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuaW1wb3J0cyldXG4gICAgICAubWFwKG0gPT4gbVsxXSB8fCBtWzJdKSAvLyBtWzFdIGZvciBFUyBtb2R1bGVzLCBtWzJdIGZvciBDb21tb25KU1xuICAgICAgLmZpbHRlcih4ID0+IHggJiYgIXguc3RhcnRzV2l0aCgnLicpICYmICF4LnN0YXJ0c1dpdGgoJy8nKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgdW5pdCB0ZXN0IGNvbnRlbnQgZm9yIGEgZmlsZSAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHlcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlVW5pdFRlc3QoZmlsZTogc3RyaW5nLCBleHBvcnRzOiBzdHJpbmdbXSwgdXNlc1F0ZXN0czogYm9vbGVhbiwgbW9ja3M6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSwgcGF0aC5leHRuYW1lKGZpbGUpKTtcbiAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZmlsZSk7XG4gICAgXG4gICAgY29uc3QgbGluZXMgPSBbXG4gICAgICBgLy8gTGlnaHR3ZWlnaHQgdW5pdCB0ZXN0IGZvciAke3BhdGguYmFzZW5hbWUoZmlsZSl9IC0gVHlwZVNjcmlwdCBFUyBtb2R1bGVgLFxuICAgICAgYGBcbiAgICBdO1xuICAgIFxuICAgIC8vIFR5cGVTY3JpcHQgRVMgbW9kdWxlIGltcG9ydHNcbiAgICBpZiAodXNlc1F0ZXN0cykge1xuICAgICAgbGluZXMucHVzaChgaW1wb3J0IHsgdGVzdCwgbW9ja0NvbnNvbGUgfSBmcm9tICdxdGVzdHMnO2ApO1xuICAgICAgbGluZXMucHVzaChgLy8gTk9URTogVXNlIG1vY2tDb25zb2xlIGRpcmVjdGx5LCBhdm9pZCBjb21wbGV4IGFzeW5jIHBhdHRlcm5zYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIExpZ2h0d2VpZ2h0IG1vY2sgc2V0dXAgZm9yIFR5cGVTY3JpcHRcbiAgICBpZiAobW9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXMucHVzaChgLy8gTGlnaHR3ZWlnaHQgbW9jayBzZXR1cCAtIFR5cGVTY3JpcHQgY29tcGF0aWJsZWApO1xuICAgICAgbW9ja3MuZm9yRWFjaChsaWIgPT4ge1xuICAgICAgICBsaW5lcy5wdXNoKGBqZXN0Lm1vY2soJyR7bGlifScsICgpID0+ICh7YCk7XG4gICAgICAgIGxpbmVzLnB1c2goYCAgX19lc01vZHVsZTogdHJ1ZSxgKTtcbiAgICAgICAgbGluZXMucHVzaChgICBkZWZhdWx0OiBqZXN0LmZuKCgpID0+ICdtb2NrLSR7bGlifScpLGApO1xuICAgICAgICBsaW5lcy5wdXNoKGB9KSk7YCk7XG4gICAgICB9KTtcbiAgICAgIGxpbmVzLnB1c2goYGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBUeXBlU2NyaXB0IHRlc3Qgc3VpdGVcbiAgICBsaW5lcy5wdXNoKGBkZXNjcmliZSgnJHtwYXRoLmJhc2VuYW1lKGZpbGUpfSBiYXNpYyBleHBvcnRzJywgKCkgPT4ge2ApO1xuICAgIFxuICAgIC8vIFNpbmdsZSBsaWdodHdlaWdodCB0ZXN0IGZvciBUeXBlU2NyaXB0IEVTIG1vZHVsZXNcbiAgICBsaW5lcy5wdXNoKGAgIHRlc3QoJ21vZHVsZSBsb2FkcyB3aXRob3V0IGVycm9ycycsIGFzeW5jICgpID0+IHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgLy8gVHlwZVNjcmlwdCBFUyBtb2R1bGUgZHluYW1pYyBpbXBvcnRgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgY29uc3QgbW9kdWxlID0gYXdhaXQgaW1wb3J0KCcuLyR7YmFzZW5hbWV9JHtleHR9Jyk7YCk7XG4gICAgbGluZXMucHVzaChgICAgIGV4cGVjdChtb2R1bGUpLnRvQmVEZWZpbmVkKCk7YCk7XG4gICAgbGluZXMucHVzaChgICAgIGV4cGVjdCh0eXBlb2YgbW9kdWxlKS50b0JlKCdvYmplY3QnKTtgKTtcbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcy5wdXNoKGAgICAgLy8gQ2hlY2sgZm9yIGV4cGVjdGVkIGV4cG9ydHNgKTtcbiAgICAgIGV4cG9ydHMuc2xpY2UoMCwgMykuZm9yRWFjaChleHBvcnROYW1lID0+IHtcbiAgICAgICAgbGluZXMucHVzaChgICAgIGV4cGVjdChtb2R1bGUuJHtleHBvcnROYW1lfSkudG9CZURlZmluZWQoKTtgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKGAgIH0pO2ApO1xuICAgIGxpbmVzLnB1c2goYH0pO2ApO1xuICAgIGxpbmVzLnB1c2goJycpO1xuICAgIFxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBBUEkgdGVzdCBjb250ZW50IGZvciBhbiBlbmRwb2ludCAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHlcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQXBpVGVzdChtZXRob2Q6IHN0cmluZywgcm91dGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbGluZXMgPSBbXG4gICAgICBgLy8gQXV0by1nZW5lcmF0ZWQgQVBJIHRlc3QgZm9yICR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9ICR7cm91dGV9IC0gVHlwZVNjcmlwdCBFUyBtb2R1bGVgLFxuICAgICAgYC8vIFBBUkFMTEVMLVNBRkUgREVTSUdOOiBUaGlzIHRlc3QgYXZvaWRzIHJhY2UgY29uZGl0aW9uc2AsXG4gICAgICBgYFxuICAgIF07XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdW5pcXVlIHRlc3Qgc2Vzc2lvbiBmb3IgQVBJIGlzb2xhdGlvblxuICAgIGxpbmVzLnB1c2goYC8vIFVuaXF1ZSBBUEkgdGVzdCBzZXNzaW9uIGZvciBwYXJhbGxlbCBleGVjdXRpb24gc2FmZXR5YCk7XG4gICAgbGluZXMucHVzaChgY29uc3QgYXBpVGVzdFNlc3Npb24gPSBcXGBcXCR7cHJvY2Vzcy5ocnRpbWUuYmlnaW50KCl9LVxcJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9XFxgO2ApO1xuICAgIGxpbmVzLnB1c2goYGNvbnN0IHVuaXF1ZVJvdXRlID0gJyR7cm91dGV9JyArICgnJHtyb3V0ZX0nLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPycpICsgJ3Rlc3RTZXNzaW9uPScgKyBhcGlUZXN0U2Vzc2lvbjtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBcbiAgICAvLyBUeXBlU2NyaXB0IEVTIG1vZHVsZSBpbXBvcnRcbiAgICBsaW5lcy5wdXNoKGBpbXBvcnQgKiBhcyBodHRwVGVzdCBmcm9tICcuLi91dGlscy9odHRwVGVzdC5qcyc7YCwgJycpO1xuICAgIFxuICAgIC8vIFR5cGVTY3JpcHQgdGVzdCBzdWl0ZVxuICAgIGxpbmVzLnB1c2goYGRlc2NyaWJlKFxcYCR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9ICR7cm91dGV9IFtBUEktXFwke2FwaVRlc3RTZXNzaW9ufV1cXGAsICgpID0+IHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgIC8vIFRlc3QgZGF0YSBmYWN0b3J5IGZvciB1bmlxdWUgcmVxdWVzdC9yZXNwb25zZSBkYXRhYCk7XG4gICAgbGluZXMucHVzaChgICBjb25zdCBjcmVhdGVVbmlxdWVUZXN0RGF0YSA9ICgpID0+ICh7YCk7XG4gICAgbGluZXMucHVzaChgICAgIHNlc3Npb25JZDogYXBpVGVzdFNlc3Npb24sYCk7XG4gICAgbGluZXMucHVzaChgICAgIHJlcXVlc3RJZDogXFxgcmVxLVxcJHtEYXRlLm5vdygpfS1cXCR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDYpfVxcYCxgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksYCk7XG4gICAgbGluZXMucHVzaChgICB9KTtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBcbiAgICBsaW5lcy5wdXNoKGAgIHRlc3QoJ3Nob3VsZCBzdWNjZWVkIHdpdGggdW5pcXVlIHRlc3QgZGF0YScsIGFzeW5jICgpID0+IHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgY29uc3QgdGVzdERhdGEgPSBjcmVhdGVVbmlxdWVUZXN0RGF0YSgpO2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICBjb25zdCBhcHAgPSBodHRwVGVzdC5jcmVhdGVNb2NrQXBwKCk7YCk7XG4gICAgbGluZXMucHVzaChgICAgIGApO1xuICAgIGxpbmVzLnB1c2goYCAgICBhcHAuJHttZXRob2QudG9Mb3dlckNhc2UoKX0odW5pcXVlUm91dGUsIChyZXEsIHJlcykgPT4ge2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIHJlcy5zdGF0dXNDb2RlID0gMjAwO2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIHJlcy5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7YCk7XG4gICAgbGluZXMucHVzaChgICAgICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7IGApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgICAgc3VjY2VzczogdHJ1ZSwgYCk7XG4gICAgbGluZXMucHVzaChgICAgICAgICB0ZXN0U2Vzc2lvbjogYXBpVGVzdFNlc3Npb24sYCk7XG4gICAgbGluZXMucHVzaChgICAgICAgICByZXF1ZXN0SWQ6IHRlc3REYXRhLnJlcXVlc3RJZGApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIH0pKTtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgfSk7YCk7XG4gICAgbGluZXMucHVzaChgICAgIGApO1xuICAgIGxpbmVzLnB1c2goYCAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwVGVzdC5zdXBlcnRlc3QoYXBwKWApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIC4ke21ldGhvZC50b0xvd2VyQ2FzZSgpfSh1bmlxdWVSb3V0ZSlgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgICAuc2VuZCh0ZXN0RGF0YSlgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgICAuZXhwZWN0KDIwMCk7YCk7XG4gICAgbGluZXMucHVzaChgICAgIGApO1xuICAgIGxpbmVzLnB1c2goYCAgICBleHBlY3QocmVzLmJvZHkuc3VjY2VzcykudG9CZSh0cnVlKTtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgZXhwZWN0KHJlcy5ib2R5LnRlc3RTZXNzaW9uKS50b0JlKGFwaVRlc3RTZXNzaW9uKTtgKTtcbiAgICBsaW5lcy5wdXNoKCcgIH0pOycpO1xuICAgIGxpbmVzLnB1c2goJ30pO1xcbicpO1xuICAgIFxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlbGxpZ2VudGx5IGV4dHJhY3QgZXhwb3J0cyBmcm9tIGJvdGggRVMgbW9kdWxlcyBhbmQgQ29tbW9uSlNcbiAgICovXG4gIHByaXZhdGUgZXh0cmFjdEV4cG9ydHMoY29udGVudDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGV4cG9ydHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgY29tbWVudHMgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzXG4gICAgY29uc3QgY2xlYW5Db250ZW50ID0gY29udGVudFxuICAgICAgLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vZywgJycpIC8vIFJlbW92ZSAvKiAqLyBjb21tZW50c1xuICAgICAgLnJlcGxhY2UoL1xcL1xcLy4qJC9nbSwgJycpOyAvLyBSZW1vdmUgLy8gY29tbWVudHNcbiAgICBcbiAgICAvLyBFeHRyYWN0IEVTIG1vZHVsZSBleHBvcnRzIChleHBvcnQgY29uc3QvZnVuY3Rpb24vY2xhc3MpXG4gICAgY29uc3QgZXNFeHBvcnRzID0gWy4uLmNsZWFuQ29udGVudC5tYXRjaEFsbChQQVRURVJOUy5leHBvcnRzRVMpXTtcbiAgICBlc0V4cG9ydHMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2hbMV0pIGV4cG9ydHMuYWRkKG1hdGNoWzFdKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IEVTIG1vZHVsZSBuYW1lZCBleHBvcnRzOiBleHBvcnQgeyBuYW1lMSwgbmFtZTIsIG5hbWUzIH1cbiAgICBjb25zdCBuYW1lZEV4cG9ydHMgPSBbLi4uY2xlYW5Db250ZW50Lm1hdGNoQWxsKFBBVFRFUk5TLmV4cG9ydHNOYW1lZCldO1xuICAgIG5hbWVkRXhwb3J0cy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgbmFtZWQgZXhwb3J0cyBsaXN0XG4gICAgICAgIGNvbnN0IGV4cG9ydExpc3QgPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKTtcbiAgICAgICAgZXhwb3J0TGlzdC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgIC8vIEhhbmRsZSBwb3RlbnRpYWwgYWxpYXNlczogXCJuYW1lIGFzIGFsaWFzXCIgLT4gdXNlIFwibmFtZVwiXG4gICAgICAgICAgY29uc3QgY2xlYW5OYW1lID0gbmFtZS5zcGxpdCgnIGFzICcpWzBdLnRyaW0oKTtcbiAgICAgICAgICBpZiAoY2xlYW5OYW1lICYmIC9eW2EtekEtWjAtOV9dKyQvLnRlc3QoY2xlYW5OYW1lKSkge1xuICAgICAgICAgICAgZXhwb3J0cy5hZGQoY2xlYW5OYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgRVMgbW9kdWxlIGRlZmF1bHQgZXhwb3J0czogZXhwb3J0IGRlZmF1bHQgU29tZU5hbWVcbiAgICBjb25zdCBkZWZhdWx0RXhwb3J0cyA9IFsuLi5jbGVhbkNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuZXhwb3J0c0RlZmF1bHQpXTtcbiAgICBkZWZhdWx0RXhwb3J0cy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkgZXhwb3J0cy5hZGQobWF0Y2hbMV0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgQ29tbW9uSlMgZXhwb3J0c1xuICAgIGNvbnN0IGNvbW1vbkpTRXhwb3J0cyA9IFsuLi5jbGVhbkNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuZXhwb3J0c0NvbW1vbkpTKV07XG4gICAgY29tbW9uSlNFeHBvcnRzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgLy8gbWF0Y2hbMV0gPSBtb2R1bGUuZXhwb3J0cy5uYW1lLCBtYXRjaFsyXSA9IGV4cG9ydHMubmFtZSwgbWF0Y2hbM10gPSBzaW5nbGUgYXNzaWdubWVudFxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgICAgIGlmIChtYXRjaFtpXSkgZXhwb3J0cy5hZGQobWF0Y2hbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBtb2R1bGUuZXhwb3J0cyA9IHsgbmFtZTEsIG5hbWUyLCAuLi4gfSBwYXR0ZXJuXG4gICAgY29uc3Qgb2JqZWN0RXhwb3J0TWF0Y2ggPSBjbGVhbkNvbnRlbnQubWF0Y2goL21vZHVsZVxcLmV4cG9ydHNcXHMqPVxccypcXHsoW159XSspXFx9Lyk7XG4gICAgaWYgKG9iamVjdEV4cG9ydE1hdGNoKSB7XG4gICAgICBjb25zdCBvYmplY3RDb250ZW50ID0gb2JqZWN0RXhwb3J0TWF0Y2hbMV07XG4gICAgICBjb25zdCBwcm9wZXJ0eU1hdGNoZXMgPSBvYmplY3RDb250ZW50Lm1hdGNoQWxsKC9cXGIoXFx3KykoPzpcXHMqOlxccypcXHcrKT9cXHMqWyx9XS9nKTtcbiAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgcHJvcGVydHlNYXRjaGVzKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSkgZXhwb3J0cy5hZGQobWF0Y2hbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gQXJyYXkuZnJvbShleHBvcnRzKS5maWx0ZXIobmFtZSA9PiBuYW1lICYmIG5hbWUubGVuZ3RoID4gMCk7XG4gIH1cblxuICAvKipcbiAgICogQW5hbHl6ZSBhIHNpbmdsZSBmaWxlIGFuZCBnZW5lcmF0ZSBhcHByb3ByaWF0ZSB0ZXN0cyAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHlcbiAgICovXG4gIGFuYWx5emUoZmlsZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKGZpbGUpO1xuICAgIGlmICghdGhpcy5jb25maWcuVkFMSURfRVhUUy5pbmNsdWRlcyhleHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgIGNvbnN0IHVzZXNRdGVzdHMgPSBQQVRURVJOUy5xdGVzdHMudGVzdChjb250ZW50KTtcbiAgICBjb25zdCBpbXBvcnRzID0gdGhpcy5nZXRVc2VkTW9kdWxlcyhjb250ZW50KTtcbiAgICBjb25zdCBtb2NrVGFyZ2V0cyA9IGltcG9ydHMuZmlsdGVyKGkgPT4gXG4gICAgICB0aGlzLmNvbmZpZy5LTk9XTl9NT0NLUy5pbmNsdWRlcyhpKSAmJiBpICE9PSAncXRlc3RzJ1xuICAgICk7XG5cbiAgICAvLyBVc2UgaW50ZWxsaWdlbnQgZXhwb3J0IGRldGVjdGlvbiBmb3IgYm90aCBFUyBtb2R1bGVzIGFuZCBDb21tb25KU1xuICAgIGNvbnN0IGV4cG9ydHMgPSB0aGlzLmV4dHJhY3RFeHBvcnRzKGNvbnRlbnQpO1xuICAgIGlmIChleHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRlc3RQYXRoID0gdGhpcy5nZXRSZWxhdGl2ZVRlc3RQYXRoKGZpbGUsICd1bml0Jyk7XG4gICAgICBjb25zdCBjcmVhdGVkID0gdGhpcy53cml0ZUlmTWlzc2luZyhcbiAgICAgICAgdGVzdFBhdGgsIFxuICAgICAgICB0aGlzLmNyZWF0ZVVuaXRUZXN0KGZpbGUsIGV4cG9ydHMsIHVzZXNRdGVzdHMsIG1vY2tUYXJnZXRzKVxuICAgICAgKTtcbiAgICAgIGlmIChjcmVhdGVkKSB7XG4gICAgICAgIHRoaXMuc2Nhbm5lZC5wdXNoKHsgXG4gICAgICAgICAgdHlwZTogJ3VuaXQnLCBcbiAgICAgICAgICBmaWxlOiBwYXRoLnJlbGF0aXZlKCcuJywgdGVzdFBhdGgpIFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBBUEkgdGVzdHMgZm9yIGRldGVjdGVkIHJvdXRlcyAtIFR5cGVTY3JpcHQgb25seVxuICAgIGNvbnN0IGFwaXMgPSBbLi4uY29udGVudC5tYXRjaEFsbChQQVRURVJOUy5hcGkpXTtcbiAgICBmb3IgKGNvbnN0IFssICwgbWV0aG9kLCByb3V0ZV0gb2YgYXBpcykge1xuICAgICAgY29uc3QgdGVzdFBhdGggPSB0aGlzLmdldFJlbGF0aXZlVGVzdFBhdGgoZmlsZSwgJ2FwaScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC50ZXN0XFwudHMkLywgYF9fJHttZXRob2QudG9Mb3dlckNhc2UoKX0udGVzdC50c2ApO1xuICAgICAgY29uc3QgY3JlYXRlZCA9IHRoaXMud3JpdGVJZk1pc3NpbmcoXG4gICAgICAgIHRlc3RQYXRoLCBcbiAgICAgICAgdGhpcy5jcmVhdGVBcGlUZXN0KG1ldGhvZCwgcm91dGUpXG4gICAgICApO1xuICAgICAgaWYgKGNyZWF0ZWQpIHtcbiAgICAgICAgdGhpcy5zY2FubmVkLnB1c2goeyBcbiAgICAgICAgICB0eXBlOiAnYXBpJywgXG4gICAgICAgICAgZmlsZTogcGF0aC5yZWxhdGl2ZSgnLicsIHRlc3RQYXRoKSBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBKZXN0IGNvbmZpZ3VyYXRpb24gYW5kIHNldHVwIGZpbGVzIC0gVHlwZVNjcmlwdCBFUyBNb2R1bGUgb25seVxuICAgKi9cbiAgc2NhZmZvbGRKZXN0U2V0dXAoKTogdm9pZCB7XG4gICAgLy8gR2VuZXJhdGUgSmVzdCBjb25maWcgZm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlc1xuICAgIGNvbnN0IGNvbmZpZyA9IGBcbi8vIGplc3QuY29uZmlnLmpzIC0gVHlwZVNjcmlwdCBFUyBNb2R1bGUgY29uZmlndXJhdGlvblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcmVzZXQ6ICd0cy1qZXN0L3ByZXNldHMvZGVmYXVsdC1lc20nLFxuICBleHRlbnNpb25zVG9UcmVhdEFzRXNtOiBbJy50cyddLFxuICB0ZXN0RW52aXJvbm1lbnQ6ICdub2RlJyxcbiAgc2V0dXBGaWxlc0FmdGVyRW52OiBbJzxyb290RGlyPi9qZXN0LXNldHVwLnRzJ10sXG4gIG1vZHVsZUZpbGVFeHRlbnNpb25zOiBbJ3RzJywgJ2pzJywgJ2pzb24nXSxcbiAgcm9vdHM6IFsnPHJvb3REaXI+J10sXG4gIHRlc3RNYXRjaDogW1xuICAgICcqKi8qLnRlc3QudHMnLCAgICAgICAgICAgLy8gU3RhbmRhcmQgdGVzdHMgYW55d2hlcmVcbiAgICAnKiovKi5HZW5lcmF0ZWRUZXN0LnRlc3QudHMnLCAvLyBHZW5lcmF0ZWQgdW5pdCB0ZXN0cyBuZXh0IHRvIHNvdXJjZSBmaWxlcyAgXG4gICAgJyoqL21hbnVhbC10ZXN0cy8qKi8qLnRlc3QudHMnLCAgICAgLy8gTWFudWFsIGZyYW1ld29yayB0ZXN0c1xuICAgICcqKi9nZW5lcmF0ZWQtdGVzdHMvKiovKi50ZXN0LnRzJyAgIC8vIEdlbmVyYXRlZCBpbnRlZ3JhdGlvbiB0ZXN0c1xuICBdLFxuICB0cmFuc2Zvcm06IHtcbiAgICAnXi4rXFxcXC50c3g/JCc6IFsndHMtamVzdCcsIHtcbiAgICAgIHVzZUVTTTogdHJ1ZSxcbiAgICAgIGlzb2xhdGVkTW9kdWxlczogdHJ1ZVxuICAgIH1dXG4gIH0sXG4gIG1vZHVsZU5hbWVNYXBwZXI6IHtcbiAgICAnXihcXFxcLnsxLDJ9Ly4qKVxcXFwuanMkJzogJyQxJyxcbiAgICAnXnF0ZXN0cy8oLiopJCc6ICc8cm9vdERpcj4vJDEnICAvLyBBbGxvdyBxdGVzdHMgdG8gaW1wb3J0IGZyb20gaXRzZWxmIGR1cmluZyB0ZXN0aW5nXG4gIH1cbn07XG5gLnRyaW0oKTtcblxuICAgIC8vIEdlbmVyYXRlIFR5cGVTY3JpcHQgRVMgbW9kdWxlIHNldHVwXG4gICAgY29uc3Qgc2V0dXAgPSBgXG4vLyBzZXR1cC50cyAtIFR5cGVTY3JpcHQgRVMgTW9kdWxlIHNldHVwIChQQVJBTExFTC1TQUZFKVxuaW1wb3J0ICdqZXN0JztcblxuLy8gR2xvYmFsIHRlc3QgY29uZmlndXJhdGlvbiBmb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGVzXG5iZWZvcmVBbGwoKCkgPT4ge1xuICAvLyBTZXQgdGVzdCBlbnZpcm9ubWVudFxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9ICd0ZXN0JztcbiAgXG4gIC8vIENvbmZpZ3VyZSB0ZXN0IHRpbWVvdXRzXG4gIGplc3Quc2V0VGltZW91dCgxMDAwMCk7XG59KTtcblxuLy8gQ2xlYW51cCBhZnRlciBlYWNoIHRlc3QgdG8gcHJldmVudCBpbnRlcmZlcmVuY2VcbmFmdGVyRWFjaCgoKSA9PiB7XG4gIC8vIENsZWFyIGFsbCBtb2Nrc1xuICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbn0pO1xuYC50cmltKCk7XG5cbiAgICB0aGlzLndyaXRlSWZNaXNzaW5nKCdqZXN0LmNvbmZpZy5qcycsIGNvbmZpZyk7XG4gICAgdGhpcy53cml0ZUlmTWlzc2luZygnc2V0dXAudHMnLCBzZXR1cCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgcXRlc3RzIHRlc3QgcnVubmVyIGZpbGUgLSBUeXBlU2NyaXB0IEVTIG1vZHVsZSBjb21wYXRpYmxlXG4gICAqL1xuICBnZW5lcmF0ZVF0ZXN0c1J1bm5lcigpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgLy8gUmVhZCB0aGUgZXhpc3RpbmcgcXRlc3RzLXJ1bm5lci50cyBhcyB0ZW1wbGF0ZVxuICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGdldE1vZHVsZURpcm5hbWVGb3JUZXN0R2VuZXJhdG9yKCksICcuLicsICdxdGVzdHMtcnVubmVyLnRzJyk7XG4gICAgICBsZXQgdGVtcGxhdGUgPSAnJztcbiAgICAgIFxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmModGVtcGxhdGVQYXRoKSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IGZzLnJlYWRGaWxlU3luYyh0ZW1wbGF0ZVBhdGgsICd1dGY4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayB0ZW1wbGF0ZSBmb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGVzIHdpdGggY29ycmVjdCBKZXN0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgdGVtcGxhdGUgPSBgXG4vLyBHZW5lcmF0ZWQgcXRlc3RzIHJ1bm5lciAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIGNvbXBhdGlibGVcbmltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuLy8gUnVuIHRlc3RzIHdpdGggVHlwZVNjcmlwdCBzdXBwb3J0IGFuZCBjb3JyZWN0IEplc3QgYXJndW1lbnRzXG5jb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuY29uc3QgdGVzdFByb2Nlc3MgPSBzcGF3bignamVzdCcsIGFyZ3MsIHtcbiAgc3RkaW86ICdpbmhlcml0JyxcbiAgc2hlbGw6IHRydWVcbn0pO1xuXG50ZXN0UHJvY2Vzcy5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gIHByb2Nlc3MuZXhpdChjb2RlIHx8IDApO1xufSk7XG5gLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWx3YXlzIG92ZXJ3cml0ZSBxdGVzdHMtcnVubmVyLnRzIHRvIGVuc3VyZSBsYXRlc3QgZnVuY3Rpb25hbGl0eSBhbmQgVHlwZVNjcmlwdCBjb21wbGlhbmNlXG4gICAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdxdGVzdHMtcnVubmVyLnRzJyk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIHRlbXBsYXRlLCAndXRmOCcpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEdlbmVyYXRlZCBxdGVzdHMtcnVubmVyLnRzIGZvciBUeXBlU2NyaXB0IEVTIG1vZHVsZXMnKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgcXRlc3RzLXJ1bm5lci50czonLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHBhY2thZ2UuanNvbiB0ZXN0IHNjcmlwdCB0byB1c2UgcXRlc3RzLXJ1bm5lci50c1xuICAgKi9cbiAgdXBkYXRlUGFja2FnZUpzb25UZXN0U2NyaXB0KCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncGFja2FnZS5qc29uJyk7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGFja2FnZVBhdGgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIHBhY2thZ2UuanNvbiBub3QgZm91bmQsIHNraXBwaW5nIHRlc3Qgc2NyaXB0IHVwZGF0ZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGFja2FnZVBhdGgsICd1dGY4JykpO1xuICAgICAgXG4gICAgICBpZiAoIXBhY2thZ2VKc29uLnNjcmlwdHMpIHtcbiAgICAgICAgcGFja2FnZUpzb24uc2NyaXB0cyA9IHt9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBwYWNrYWdlSnNvbi5zY3JpcHRzLnRlc3QgPSAnbnB4IHRzeCBxdGVzdHMtcnVubmVyLnRzJztcbiAgICAgIFxuICAgICAgZnMud3JpdGVGaWxlU3luYyhwYWNrYWdlUGF0aCwgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb24sIG51bGwsIDIpLCAndXRmOCcpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBVcGRhdGVkIHBhY2thZ2UuanNvbiB0ZXN0IHNjcmlwdCB0byB1c2UgcXRlc3RzLXJ1bm5lci50cycpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIENvdWxkIG5vdCB1cGRhdGUgcGFja2FnZS5qc29uOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FuIGZvciBmaWxlcyB3aXRob3V0IHRlc3RzIGFuZCBnZW5lcmF0ZSB0aGVtIC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUZXN0RmlsZXMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gU2Nhbm5pbmcgZm9yIGZpbGVzIHRoYXQgbmVlZCBUeXBlU2NyaXB0IHRlc3RzLi4uJyk7XG4gICAgXG4gICAgY29uc3QgYWxsRmlsZXMgPSB0aGlzLndhbGtQcm9qZWN0KCk7XG4gICAgY29uc3QgeyBzb3VyY2VGaWxlcyB9ID0gdGhpcy5jYXRlZ29yaXplRmlsZXMoYWxsRmlsZXMpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5OBIEZvdW5kICR7c291cmNlRmlsZXMubGVuZ3RofSBzb3VyY2UgZmlsZXMgd2l0aG91dCB0ZXN0c2ApO1xuICAgIFxuICAgIGlmIChzb3VyY2VGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQWxsIHNvdXJjZSBmaWxlcyBhbHJlYWR5IGhhdmUgY29ycmVzcG9uZGluZyB0ZXN0cycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZW5lcmF0ZSB0ZXN0cyBmb3IgZWFjaCBzb3VyY2UgZmlsZVxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBzb3VyY2VGaWxlcykge1xuICAgICAgdGhpcy5hbmFseXplKGZpbGUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHdheXMgc2V0IHVwIEplc3QgY29uZmlndXJhdGlvbiBhbmQgcnVubmVyIHRvIGVuc3VyZSB0aGV5J3JlIHVwLXRvLWRhdGVcbiAgICB0aGlzLnNjYWZmb2xkSmVzdFNldHVwKCk7XG4gICAgdGhpcy5nZW5lcmF0ZVF0ZXN0c1J1bm5lcigpO1xuICAgIHRoaXMudXBkYXRlUGFja2FnZUpzb25UZXN0U2NyaXB0KCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk50gR2VuZXJhdGVkICR7dGhpcy5zY2FubmVkLmxlbmd0aH0gVHlwZVNjcmlwdCB0ZXN0IGZpbGVzOmApO1xuICAgIHRoaXMuc2Nhbm5lZC5mb3JFYWNoKHRlc3QgPT4ge1xuICAgICAgY29uc29sZS5sb2coYCAgICR7dGVzdC50eXBlfTogJHt0ZXN0LmZpbGV9YCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNjYW4gcmVzdWx0c1xuICAgKi9cbiAgZ2V0UmVzdWx0cygpOiBTY2FubmVkVGVzdFtdIHtcbiAgICByZXR1cm4gdGhpcy5zY2FubmVkO1xuICB9XG59XG5cbi8vIEV4cG9ydCB0aGUgVGVzdEdlbmVyYXRvciBjbGFzcyB1c2luZyBFUyBtb2R1bGUgc3ludGF4XG5leHBvcnQgeyBUZXN0R2VuZXJhdG9yIH07XG5leHBvcnQgZGVmYXVsdCBUZXN0R2VuZXJhdG9yOyJdLCJ2ZXJzaW9uIjozfQ==