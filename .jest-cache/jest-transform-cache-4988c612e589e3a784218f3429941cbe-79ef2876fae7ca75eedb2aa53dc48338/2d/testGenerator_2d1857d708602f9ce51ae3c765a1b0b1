f05a997ec71a827d6e34e3cb0d1ae4c7
"use strict";
/**
 * Test Generator for qtests Framework - TypeScript Implementation
 *
 * Automatically generates unit tests and API tests by scanning source code.
 * Analyzes JavaScript/TypeScript files to detect exports, imports, and API routes,
 * then creates appropriate test files with proper structure and mocking.
 *
 * Features:
 * - Unit test generation for exported functions/classes
 * - API test generation for Express routes
 * - Automatic mock setup for known libraries
 * - Jest configuration scaffolding
 * - Support for qtests framework integration
 * - TypeScript ES module only (no version duplication)
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestGenerator = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const esm_globals_js_1 = require("../utils/esm-globals.js");
// ES Module __dirname equivalent - lazy initialization to avoid Jest issues
let moduleDirname;
function getModuleDirnameForTestGenerator() {
    if (moduleDirname === undefined) {
        // Use a try-catch to handle Jest environment gracefully
        try {
            // Use eval to hide import.meta from Jest's static parser
            const importMetaUrl = (0, eval)('import.meta.url');
            moduleDirname = (0, esm_globals_js_1.getModuleDirname)(importMetaUrl);
        }
        catch (error) {
            // Fallback for Jest environment
            moduleDirname = process.cwd();
        }
    }
    return moduleDirname;
}
// Configuration constants - TypeScript ES module only
const DEFAULT_CONFIG = {
    SRC_DIR: '.',
    TEST_DIR: 'generated-tests',
    KNOWN_MOCKS: ['axios', 'node-fetch', 'pg', 'mongoose', 'fs', 'redis'],
    VALID_EXTS: ['.ts', '.js', '.tsx', '.jsx']
};
// Regex patterns for code analysis - Enhanced for both ES modules and CommonJS
const PATTERNS = {
    qtests: /from ['"]qtests['"]|require\(['"]qtests['"]\)/,
    api: /\b(app|router)\.(get|post|put|delete|patch)\s*\(\s*['"`]([^'"`]+)['"`]/gi,
    // ES module exports: export const, export function, export class
    exportsES: /^\s*export\s+(?:const|function|class)\s+([a-zA-Z0-9_]+)/gm,
    // ES module named exports: export { name1, name2, name3 }
    exportsNamed: /export\s*\{\s*([^}]+)\s*\}/g,
    // ES module default exports: export default SomeName
    exportsDefault: /export\s+default\s+([a-zA-Z0-9_]+)/g,
    // CommonJS exports: module.exports = {}, module.exports.name =, exports.name =
    exportsCommonJS: /(?:module\.exports\.([a-zA-Z0-9_]+)\s*=|exports\.([a-zA-Z0-9_]+)\s*=|module\.exports\s*=\s*([a-zA-Z0-9_]+))/gm,
    // Function declarations that might be exported
    functionDeclarations: /^\s*(?:async\s+)?function\s+([a-zA-Z0-9_]+)\s*\(/gm,
    // Class declarations that might be exported
    classDeclarations: /^\s*class\s+([a-zA-Z0-9_]+)/gm,
    imports: /from ['"]([^'"]+)['"]|require\(['"]([^'"]+)['"]\)/g
};
class TestGenerator {
    constructor(options = {}) {
        // Precompiled include/exclude regexes for fast filtering
        this.includeRegexes = [];
        this.excludeRegexes = [];
        this.config = { ...DEFAULT_CONFIG, ...options };
        this.scanned = [];
        this.isESModule = this.detectESModule(); // Detect module type once during initialization
        // Compile include/exclude glob patterns to regex for matching
        this.includeRegexes = (this.config.include || []).map(this.globToRegExp);
        this.excludeRegexes = (this.config.exclude || []).map(this.globToRegExp);
    }
    /**
     * Detect if the current project uses ES modules or CommonJS
     * Since we're now "TypeScript ES module only", this defaults to true for TypeScript projects
     */
    detectESModule() {
        try {
            // Check package.json for explicit "type": "module"
            const packagePath = path_1.default.resolve(process.cwd(), 'package.json');
            if (fs_1.default.existsSync(packagePath)) {
                const packageJson = JSON.parse(fs_1.default.readFileSync(packagePath, 'utf8'));
                if (packageJson.type === 'module') {
                    return true;
                }
                // For TypeScript ES module only approach, prefer ES modules when TypeScript is detected
                if (packageJson.devDependencies?.typescript || packageJson.dependencies?.typescript) {
                    return true;
                }
            }
            // Check for ES module patterns in source files (excluding test files and node_modules)
            const sourceFiles = this.walkProject()
                .filter(file => {
                const ext = path_1.default.extname(file);
                const isValidExt = this.config.VALID_EXTS.includes(ext);
                const isTestFile = this.isTestFile(path_1.default.basename(file));
                const isNodeModules = file.includes('node_modules');
                return isValidExt && !isTestFile && !isNodeModules;
            })
                .slice(0, 10); // Sample first 10 files for performance
            let esModuleCount = 0;
            let commonJSCount = 0;
            for (const file of sourceFiles) {
                try {
                    const content = fs_1.default.readFileSync(file, 'utf8');
                    // Look for ES module patterns (import OR export statements)
                    if (content.includes('import ') || content.includes('export ')) {
                        esModuleCount++;
                    }
                    // Look for CommonJS patterns
                    if (content.includes('require(') || content.includes('module.exports')) {
                        commonJSCount++;
                    }
                }
                catch (error) {
                    // Skip files we can't read
                    continue;
                }
            }
            // For TypeScript ES module only approach, prefer ES modules when equal or when TypeScript files are present
            if (esModuleCount === 0 && commonJSCount === 0) {
                return true; // Default to ES modules for TypeScript ES module only approach
            }
            if (esModuleCount === 0) {
                return false; // No ES module patterns found, default to CommonJS
            }
            return esModuleCount >= commonJSCount; // Changed from > to >= to prefer ES modules
        }
        catch (error) {
            // Default to ES modules for TypeScript ES module only approach
            return true;
        }
    }
    /**
     * Check if directory should be skipped during discovery
     */
    shouldSkipDirectory(dirName) {
        const skipPatterns = [
            'node_modules', '.git', '.next', 'dist', 'build', 'coverage',
            '.vscode', '.idea', 'docs', 'documentation', 'assets', 'public', 'static',
            '.replit_cache', '.config', '.npm', 'logs',
            'examples', 'demo', 'demos', 'samples', 'bin',
            // Skip common test and generated directories
            '__mocks__', '__tests__', 'tests', 'test', 'generated-tests',
            // Skip manual test directories and fixtures
            'manual-tests', 'fixtures', 'test-fixtures'
        ];
        return skipPatterns.includes(dirName) || dirName.startsWith('.');
    }
    /**
     * Walk entire project directory structure, respecting skip patterns
     */
    walkProject() {
        const root = this.config.SRC_DIR
            ? path_1.default.resolve(process.cwd(), this.config.SRC_DIR)
            : process.cwd();
        return this.walkRecursive(root);
    }
    /**
     * Recursively walk directory and return all file paths, skipping irrelevant directories
     */
    walkRecursive(dir) {
        if (!fs_1.default.existsSync(dir)) {
            return [];
        }
        return fs_1.default.readdirSync(dir, { withFileTypes: true }).flatMap(entry => {
            const full = path_1.default.resolve(dir, entry.name);
            if (entry.isDirectory()) {
                // Skip directories that shouldn't contain tests or source files
                if (this.shouldSkipDirectory(entry.name)) {
                    return [];
                }
                return this.walkRecursive(full);
            }
            else {
                return [full];
            }
        });
    }
    /**
     * Convert a glob pattern (supports *, **, ?) into a RegExp
     * - *  matches any sequence except path separator
     * - ** matches any sequence including path separators
     * - ?  matches a single character except path separator
     */
    globToRegExp(pattern) {
        // Normalize to posix style for matching
        let pat = pattern.replace(/\\/g, '/');
        // Escape regex special chars, except our glob tokens * ?
        pat = pat.replace(/([.+^${}()|\[\]\\])/g, '\\$1');
        // Convert ** to a special token first to avoid conflict with *
        pat = pat.replace(/\*\*/g, '::GLOBSTAR::');
        // Convert remaining * and ?
        pat = pat.replace(/\*/g, '[^/]*').replace(/\?/g, '[^/]');
        // Convert GLOBSTAR
        pat = pat.replace(/::GLOBSTAR::/g, '.*');
        // Anchor pattern
        pat = '^' + pat + '$';
        return new RegExp(pat);
    }
    /**
     * Check include/exclude patterns against a path (posix normalized)
     */
    pathMatchesFilters(filePath) {
        const posixPath = filePath.replace(/\\/g, '/');
        // Apply exclude first
        if (this.excludeRegexes.some(rx => rx.test(posixPath))) {
            return false;
        }
        // If includes provided, must match at least one include
        if (this.includeRegexes.length > 0) {
            return this.includeRegexes.some(rx => rx.test(posixPath));
        }
        return true; // No includes means include all (after excludes)
    }
    /**
     * Legacy walk method for backwards compatibility (walks single directory)
     */
    walk(dir) {
        if (!fs_1.default.existsSync(dir)) {
            return [];
        }
        return fs_1.default.readdirSync(dir, { withFileTypes: true }).flatMap(entry => {
            const full = path_1.default.resolve(dir, entry.name);
            return entry.isDirectory() ? this.walk(full) : [full];
        });
    }
    /**
     * Check if file should be skipped as a source file (config, setup, etc.)
     */
    shouldSkipSourceFile(file) {
        const basename = path_1.default.basename(file);
        const dirname = path_1.default.dirname(file);
        // Skip files in test-related directories
        if (dirname.includes('manual-tests') || dirname.includes('fixtures')) {
            return true;
        }
        const skipPatterns = [
            /^jest\.config\./, // Jest config files
            /^jest-setup\./, // Jest setup files
            /^setup\./, // Setup files
            /^config\./, // Config files  
            /-demo\./, // Demo files
            /-example\./, // Example files
            /\.config\./, // Any config files
            /^example\./, // Files named "example.*"
            /^demo\./, // Files named "demo.*"
            /qtests-runner\./, // Generated runner files
            /setupMultiple/, // Test setup helpers
            /reloadCheck/, // Test utilities
            /testSetup/, // Test setup files
        ];
        return skipPatterns.some(pattern => pattern.test(basename));
    }
    /**
     * Categorize discovered files into source files and existing tests
     */
    categorizeFiles(files) {
        const sourceFiles = [];
        const existingTests = [];
        files.forEach(file => {
            const ext = path_1.default.extname(file);
            const basename = path_1.default.basename(file);
            // Skip files with invalid extensions
            if (!this.config.VALID_EXTS.includes(ext)) {
                return;
            }
            // Apply CLI include/exclude filters against project-relative path
            const relFromCwd = path_1.default.relative(process.cwd(), file);
            if (!this.pathMatchesFilters(relFromCwd)) {
                return;
            }
            // Skip config, demo, and setup files
            if (this.shouldSkipSourceFile(file)) {
                return;
            }
            // Check if this is a test file
            if (this.isTestFile(basename)) {
                existingTests.push(file);
            }
            else {
                // Check if this source file already has a corresponding test
                const hasTest = this.hasCorrespondingTest(file, files);
                if (!hasTest) {
                    sourceFiles.push(file);
                }
            }
        });
        return { sourceFiles, existingTests };
    }
    /**
     * Check if filename indicates it's a test file
     */
    isTestFile(filename) {
        const testPatterns = [
            /\.test\./,
            /\.spec\./,
            /_test\./,
            /_spec\./,
            /\.e2e\./,
            /\.integration\./
        ];
        return testPatterns.some(pattern => pattern.test(filename));
    }
    /**
     * Check if a source file has a corresponding test file
     */
    hasCorrespondingTest(sourceFile, allFiles) {
        const dir = path_1.default.dirname(sourceFile);
        const basename = path_1.default.basename(sourceFile, path_1.default.extname(sourceFile));
        const ext = path_1.default.extname(sourceFile);
        // Common test file patterns to look for - TypeScript ES module only
        const testPatterns = [
            `${basename}.test.ts`,
            `${basename}.GenerateTest.test.ts`, // Updated generated unit test pattern  
            `${basename}GeneratedTest.test.ts`, // Legacy pattern for backwards compatibility
            `${basename}.spec.ts`,
            `${basename}_test.ts`,
            `${basename}_spec.ts`,
            `${basename}.test${ext}`,
            `${basename}.spec${ext}`
        ];
        // Look for test files in the same directory
        const sameDirectoryTests = testPatterns.map(pattern => path_1.default.join(dir, pattern));
        // Look for test files in common test directories
        const testDirectories = ['tests', 'test', '__tests__', 'spec'];
        const testDirectoryTests = testDirectories.flatMap(testDir => {
            const testPath = path_1.default.join(dir, testDir);
            return testPatterns.map(pattern => path_1.default.join(testPath, pattern));
        });
        // Check if any of these test files exist
        const allTestPaths = [...sameDirectoryTests, ...testDirectoryTests];
        // Normalize paths for comparison - convert both to absolute paths
        const normalizedAllFiles = allFiles.map(file => path_1.default.resolve(file));
        const normalizedTestPaths = allTestPaths.map(testPath => path_1.default.resolve(testPath));
        return normalizedTestPaths.some(testPath => normalizedAllFiles.includes(testPath));
    }
    /**
     * Detect if source file or content indicates React usage
     */
    detectReactUsage(file, content = '') {
        // Check file extension
        if (file.endsWith('.tsx') || file.endsWith('.jsx')) {
            return true;
        }
        // Check for React imports
        const reactImports = /import.*(?:react|React|@types\/react)/i.test(content);
        if (reactImports)
            return true;
        // Check for JSX patterns
        const jsxPatterns = [
            /<[A-Z][a-zA-Z0-9]*[\s\/>]/, // Component tags like <MyComponent
            /<[a-z]+[\s\/>]/, // HTML tags like <div>
            /React\.createElement/, // React.createElement calls
            /jsx.*:/, // JSX pragma
        ];
        return jsxPatterns.some(pattern => pattern.test(content));
    }
    /**
     * Detect if export name is likely a React hook
     */
    isReactHook(exportName) {
        return exportName.startsWith('use') && exportName.length > 3;
    }
    /**
     * Detect if export name is likely a React component
     */
    isReactComponent(exportName, content = '') {
        // Check if it starts with uppercase (component convention)
        if (!/^[A-Z]/.test(exportName))
            return false;
        // Check if it's defined as a function that might return JSX
        const componentPatterns = [
            new RegExp(`function\\s+${exportName}\\s*\\(`),
            new RegExp(`const\\s+${exportName}\\s*=\\s*\\(`),
            new RegExp(`export\\s+function\\s+${exportName}\\s*\\(`),
            new RegExp(`${exportName}\\s*=\\s*\\(.*\\)\\s*=>`) // Arrow function
        ];
        return componentPatterns.some(pattern => pattern.test(content));
    }
    /**
     * Heuristically detect if a React component likely requires props.
     * - TS inline prop types without ?: required (e.g., props: { id: string })
     * - Destructured props without defaults (e.g., function C({ id }: { id: string }))
     * - propTypes with isRequired
     */
    componentRequiresProps(exportName, content = '') {
        try {
            // 1) propTypes isRequired
            const propTypesReq = new RegExp(`${exportName}\.propTypes\s*=\s*\{[\s\S]*?isRequired`, 'm');
            if (propTypesReq.test(content))
                return true;
            // 2) TS inline type with required fields (no ?)
            // Simple conservative detection for inline typed props/destructuring with inline types
            const tsInlineSimple = new RegExp(`${exportName}[\\s\\S]*\\(\\s*props\\s*:\\s*\\{[^}]+\\}`, 'm');
            const tsDestructuredSimple = new RegExp(`${exportName}[\\s\\S]*\\(\\s*\\{[^}]+\\}\\s*:\\s*\\{[^}]+\\}`, 'm');
            if (tsInlineSimple.test(content) || tsDestructuredSimple.test(content)) {
                return true;
            }
            const tsInline1 = new RegExp(`(?:export\\s+)?function\\s+${exportName}\\s*\\(\\s*props\\s*:\\s*\\{([\\n\\r\\t \\w:<>\\|\\[\\]\\n\\r,?]+)\\}\\s*\\)`, 'm');
            const tsInline2 = new RegExp(`(?:export\s+)?const\s+${exportName}\s*=\s*\(\s*props\s*:\s*\{([\n\r\t \w:<>\|\[\]\n\r,?]+)\}\s*\)`, 'm');
            const tsDestructured = new RegExp(`(?:export\s+)?function\s+${exportName}\s*\(\s*\{([^}=]+)\}\s*:\s*\{([^}]+)\}\s*\)`, 'm');
            const tsArrowDestructured = new RegExp(`(?:export\s+)?const\s+${exportName}\s*=\s*\(\s*\{([^}=]+)\}\s*:\s*\{([^}]+)\}\s*\)`, 'm');
            const matches = [tsInline1.exec(content), tsInline2.exec(content), tsDestructured.exec(content), tsArrowDestructured.exec(content)];
            for (const m of matches) {
                if (!m)
                    continue;
                const typeBlock = (m[1] || m[2] || '').trim();
                if (!typeBlock)
                    continue;
                // If any field lacks ?, assume required
                const fields = typeBlock.split(',');
                for (const f of fields) {
                    const field = f.trim();
                    if (!field)
                        continue;
                    // Example: id?: string vs id: string
                    if (/^[A-Za-z_$][\w$]*\s*:\s*[^?]/.test(field)) {
                        return true;
                    }
                }
            }
            // 3) Destructured props without default object for param (no = {})
            const destructuredNoDefaultFn = new RegExp(`(?:export\s+)?function\s+${exportName}\s*\(\s*\{([^}]+)\}\s*\)`, 'm');
            const destructuredNoDefaultArrow = new RegExp(`(?:export\s+)?const\s+${exportName}\s*=\s*\(\s*\{([^}]+)\}\s*\)`, 'm');
            if (destructuredNoDefaultFn.test(content) || destructuredNoDefaultArrow.test(content)) {
                // If the param includes = {}, it's optional; otherwise assume required
                const paramWithDefault = new RegExp(`${exportName}[^\n]*\(\s*\{[^}]+\}\s*=\s*\{\}\s*\)`);
                if (!paramWithDefault.test(content))
                    return true;
            }
            return false;
        }
        catch {
            return false;
        }
    }
    /**
     * Generate test file path based on source file and test type
     * React-aware: generates .tsx for React components/hooks, .ts otherwise
     */
    getRelativeTestPath(file, type = 'unit', content = '') {
        const dir = path_1.default.dirname(file);
        const basename = path_1.default.basename(file, path_1.default.extname(file));
        // Determine test file extension based on React usage
        const isReactFile = this.detectReactUsage(file, content);
        const testExt = isReactFile ? '.tsx' : '.ts';
        if (type === 'unit') {
            // For unit tests, place them alongside the source file with GeneratedTest naming
            return path_1.default.join(dir, `${basename}.GenerateTest.test${testExt}`);
        }
        else {
            // For API/integration tests, use the configured test directory with appropriate extension
            const rel = path_1.default.relative(process.cwd(), file);
            return path_1.default.join(this.config.TEST_DIR, rel.replace(/\.[tj]sx?$/, `.GenerateTest.test${testExt}`).replace(/[\\/]/g, '__'));
        }
    }
    /**
     * Create directory if it doesn't exist
     */
    createDir(p) {
        const dir = path_1.default.dirname(p);
        if (!fs_1.default.existsSync(dir)) {
            fs_1.default.mkdirSync(dir, { recursive: true });
        }
    }
    /**
     * Write file only if it doesn't already exist, unless force flag is set
     * Supports dry-run mode for previewing planned files
     */
    writeIfMissing(p, content, dryRun = false) {
        const exists = fs_1.default.existsSync(p);
        // Allow overwrite only for files generated by this tool (contain ".GenerateTest")
        const isGeneratedTest = p.includes('.GenerateTest');
        const canWrite = !exists || (Boolean(this.config.force) && isGeneratedTest);
        if (dryRun) {
            // In dry-run mode, just log what would be written
            console.log(`${exists ? '[WOULD OVERWRITE]' : '[WOULD CREATE]'} ${path_1.default.relative('.', p)}`);
            return canWrite;
        }
        if (canWrite) {
            this.createDir(p);
            fs_1.default.writeFileSync(p, content, 'utf8');
            return true;
        }
        return false;
    }
    /**
     * Extract imported modules from file content - Enhanced for both ES modules and CommonJS
     */
    getUsedModules(content) {
        return [...content.matchAll(PATTERNS.imports)]
            .map(m => m[1] || m[2]) // m[1] for ES modules, m[2] for CommonJS
            .filter(x => x && !x.startsWith('.') && !x.startsWith('/'));
    }
    /**
     * Ensure a local copy of API test utilities exists at generated-tests/utils/httpTest.ts
     * so that generated integration tests work without extra project wiring.
     * Idempotent: only writes if missing.
     */
    ensureLocalHttpTestUtils() {
        try {
            const targetDir = path_1.default.join(process.cwd(), this.config.TEST_DIR || 'generated-tests', 'utils');
            const targetFile = path_1.default.join(targetDir, 'httpTest.ts');
            if (fs_1.default.existsSync(targetFile))
                return;
            // Try to read the package's httpTest.ts to copy over
            const src = path_1.default.join(getModuleDirnameForTestGenerator(), '..', 'utils', 'httpTest.ts');
            let content = '';
            try {
                content = fs_1.default.readFileSync(src, 'utf8');
            }
            catch {
                // Minimal fallback shim if the source cannot be found
                content = [
                    `// Minimal httpTest shim for generated integration tests`,
                    `export { default as supertest } from 'supertest';`,
                    `export function createMockApp() { throw new Error('createMockApp not available in shim'); }`
                ].join('\n');
            }
            fs_1.default.mkdirSync(targetDir, { recursive: true });
            fs_1.default.writeFileSync(targetFile, content, 'utf8');
            console.log(`✅ Scaffoled local API test utils at ${path_1.default.relative(process.cwd(), targetFile)}`);
        }
        catch (err) {
            console.warn('⚠️  Could not scaffold local httpTest utils:', err?.message || String(err));
        }
    }
    /**
     * Detect if code uses Date or Math.random for deterministic test helpers
     * 🚩AI: DETERMINISM_HELPERS — fake timers and seeded randomness scaffolding
     */
    detectNonDeterministicCode(content) {
        const usesDate = /new Date\(|Date\.now\(|\.getTime\(/.test(content);
        const usesRandom = /Math\.random\(/.test(content);
        return { usesDate, usesRandom };
    }
    /**
     * Optional TypeScript AST analysis for better type inference
     * 🚩AI: TYPE_INFERENCE_OPTION — dynamic import('typescript') with heuristics fallback
     */
    async tryTypeScriptAnalysis(file, content) {
        try {
            // Dynamic import of TypeScript - only if available
            const ts = await Promise.resolve().then(() => __importStar(require('typescript'))).catch(() => null);
            if (!ts) {
                return null;
            }
            // Parse the TypeScript source
            const sourceFile = ts.createSourceFile(file, content, ts.ScriptTarget.Latest, true);
            const functions = [];
            // Visitor function to extract function declarations with types
            const visit = (node) => {
                if (ts.isFunctionDeclaration(node) && node.name) {
                    const funcName = node.name.getText();
                    const params = node.parameters.map((param) => ({
                        name: param.name.getText(),
                        type: param.type ? param.type.getText() : 'any'
                    }));
                    functions.push({ name: funcName, params });
                }
                ts.forEachChild(node, visit);
            };
            visit(sourceFile);
            return { functions };
        }
        catch (error) {
            // Fallback gracefully if TypeScript analysis fails
            console.log(`TypeScript analysis failed: ${error.message}`);
            return null;
        }
    }
    /**
     * Generate sample values based on TypeScript types
     */
    generateSampleValue(type) {
        const cleanType = type.toLowerCase().trim();
        switch (cleanType) {
            case 'string':
                return `'test-string'`;
            case 'number':
                return '42';
            case 'boolean':
                return 'true';
            case 'array':
            case 'string[]':
                return `['item1', 'item2']`;
            case 'number[]':
                return '[1, 2, 3]';
            case 'object':
                return `{ key: 'value' }`;
            default:
                if (cleanType.endsWith('[]')) {
                    return '[]';
                }
                if (cleanType.includes('|')) {
                    // Union type - pick first option
                    const firstType = cleanType.split('|')[0].trim();
                    return this.generateSampleValue(firstType);
                }
                return 'undefined';
        }
    }
    /**
     * Detect if function has parameterized logic suitable for table-driven tests
     */
    detectParameterizedLogic(content, functionName) {
        // Look for the function definition
        const funcRegex = new RegExp(`function\\s+${functionName}\\s*\\([^)]*\\)\\s*\\{([^}]+)\\}`, 'i');
        const match = content.match(funcRegex);
        if (!match)
            return false;
        const functionBody = match[1];
        // Heuristics for parameterized logic
        const hasConditionals = /if\s*\(|switch\s*\(|case\s+/.test(functionBody);
        const hasArithmetic = /[+\-*/%]/.test(functionBody);
        const hasComparisons = /[<>=!]+/.test(functionBody);
        const hasStringOps = /\.split\(|\.substring\(|\.slice\(/.test(functionBody);
        return hasConditionals || hasArithmetic || hasComparisons || hasStringOps;
    }
    /**
     * Generate realistic test inputs based on function parameters
     */
    generateRealisticInputs(functionName, params) {
        const inputs = [];
        const paramNames = [];
        params.forEach(param => {
            paramNames.push(param.name);
            // Generate contextually appropriate values based on parameter name
            const paramName = param.name.toLowerCase();
            const paramType = param.type.toLowerCase();
            if (paramName.includes('id') || paramName.includes('uuid')) {
                inputs.push(paramType === 'string' ? `'user-123'` : '123');
            }
            else if (paramName.includes('name') || paramName.includes('title')) {
                inputs.push(`'TestName'`);
            }
            else if (paramName.includes('email')) {
                inputs.push(`'test@example.com'`);
            }
            else if (paramName.includes('age') || paramName.includes('count')) {
                inputs.push('25');
            }
            else if (paramName.includes('url') || paramName.includes('path')) {
                inputs.push(`'/api/test'`);
            }
            else if (paramName.includes('data') || paramName.includes('payload')) {
                inputs.push(`{ test: 'data' }`);
            }
            else {
                inputs.push(this.generateSampleValue(param.type));
            }
        });
        const expectedPattern = `// Expected: meaningful result based on ${paramNames.join(', ')}`;
        return { inputs, expectedPattern };
    }
    /**
     * Generate deterministic helpers for tests that need them
     */
    generateDeterministicHelpers(usesDate, usesRandom) {
        const helpers = [];
        if (usesDate || usesRandom) {
            helpers.push(`// Deterministic test helpers`);
            helpers.push(`beforeEach(() => {`);
            if (usesDate) {
                helpers.push(`  // Fix time for deterministic Date behavior`);
                helpers.push(`  jest.useFakeTimers().setSystemTime(new Date('2023-01-01T00:00:00Z'));`);
            }
            if (usesRandom) {
                helpers.push(`  // Seed Math.random for deterministic behavior`);
                helpers.push(`  let seed = 12345;`);
                helpers.push(`  Math.random = jest.fn(() => {`);
                helpers.push(`    seed = (seed * 9301 + 49297) % 233280;`);
                helpers.push(`    return seed / 233280;`);
                helpers.push(`  });`);
            }
            helpers.push(`});`);
            helpers.push(``);
            if (usesDate) {
                helpers.push(`afterEach(() => {`);
                helpers.push(`  jest.useRealTimers();`);
                helpers.push(`});`);
                helpers.push(``);
            }
        }
        return helpers;
    }
    /**
     * Generate React component test using React.createElement (no JSX)
     */
    createReactComponentTest(exportName, basename, useReactQueryProvider) {
        const renderLine = useReactQueryProvider
            ? `const { container } = render(React.createElement(Providers as any, {}, React.createElement(Component as any, {})));`
            : `const { container } = render(React.createElement(Component as any, {}));`;
        return [
            `describe('${exportName} Component', () => {`,
            `  it('renders without crashing', () => {`,
            `    // Resolve component from exports`,
            `    const Component = (testModule as any).default ?? (testModule as any)['${exportName}'];`,
            `    expect(Component).toBeDefined();`,
            `    // Smoke render using React.createElement (no JSX)`,
            `    ${renderLine}`,
            `    expect(container).toBeDefined();`,
            `  });`,
            `});`,
            ``
        ];
    }
    /**
     * Generate React hook test using wrapper component
     */
    createReactHookTest(exportName, basename, useReactQueryProvider) {
        const probeRender = useReactQueryProvider
            ? `render(React.createElement(Providers as any, {}, React.createElement(HookProbe)))`
            : `render(React.createElement(HookProbe))`;
        return [
            `describe('${exportName} Hook', () => {`,
            `  it('mounts via probe without errors', () => {`,
            `    // Create hook probe component (never call hooks outside a component)`,
            `    function HookProbe() {`,
            `      const hookResult = (testModule as any)['${exportName}']();`,
            `      return React.createElement('div', { 'data-testid': 'hook-result' }, String(!!hookResult));`,
            `    }`,
            `    const { getByTestId } = ${probeRender};`,
            `    const result = getByTestId('hook-result');`,
            `    expect(result).toBeDefined();`,
            `  });`,
            `});`,
            ``
        ];
    }
    /**
     * Generate unit test content for a file - TypeScript ES module with React support
     * 🚩AI: ENTRY_POINT_FOR_GENERATED_TEST_IMPORTS — insert `import 'qtests/setup'` first
     * 🚩AI: UNIT_TEMPLATE_SECTION — write per-export describe/it with positive + edge
     */
    createUnitTest(file, exports, usesQtests, mocks, content = '') {
        const basename = path_1.default.basename(file, path_1.default.extname(file));
        const ext = path_1.default.extname(file);
        const lines = [
            `// Generated unit test for ${path_1.default.basename(file)} - TypeScript ES module`,
            `// 🚩AI: ENTRY_POINT_FOR_GENERATED_TEST_IMPORTS`,
            `import 'qtests/setup';`, // Always import qtests/setup first
            ``
        ];
        // Detect if this is a React file and whether it uses React Query
        const isReactFile = this.detectReactUsage(file, content);
        const usesReactQuery = /@tanstack\/react-query/.test(content);
        const wantsRouter = Boolean(this.config.withRouter);
        const detectsRouter = /react-router(?:-dom)?/.test(content);
        const usesReactRouter = isReactFile && wantsRouter && detectsRouter;
        // Import the module being tested (no extension for better ts-jest compatibility)
        lines.push(`import * as testModule from './${basename}';`);
        // Add React imports if needed
        if (isReactFile) {
            lines.push(`import * as React from 'react';`);
            lines.push(`import { render } from '@testing-library/react';`);
            if (usesReactRouter) {
                // Prefer matching the imported module from source when possible
                const routerModule = content.includes('react-router-dom') ? 'react-router-dom' : 'react-router';
                lines.push(`import { MemoryRouter } from '${routerModule}';`);
            }
            if (usesReactQuery) {
                lines.push(`import { QueryClient, QueryClientProvider } from '@tanstack/react-query';`);
            }
            if (usesReactQuery || usesReactRouter) {
                // Compose providers deterministically: MemoryRouter (outer) -> QueryClientProvider (inner)
                lines.push(`// Minimal provider composition for tests`);
                lines.push(`const Providers: React.FC<{ children?: React.ReactNode }> = ({ children }) => {`);
                if (usesReactQuery) {
                    lines.push(`  const client = new QueryClient();`);
                }
                if (usesReactRouter && usesReactQuery) {
                    lines.push(`  return React.createElement(MemoryRouter as any, {}, `);
                    lines.push(`    React.createElement(QueryClientProvider as any, { client }, children as any)`);
                    lines.push(`  );`);
                }
                else if (usesReactRouter) {
                    lines.push(`  return React.createElement(MemoryRouter as any, {}, children as any);`);
                }
                else if (usesReactQuery) {
                    lines.push(`  return React.createElement(QueryClientProvider as any, { client }, children as any);`);
                }
                lines.push(`};`);
            }
        }
        // Add console capture if needed
        if (usesQtests) {
            lines.push(`import { mockConsole } from 'qtests';`);
        }
        lines.push(``);
        // Replace jest.mock with qtests stub comments for known libraries
        if (mocks.length > 0) {
            lines.push(`// External dependencies automatically stubbed by qtests/setup:`);
            mocks.forEach(lib => {
                lines.push(`// - ${lib}: stubbed by qtests (no jest.mock needed)`);
            });
            lines.push(``);
        }
        // Add deterministic helpers if the source code uses Date or Math.random
        if (content) {
            const { usesDate, usesRandom } = this.detectNonDeterministicCode(content);
            const deterministicHelpers = this.generateDeterministicHelpers(usesDate, usesRandom);
            deterministicHelpers.forEach(helper => lines.push(helper));
        }
        // Generate tests per export with React-aware templates
        if (exports.length > 0) {
            exports.forEach(exportName => {
                if (isReactFile && this.isReactHook(exportName)) {
                    // Generate React hook test
                    const hookTestLines = this.createReactHookTest(exportName, basename, usesReactQuery || usesReactRouter);
                    lines.push(...hookTestLines);
                }
                else if (isReactFile && this.isReactComponent(exportName, content)) {
                    // If component appears to require props, fall back to safe module/exists test
                    if (this.componentRequiresProps(exportName, content)) {
                        lines.push(`describe('${exportName} Component', () => {`);
                        lines.push(`  it('is defined (fallback: required props detected)', () => {`);
                        lines.push(`    const Component = (testModule as any).default ?? (testModule as any)['${exportName}'];`);
                        lines.push(`    expect(Component).toBeDefined();`);
                        lines.push(`  });`);
                        lines.push(`});`);
                        lines.push('');
                    }
                    else {
                        // Generate React component test
                        const componentTestLines = this.createReactComponentTest(exportName, basename, usesReactQuery || usesReactRouter);
                        lines.push(...componentTestLines);
                    }
                }
                else {
                    // Generate safe existence test only (no fake function calls)
                    lines.push(`describe('${exportName}', () => {`);
                    lines.push(`  it('is defined', () => {`);
                    lines.push(`    expect(testModule.${exportName}).toBeDefined();`);
                    lines.push(`  });`);
                    lines.push(`});`);
                    lines.push('');
                }
            });
        }
        else {
            // Fallback test when no exports detected
            lines.push(`describe('${path_1.default.basename(file)} module', () => {`);
            lines.push(`  it('should load without errors', async () => {`);
            lines.push(`    expect(testModule).toBeDefined();`);
            lines.push(`    expect(typeof testModule).toBe('object');`);
            lines.push(`  });`);
            lines.push(`});`);
            lines.push(``);
        }
        return lines.join('\n');
    }
    /**
     * Generate API test content for an endpoint - TypeScript ES module only
     * 🚩AI: INTEGRATION_TEMPLATE_SECTION — createMockApp + supertest + failure path
     */
    createApiTest(method, route) {
        const lines = [
            `// Generated integration test for ${method.toUpperCase()} ${route} - TypeScript ES module`,
            `// 🚩AI: ENTRY_POINT_FOR_GENERATED_TEST_IMPORTS`,
            `import 'qtests/setup';`, // Always import qtests/setup first
            ``
        ];
        // Import testing utilities (omit extension for ts-jest compatibility)
        lines.push(`import { createMockApp, supertest } from '../utils/httpTest';`);
        lines.push(``);
        // 🚩AI: DETERMINISM_HELPERS — fake timers and seeded randomness scaffolding
        lines.push(`// Deterministic test helpers`);
        lines.push(`beforeEach(() => {`);
        lines.push(`  // Use fake timers for deterministic time-based behavior`);
        lines.push(`  jest.useFakeTimers().setSystemTime(new Date('2023-01-01T00:00:00Z'));`);
        lines.push(`});`);
        lines.push(``);
        lines.push(`afterEach(() => {`);
        lines.push(`  jest.useRealTimers();`);
        lines.push(`});`);
        lines.push(``);
        // Generate unique test session for API isolation
        lines.push(`// Deterministic unique route for parallel test safety`);
        lines.push(`const testHash = require('crypto').createHash('md5').update('${route}').digest('hex').slice(0, 8);`);
        lines.push(`const uniqueRoute = '${route}' + ('${route}'.includes('?') ? '&' : '?') + 'testId=' + testHash;`);
        lines.push(``);
        // TypeScript test suite
        lines.push(`describe('${method.toUpperCase()} ${route}', () => {`);
        lines.push(`  let app: ReturnType<typeof createMockApp>;`);
        lines.push(``);
        lines.push(`  beforeEach(() => {`);
        lines.push(`    app = createMockApp();`);
        lines.push(`  });`);
        lines.push(``);
        // Success test case
        lines.push(`  it('should return success response', async () => {`);
        lines.push(`    // Setup route handler`);
        lines.push(`    app.${method.toLowerCase()}(uniqueRoute, (req, res) => {`);
        lines.push(`      res.statusCode = 200;`);
        lines.push(`      res.setHeader('content-type', 'application/json');`);
        lines.push(`      res.end(JSON.stringify({`);
        lines.push(`        success: true,`);
        lines.push(`        message: 'Request processed successfully'`);
        lines.push(`      }));`);
        lines.push(`    });`);
        lines.push(``);
        lines.push(`    // Execute test`);
        lines.push(`    const res = await supertest(app)`);
        lines.push(`      .${method.toLowerCase()}(uniqueRoute)`);
        if (method.toLowerCase() !== 'get') {
            lines.push(`      .send({ testData: 'valid input' })`);
        }
        lines.push(`      .expect(200);`);
        lines.push(``);
        lines.push(`    // Verify response`);
        lines.push(`    expect(res.body.success).toBe(true);`);
        lines.push(`    expect(res.body.message).toBe('Request processed successfully');`);
        lines.push(`  });`);
        lines.push(``);
        // Failure test case  
        lines.push(`  it('should handle not found case', async () => {`);
        lines.push(`    // Don't setup any route handlers to simulate 404`);
        lines.push(``);
        lines.push(`    // Execute test`);
        lines.push(`    const res = await supertest(app)`);
        lines.push(`      .${method.toLowerCase()}('/nonexistent-route')`);
        if (method.toLowerCase() !== 'get') {
            lines.push(`      .send({ testData: 'any data' })`);
        }
        lines.push(`      .expect(404);`);
        lines.push(``);
        lines.push(`    // Verify error response`);
        lines.push(`    expect(res.body.error).toBe('Not Found');`);
        lines.push(`  });`);
        lines.push(`});`);
        lines.push('');
        return lines.join('\n');
    }
    /**
     * Intelligently extract exports from both ES modules and CommonJS
     */
    extractExports(content) {
        const exports = new Set();
        // Remove comments to avoid false positives
        const cleanContent = content
            .replace(/\/\*[\s\S]*?\*\//g, '') // Remove /* */ comments
            .replace(/\/\/.*$/gm, ''); // Remove // comments
        // Extract ES module exports (export const/function/class)
        const esExports = [...cleanContent.matchAll(PATTERNS.exportsES)];
        esExports.forEach(match => {
            if (match[1])
                exports.add(match[1]);
        });
        // Extract ES module named exports: export { name1, name2, name3 }
        const namedExports = [...cleanContent.matchAll(PATTERNS.exportsNamed)];
        namedExports.forEach(match => {
            if (match[1]) {
                // Parse the named exports list
                const exportList = match[1].split(',').map(name => name.trim());
                exportList.forEach(name => {
                    // Handle potential aliases: "name as alias" -> use "name"
                    const cleanName = name.split(' as ')[0].trim();
                    if (cleanName && /^[a-zA-Z0-9_]+$/.test(cleanName)) {
                        exports.add(cleanName);
                    }
                });
            }
        });
        // Extract ES module default exports: export default SomeName
        const defaultExports = [...cleanContent.matchAll(PATTERNS.exportsDefault)];
        defaultExports.forEach(match => {
            if (match[1])
                exports.add(match[1]);
        });
        // Extract CommonJS exports
        const commonJSExports = [...cleanContent.matchAll(PATTERNS.exportsCommonJS)];
        commonJSExports.forEach(match => {
            // match[1] = module.exports.name, match[2] = exports.name, match[3] = single assignment
            for (let i = 1; i <= 3; i++) {
                if (match[i])
                    exports.add(match[i]);
            }
        });
        // Handle module.exports = { name1, name2, ... } pattern
        const objectExportMatch = cleanContent.match(/module\.exports\s*=\s*\{([^}]+)\}/);
        if (objectExportMatch) {
            const objectContent = objectExportMatch[1];
            const propertyMatches = objectContent.matchAll(/\b(\w+)(?:\s*:\s*\w+)?\s*[,}]/g);
            for (const match of propertyMatches) {
                if (match[1])
                    exports.add(match[1]);
            }
        }
        return Array.from(exports).filter(name => name && name.length > 0);
    }
    /**
     * Analyze a single file and generate appropriate tests - TypeScript ES module only
     */
    async analyze(file, dryRun = false) {
        const ext = path_1.default.extname(file);
        if (!this.config.VALID_EXTS.includes(ext)) {
            return;
        }
        const content = fs_1.default.readFileSync(file, 'utf8');
        const usesQtests = PATTERNS.qtests.test(content);
        const imports = this.getUsedModules(content);
        const mockTargets = imports.filter(i => this.config.KNOWN_MOCKS.includes(i) && i !== 'qtests');
        // Use intelligent export detection for both ES modules and CommonJS
        let exports = this.extractExports(content);
        // If AST mode requested, attempt to augment exports via TypeScript parser
        if (this.config.mode === 'ast') {
            try {
                const astInfo = await this.tryTypeScriptAnalysis(file, content);
                if (astInfo && Array.isArray(astInfo.functions)) {
                    const astExports = astInfo.functions.map(fn => fn.name).filter(Boolean);
                    exports = Array.from(new Set([...(exports || []), ...astExports]));
                }
            }
            catch {
                // Swallow AST errors and proceed with heuristic
            }
        }
        if (exports.length > 0 && (!this.config.integration)) {
            const testPath = this.getRelativeTestPath(file, 'unit', content);
            const created = this.writeIfMissing(testPath, this.createUnitTest(file, exports, usesQtests, mockTargets, content), dryRun);
            if (created) {
                this.scanned.push({
                    type: 'unit',
                    file: path_1.default.relative('.', testPath)
                });
            }
        }
        // Generate API tests for detected routes - TypeScript only
        const apis = [...content.matchAll(PATTERNS.api)];
        if (apis.length > 0 && (!this.config.unit)) {
            for (const [, , method, route] of apis) {
                const testPath = this.getRelativeTestPath(file, 'api', content)
                    .replace(/\.GenerateTest\.test\.(ts|tsx)$/, `.GenerateTest__${method.toLowerCase()}.test.$1`);
                const created = this.writeIfMissing(testPath, this.createApiTest(method, route), dryRun);
                // If an API test was created, ensure local httpTest utilities exist (idempotent)
                if (created && !dryRun) {
                    this.ensureLocalHttpTestUtils();
                }
                if (created) {
                    this.scanned.push({
                        type: 'api',
                        file: path_1.default.relative('.', testPath)
                    });
                }
            }
        }
    }
    /**
     * Detect if project uses React based on dependencies and source files
     */
    detectReactProject() {
        try {
            // Honor forced React mode if provided via CLI
            if (this.config.react)
                return true;
            // Check package.json for React dependencies
            const packagePath = path_1.default.join(process.cwd(), 'package.json');
            if (fs_1.default.existsSync(packagePath)) {
                const packageJson = JSON.parse(fs_1.default.readFileSync(packagePath, 'utf8'));
                const allDeps = {
                    ...packageJson.dependencies,
                    ...packageJson.devDependencies,
                    ...packageJson.peerDependencies
                };
                const reactDeps = ['react', '@types/react', 'react-dom', '@types/react-dom',
                    '@testing-library/react', '@tanstack/react-query'];
                if (reactDeps.some(dep => allDeps[dep])) {
                    return true;
                }
            }
            // Scan for .tsx files or React imports in source code
            const allFiles = this.walkProject();
            return allFiles.some(file => {
                if (file.endsWith('.tsx') || file.endsWith('.jsx'))
                    return true;
                try {
                    const content = fs_1.default.readFileSync(file, 'utf8');
                    return this.detectReactUsage(file, content);
                }
                catch {
                    return false;
                }
            });
        }
        catch {
            return false;
        }
    }
    /**
     * Create Jest configuration and setup files - React-aware TypeScript ES Module
     */
    scaffoldJestSetup() {
        const isReactProject = this.detectReactProject();
        // Generate Jest config for TypeScript ES modules with React support
        const extensionsToTreatAsEsm = isReactProject ? ['.ts', '.tsx'] : ['.ts'];
        const moduleFileExtensions = isReactProject ? ['ts', 'tsx', 'js', 'jsx', 'json'] : ['ts', 'js', 'json'];
        const testEnvironment = isReactProject ? 'jsdom' : 'node';
        const testMatchPatterns = isReactProject
            ? [
                '**/*.test.ts',
                '**/*.test.tsx',
                '**/*.GenerateTest.test.ts',
                '**/*.GenerateTest.test.tsx',
                '**/manual-tests/**/*.test.ts',
                '**/generated-tests/**/*.test.ts'
            ]
            : [
                '**/*.test.ts',
                '**/*.GenerateTest.test.ts',
                '**/manual-tests/**/*.test.ts',
                '**/generated-tests/**/*.test.ts'
            ];
        const transformConfig = isReactProject
            ? {
                '^.+\\.tsx?$': ['ts-jest', {
                        useESM: true,
                        isolatedModules: true,
                        tsconfig: {
                            jsx: 'react-jsx'
                        }
                    }]
            }
            : {
                '^.+\\.tsx?$': ['ts-jest', {
                        useESM: true,
                        isolatedModules: true
                    }]
            };
        const config = `
// jest.config.js - TypeScript ES Module configuration${isReactProject ? ' (React-enabled)' : ''}
export default {
  preset: 'ts-jest/presets/default-esm',
  extensionsToTreatAsEsm: ${JSON.stringify(extensionsToTreatAsEsm)},
  testEnvironment: '${testEnvironment}',
  setupFilesAfterEnv: ['<rootDir>/jest-setup.ts'],
  moduleFileExtensions: ${JSON.stringify(moduleFileExtensions)},
  roots: ['<rootDir>'],
  testMatch: ${JSON.stringify(testMatchPatterns, null, 4).replace(/\n/g, '\n  ')},
  transform: ${JSON.stringify(transformConfig, null, 4).replace(/\n/g, '\n  ')},
  transformIgnorePatterns: [
    'node_modules/(?!(?:@tanstack|@radix-ui|lucide-react|react-resizable-panels|cmdk|vaul)/)'
  ],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
    '^qtests/(.*)$': '<rootDir>/node_modules/qtests/$1'
  }${isReactProject ? ',\n  // React Testing Library configuration\n  testEnvironment: \'jsdom\',\n  setupFilesAfterEnv: [\'<rootDir>/jest-setup.ts\']' : ''}
};
`.trim();
        // Generate TypeScript ES module setup with React support
        const domPolyfills = isReactProject ? `

// DOM polyfills for React Testing Library
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // Deprecated
    removeListener: jest.fn(), // Deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// ResizeObserver polyfill
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));

// IntersectionObserver polyfill
global.IntersectionObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));` : '';
        const setup = `
// jest-setup.ts - Jest setup for TypeScript ESM${isReactProject ? ' with React support' : ''}
// Keep qtests setup FIRST to ensure global stubbing is active
import 'qtests/setup';
import 'jest';${isReactProject ? "\nimport '@testing-library/jest-dom';" : ''}

// Set test environment early
process.env.NODE_ENV = 'test';

beforeAll(() => {
  jest.setTimeout(10000);
});

afterEach(() => {
  jest.clearAllMocks();
});${domPolyfills}
`.trim();
        this.writeIfMissing('jest.config.js', config);
        this.writeIfMissing('jest-setup.ts', setup);
    }
    /**
     * Generate qtests test runner file - TypeScript ES module compatible
     */
    generateQtestsRunner() {
        try {
            // Read the existing qtests-ts-runner.ts as template
            const templatePath = path_1.default.join(getModuleDirnameForTestGenerator(), '..', 'qtests-ts-runner.ts');
            let template = '';
            if (fs_1.default.existsSync(templatePath)) {
                template = fs_1.default.readFileSync(templatePath, 'utf8');
            }
            else {
                // Fallback template for TypeScript ES modules with correct Jest configuration
                template = `
// Generated qtests runner - TypeScript ES module compatible
import { spawn } from 'child_process';
import path from 'path';

// Run tests with TypeScript support and correct Jest arguments
const args = process.argv.slice(2);
const testProcess = spawn('jest', args, {
  stdio: 'inherit',
  shell: true
});

testProcess.on('exit', (code) => {
  process.exit(code || 0);
});
`.trim();
            }
            // Always overwrite qtests-ts-runner.ts to ensure latest functionality and TypeScript compliance
            const outputPath = path_1.default.join(process.cwd(), 'qtests-ts-runner.ts');
            fs_1.default.writeFileSync(outputPath, template, 'utf8');
            console.log('✅ Generated qtests-ts-runner.ts for TypeScript ES modules');
        }
        catch (error) {
            console.error('Failed to generate qtests-ts-runner.ts:', error.message);
        }
    }
    /**
     * Update package.json test script to use qtests-ts-runner.ts
     */
    updatePackageJsonTestScript() {
        try {
            const packagePath = path_1.default.join(process.cwd(), 'package.json');
            if (!fs_1.default.existsSync(packagePath)) {
                console.log('⚠️  package.json not found, skipping test script update');
                return;
            }
            const packageJson = JSON.parse(fs_1.default.readFileSync(packagePath, 'utf8'));
            if (!packageJson.scripts) {
                packageJson.scripts = {};
            }
            packageJson.scripts.test = 'npx tsx qtests-ts-runner.ts';
            fs_1.default.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2), 'utf8');
            console.log('✅ Updated package.json test script to use qtests-ts-runner.ts');
        }
        catch (error) {
            console.log('⚠️  Could not update package.json:', error.message);
        }
    }
    /**
     * Scan for files without tests and generate them - TypeScript ES module only
     */
    async generateTestFiles(dryRun = false) {
        console.log('🔍 Scanning for files that need TypeScript tests...');
        const allFiles = this.walkProject();
        const { sourceFiles } = this.categorizeFiles(allFiles);
        console.log(`📁 Found ${sourceFiles.length} source files without tests`);
        // Generate tests for each source file
        for (const file of sourceFiles) {
            await this.analyze(file, dryRun);
        }
        // On non-dry runs, always scaffold Jest and runner even if there were no new files
        if (!dryRun) {
            this.scaffoldJestSetup();
            this.generateQtestsRunner();
            // Only update package.json if requested via CLI flag
            if (this.config.updatePackageScript) {
                this.updatePackageJsonTestScript();
            }
        }
        else {
            console.log('ℹ️ Dry run: Skipping Jest config and runner generation');
        }
        console.log(`📝 Generated ${this.scanned.length} TypeScript test files:`);
        this.scanned.forEach(test => {
            console.log(`   ${test.type}: ${test.file}`);
        });
    }
    /**
     * Get scan results
     */
    getResults() {
        return this.scanned;
    }
}
exports.TestGenerator = TestGenerator;
exports.default = TestGenerator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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IiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvbGliL3Rlc3RHZW5lcmF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0IEdlbmVyYXRvciBmb3IgcXRlc3RzIEZyYW1ld29yayAtIFR5cGVTY3JpcHQgSW1wbGVtZW50YXRpb25cbiAqIFxuICogQXV0b21hdGljYWxseSBnZW5lcmF0ZXMgdW5pdCB0ZXN0cyBhbmQgQVBJIHRlc3RzIGJ5IHNjYW5uaW5nIHNvdXJjZSBjb2RlLlxuICogQW5hbHl6ZXMgSmF2YVNjcmlwdC9UeXBlU2NyaXB0IGZpbGVzIHRvIGRldGVjdCBleHBvcnRzLCBpbXBvcnRzLCBhbmQgQVBJIHJvdXRlcyxcbiAqIHRoZW4gY3JlYXRlcyBhcHByb3ByaWF0ZSB0ZXN0IGZpbGVzIHdpdGggcHJvcGVyIHN0cnVjdHVyZSBhbmQgbW9ja2luZy5cbiAqIFxuICogRmVhdHVyZXM6XG4gKiAtIFVuaXQgdGVzdCBnZW5lcmF0aW9uIGZvciBleHBvcnRlZCBmdW5jdGlvbnMvY2xhc3Nlc1xuICogLSBBUEkgdGVzdCBnZW5lcmF0aW9uIGZvciBFeHByZXNzIHJvdXRlc1xuICogLSBBdXRvbWF0aWMgbW9jayBzZXR1cCBmb3Iga25vd24gbGlicmFyaWVzXG4gKiAtIEplc3QgY29uZmlndXJhdGlvbiBzY2FmZm9sZGluZ1xuICogLSBTdXBwb3J0IGZvciBxdGVzdHMgZnJhbWV3b3JrIGludGVncmF0aW9uXG4gKiAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgKG5vIHZlcnNpb24gZHVwbGljYXRpb24pXG4gKi9cblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZ2V0TW9kdWxlRGlybmFtZSB9IGZyb20gJy4uL3V0aWxzL2VzbS1nbG9iYWxzLmpzJztcblxuLy8gRVMgTW9kdWxlIF9fZGlybmFtZSBlcXVpdmFsZW50IC0gbGF6eSBpbml0aWFsaXphdGlvbiB0byBhdm9pZCBKZXN0IGlzc3Vlc1xubGV0IG1vZHVsZURpcm5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldE1vZHVsZURpcm5hbWVGb3JUZXN0R2VuZXJhdG9yKCk6IHN0cmluZyB7XG4gIGlmIChtb2R1bGVEaXJuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBVc2UgYSB0cnktY2F0Y2ggdG8gaGFuZGxlIEplc3QgZW52aXJvbm1lbnQgZ3JhY2VmdWxseVxuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgZXZhbCB0byBoaWRlIGltcG9ydC5tZXRhIGZyb20gSmVzdCdzIHN0YXRpYyBwYXJzZXJcbiAgICAgIGNvbnN0IGltcG9ydE1ldGFVcmwgPSAoMCwgZXZhbCkoJ2ltcG9ydC5tZXRhLnVybCcpO1xuICAgICAgbW9kdWxlRGlybmFtZSA9IGdldE1vZHVsZURpcm5hbWUoaW1wb3J0TWV0YVVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEZhbGxiYWNrIGZvciBKZXN0IGVudmlyb25tZW50XG4gICAgICBtb2R1bGVEaXJuYW1lID0gcHJvY2Vzcy5jd2QoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZHVsZURpcm5hbWU7XG59XG5cbi8vIFR5cGUgZGVmaW5pdGlvbnNcbmludGVyZmFjZSBUZXN0R2VuZXJhdG9yQ29uZmlnIHtcbiAgU1JDX0RJUjogc3RyaW5nO1xuICBURVNUX0RJUjogc3RyaW5nO1xuICBLTk9XTl9NT0NLUzogc3RyaW5nW107XG4gIFZBTElEX0VYVFM6IHN0cmluZ1tdO1xuICBtb2RlPzogJ2hldXJpc3RpYycgfCAnYXN0JztcbiAgdW5pdD86IGJvb2xlYW47XG4gIGludGVncmF0aW9uPzogYm9vbGVhbjtcbiAgZHJ5UnVuPzogYm9vbGVhbjtcbiAgZm9yY2U/OiBib29sZWFuO1xuICBpbmNsdWRlPzogc3RyaW5nW107XG4gIGV4Y2x1ZGU/OiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIFNjYW5uZWRUZXN0IHtcbiAgdHlwZTogJ3VuaXQnIHwgJ2FwaSc7XG4gIGZpbGU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZpbGVDYXRlZ29yaXphdGlvbiB7XG4gIHNvdXJjZUZpbGVzOiBzdHJpbmdbXTtcbiAgZXhpc3RpbmdUZXN0czogc3RyaW5nW107XG59XG5cbi8vIENvbmZpZ3VyYXRpb24gY29uc3RhbnRzIC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVxuY29uc3QgREVGQVVMVF9DT05GSUc6IFRlc3RHZW5lcmF0b3JDb25maWcgPSB7XG4gIFNSQ19ESVI6ICcuJyxcbiAgVEVTVF9ESVI6ICdnZW5lcmF0ZWQtdGVzdHMnLFxuICBLTk9XTl9NT0NLUzogWydheGlvcycsICdub2RlLWZldGNoJywgJ3BnJywgJ21vbmdvb3NlJywgJ2ZzJywgJ3JlZGlzJ10sXG4gIFZBTElEX0VYVFM6IFsnLnRzJywgJy5qcycsICcudHN4JywgJy5qc3gnXVxufTtcblxuLy8gUmVnZXggcGF0dGVybnMgZm9yIGNvZGUgYW5hbHlzaXMgLSBFbmhhbmNlZCBmb3IgYm90aCBFUyBtb2R1bGVzIGFuZCBDb21tb25KU1xuY29uc3QgUEFUVEVSTlMgPSB7XG4gIHF0ZXN0czogL2Zyb20gWydcIl1xdGVzdHNbJ1wiXXxyZXF1aXJlXFwoWydcIl1xdGVzdHNbJ1wiXVxcKS8sXG4gIGFwaTogL1xcYihhcHB8cm91dGVyKVxcLihnZXR8cG9zdHxwdXR8ZGVsZXRlfHBhdGNoKVxccypcXChcXHMqWydcImBdKFteJ1wiYF0rKVsnXCJgXS9naSxcbiAgLy8gRVMgbW9kdWxlIGV4cG9ydHM6IGV4cG9ydCBjb25zdCwgZXhwb3J0IGZ1bmN0aW9uLCBleHBvcnQgY2xhc3NcbiAgZXhwb3J0c0VTOiAvXlxccypleHBvcnRcXHMrKD86Y29uc3R8ZnVuY3Rpb258Y2xhc3MpXFxzKyhbYS16QS1aMC05X10rKS9nbSxcbiAgLy8gRVMgbW9kdWxlIG5hbWVkIGV4cG9ydHM6IGV4cG9ydCB7IG5hbWUxLCBuYW1lMiwgbmFtZTMgfVxuICBleHBvcnRzTmFtZWQ6IC9leHBvcnRcXHMqXFx7XFxzKihbXn1dKylcXHMqXFx9L2csXG4gIC8vIEVTIG1vZHVsZSBkZWZhdWx0IGV4cG9ydHM6IGV4cG9ydCBkZWZhdWx0IFNvbWVOYW1lXG4gIGV4cG9ydHNEZWZhdWx0OiAvZXhwb3J0XFxzK2RlZmF1bHRcXHMrKFthLXpBLVowLTlfXSspL2csXG4gIC8vIENvbW1vbkpTIGV4cG9ydHM6IG1vZHVsZS5leHBvcnRzID0ge30sIG1vZHVsZS5leHBvcnRzLm5hbWUgPSwgZXhwb3J0cy5uYW1lID1cbiAgZXhwb3J0c0NvbW1vbkpTOiAvKD86bW9kdWxlXFwuZXhwb3J0c1xcLihbYS16QS1aMC05X10rKVxccyo9fGV4cG9ydHNcXC4oW2EtekEtWjAtOV9dKylcXHMqPXxtb2R1bGVcXC5leHBvcnRzXFxzKj1cXHMqKFthLXpBLVowLTlfXSspKS9nbSxcbiAgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25zIHRoYXQgbWlnaHQgYmUgZXhwb3J0ZWRcbiAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IC9eXFxzKig/OmFzeW5jXFxzKyk/ZnVuY3Rpb25cXHMrKFthLXpBLVowLTlfXSspXFxzKlxcKC9nbSxcbiAgLy8gQ2xhc3MgZGVjbGFyYXRpb25zIHRoYXQgbWlnaHQgYmUgZXhwb3J0ZWRcbiAgY2xhc3NEZWNsYXJhdGlvbnM6IC9eXFxzKmNsYXNzXFxzKyhbYS16QS1aMC05X10rKS9nbSxcbiAgaW1wb3J0czogL2Zyb20gWydcIl0oW14nXCJdKylbJ1wiXXxyZXF1aXJlXFwoWydcIl0oW14nXCJdKylbJ1wiXVxcKS9nXG59O1xuXG5jbGFzcyBUZXN0R2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSBjb25maWc6IFRlc3RHZW5lcmF0b3JDb25maWc7XG4gIHByaXZhdGUgc2Nhbm5lZDogU2Nhbm5lZFRlc3RbXTtcbiAgcHJpdmF0ZSBpc0VTTW9kdWxlOiBib29sZWFuO1xuICAvLyBQcmVjb21waWxlZCBpbmNsdWRlL2V4Y2x1ZGUgcmVnZXhlcyBmb3IgZmFzdCBmaWx0ZXJpbmdcbiAgcHJpdmF0ZSBpbmNsdWRlUmVnZXhlczogUmVnRXhwW10gPSBbXTtcbiAgcHJpdmF0ZSBleGNsdWRlUmVnZXhlczogUmVnRXhwW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQYXJ0aWFsPFRlc3RHZW5lcmF0b3JDb25maWc+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLnNjYW5uZWQgPSBbXTtcbiAgICB0aGlzLmlzRVNNb2R1bGUgPSB0aGlzLmRldGVjdEVTTW9kdWxlKCk7IC8vIERldGVjdCBtb2R1bGUgdHlwZSBvbmNlIGR1cmluZyBpbml0aWFsaXphdGlvblxuICAgIC8vIENvbXBpbGUgaW5jbHVkZS9leGNsdWRlIGdsb2IgcGF0dGVybnMgdG8gcmVnZXggZm9yIG1hdGNoaW5nXG4gICAgdGhpcy5pbmNsdWRlUmVnZXhlcyA9ICh0aGlzLmNvbmZpZy5pbmNsdWRlIHx8IFtdKS5tYXAodGhpcy5nbG9iVG9SZWdFeHApO1xuICAgIHRoaXMuZXhjbHVkZVJlZ2V4ZXMgPSAodGhpcy5jb25maWcuZXhjbHVkZSB8fCBbXSkubWFwKHRoaXMuZ2xvYlRvUmVnRXhwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgdGhlIGN1cnJlbnQgcHJvamVjdCB1c2VzIEVTIG1vZHVsZXMgb3IgQ29tbW9uSlNcbiAgICogU2luY2Ugd2UncmUgbm93IFwiVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVwiLCB0aGlzIGRlZmF1bHRzIHRvIHRydWUgZm9yIFR5cGVTY3JpcHQgcHJvamVjdHNcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0RVNNb2R1bGUoKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIHBhY2thZ2UuanNvbiBmb3IgZXhwbGljaXQgXCJ0eXBlXCI6IFwibW9kdWxlXCJcbiAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICdwYWNrYWdlLmpzb24nKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBhY2thZ2VQYXRoKSkge1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgaWYgKHBhY2thZ2VKc29uLnR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2gsIHByZWZlciBFUyBtb2R1bGVzIHdoZW4gVHlwZVNjcmlwdCBpcyBkZXRlY3RlZFxuICAgICAgICBpZiAocGFja2FnZUpzb24uZGV2RGVwZW5kZW5jaWVzPy50eXBlc2NyaXB0IHx8IHBhY2thZ2VKc29uLmRlcGVuZGVuY2llcz8udHlwZXNjcmlwdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBFUyBtb2R1bGUgcGF0dGVybnMgaW4gc291cmNlIGZpbGVzIChleGNsdWRpbmcgdGVzdCBmaWxlcyBhbmQgbm9kZV9tb2R1bGVzKVxuICAgICAgY29uc3Qgc291cmNlRmlsZXMgPSB0aGlzLndhbGtQcm9qZWN0KClcbiAgICAgICAgLmZpbHRlcihmaWxlID0+IHtcbiAgICAgICAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZmlsZSk7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZEV4dCA9IHRoaXMuY29uZmlnLlZBTElEX0VYVFMuaW5jbHVkZXMoZXh0KTtcbiAgICAgICAgICBjb25zdCBpc1Rlc3RGaWxlID0gdGhpcy5pc1Rlc3RGaWxlKHBhdGguYmFzZW5hbWUoZmlsZSkpO1xuICAgICAgICAgIGNvbnN0IGlzTm9kZU1vZHVsZXMgPSBmaWxlLmluY2x1ZGVzKCdub2RlX21vZHVsZXMnKTtcbiAgICAgICAgICByZXR1cm4gaXNWYWxpZEV4dCAmJiAhaXNUZXN0RmlsZSAmJiAhaXNOb2RlTW9kdWxlcztcbiAgICAgICAgfSlcbiAgICAgICAgLnNsaWNlKDAsIDEwKTsgLy8gU2FtcGxlIGZpcnN0IDEwIGZpbGVzIGZvciBwZXJmb3JtYW5jZVxuICAgICAgXG4gICAgICBsZXQgZXNNb2R1bGVDb3VudCA9IDA7XG4gICAgICBsZXQgY29tbW9uSlNDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBzb3VyY2VGaWxlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICAgICAgICAvLyBMb29rIGZvciBFUyBtb2R1bGUgcGF0dGVybnMgKGltcG9ydCBPUiBleHBvcnQgc3RhdGVtZW50cylcbiAgICAgICAgICBpZiAoY29udGVudC5pbmNsdWRlcygnaW1wb3J0ICcpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ2V4cG9ydCAnKSkge1xuICAgICAgICAgICAgZXNNb2R1bGVDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBMb29rIGZvciBDb21tb25KUyBwYXR0ZXJuc1xuICAgICAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdyZXF1aXJlKCcpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ21vZHVsZS5leHBvcnRzJykpIHtcbiAgICAgICAgICAgIGNvbW1vbkpTQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gU2tpcCBmaWxlcyB3ZSBjYW4ndCByZWFkXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2gsIHByZWZlciBFUyBtb2R1bGVzIHdoZW4gZXF1YWwgb3Igd2hlbiBUeXBlU2NyaXB0IGZpbGVzIGFyZSBwcmVzZW50XG4gICAgICBpZiAoZXNNb2R1bGVDb3VudCA9PT0gMCAmJiBjb21tb25KU0NvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBEZWZhdWx0IHRvIEVTIG1vZHVsZXMgZm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2hcbiAgICAgIH1cbiAgICAgIGlmIChlc01vZHVsZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gRVMgbW9kdWxlIHBhdHRlcm5zIGZvdW5kLCBkZWZhdWx0IHRvIENvbW1vbkpTXG4gICAgICB9XG4gICAgICByZXR1cm4gZXNNb2R1bGVDb3VudCA+PSBjb21tb25KU0NvdW50OyAvLyBDaGFuZ2VkIGZyb20gPiB0byA+PSB0byBwcmVmZXIgRVMgbW9kdWxlc1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIEVTIG1vZHVsZXMgZm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHkgYXBwcm9hY2hcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBkaXJlY3Rvcnkgc2hvdWxkIGJlIHNraXBwZWQgZHVyaW5nIGRpc2NvdmVyeVxuICAgKi9cbiAgcHJpdmF0ZSBzaG91bGRTa2lwRGlyZWN0b3J5KGRpck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHNraXBQYXR0ZXJucyA9IFtcbiAgICAgICdub2RlX21vZHVsZXMnLCAnLmdpdCcsICcubmV4dCcsICdkaXN0JywgJ2J1aWxkJywgJ2NvdmVyYWdlJyxcbiAgICAgICcudnNjb2RlJywgJy5pZGVhJywgJ2RvY3MnLCAnZG9jdW1lbnRhdGlvbicsICdhc3NldHMnLCAncHVibGljJywgJ3N0YXRpYycsXG4gICAgICAnLnJlcGxpdF9jYWNoZScsICcuY29uZmlnJywgJy5ucG0nLCAnbG9ncycsXG4gICAgICAnZXhhbXBsZXMnLCAnZGVtbycsICdkZW1vcycsICdzYW1wbGVzJywgJ2JpbicsXG4gICAgICAvLyBTa2lwIGNvbW1vbiB0ZXN0IGFuZCBnZW5lcmF0ZWQgZGlyZWN0b3JpZXNcbiAgICAgICdfX21vY2tzX18nLCAnX190ZXN0c19fJywgJ3Rlc3RzJywgJ3Rlc3QnLCAnZ2VuZXJhdGVkLXRlc3RzJyxcbiAgICAgIC8vIFNraXAgbWFudWFsIHRlc3QgZGlyZWN0b3JpZXMgYW5kIGZpeHR1cmVzXG4gICAgICAnbWFudWFsLXRlc3RzJywgJ2ZpeHR1cmVzJywgJ3Rlc3QtZml4dHVyZXMnXG4gICAgXTtcbiAgICByZXR1cm4gc2tpcFBhdHRlcm5zLmluY2x1ZGVzKGRpck5hbWUpIHx8IGRpck5hbWUuc3RhcnRzV2l0aCgnLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgZW50aXJlIHByb2plY3QgZGlyZWN0b3J5IHN0cnVjdHVyZSwgcmVzcGVjdGluZyBza2lwIHBhdHRlcm5zXG4gICAqL1xuICBwcml2YXRlIHdhbGtQcm9qZWN0KCk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5jb25maWcuU1JDX0RJUlxuICAgICAgPyBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgdGhpcy5jb25maWcuU1JDX0RJUilcbiAgICAgIDogcHJvY2Vzcy5jd2QoKTtcbiAgICByZXR1cm4gdGhpcy53YWxrUmVjdXJzaXZlKHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHdhbGsgZGlyZWN0b3J5IGFuZCByZXR1cm4gYWxsIGZpbGUgcGF0aHMsIHNraXBwaW5nIGlycmVsZXZhbnQgZGlyZWN0b3JpZXNcbiAgICovXG4gIHByaXZhdGUgd2Fsa1JlY3Vyc2l2ZShkaXI6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZnMucmVhZGRpclN5bmMoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSkuZmxhdE1hcChlbnRyeSA9PiB7XG4gICAgICBjb25zdCBmdWxsID0gcGF0aC5yZXNvbHZlKGRpciwgZW50cnkubmFtZSk7XG4gICAgICBcbiAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vIFNraXAgZGlyZWN0b3JpZXMgdGhhdCBzaG91bGRuJ3QgY29udGFpbiB0ZXN0cyBvciBzb3VyY2UgZmlsZXNcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2tpcERpcmVjdG9yeShlbnRyeS5uYW1lKSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53YWxrUmVjdXJzaXZlKGZ1bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtmdWxsXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgZ2xvYiBwYXR0ZXJuIChzdXBwb3J0cyAqLCAqKiwgPykgaW50byBhIFJlZ0V4cFxuICAgKiAtICogIG1hdGNoZXMgYW55IHNlcXVlbmNlIGV4Y2VwdCBwYXRoIHNlcGFyYXRvclxuICAgKiAtICoqIG1hdGNoZXMgYW55IHNlcXVlbmNlIGluY2x1ZGluZyBwYXRoIHNlcGFyYXRvcnNcbiAgICogLSA/ICBtYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlciBleGNlcHQgcGF0aCBzZXBhcmF0b3JcbiAgICovXG4gIHByaXZhdGUgZ2xvYlRvUmVnRXhwKHBhdHRlcm46IHN0cmluZyk6IFJlZ0V4cCB7XG4gICAgLy8gTm9ybWFsaXplIHRvIHBvc2l4IHN0eWxlIGZvciBtYXRjaGluZ1xuICAgIGxldCBwYXQgPSBwYXR0ZXJuLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAvLyBFc2NhcGUgcmVnZXggc3BlY2lhbCBjaGFycywgZXhjZXB0IG91ciBnbG9iIHRva2VucyAqID9cbiAgICBwYXQgPSBwYXQucmVwbGFjZSgvKFsuK14ke30oKXxcXFtcXF1cXFxcXSkvZywgJ1xcXFwkMScpO1xuICAgIC8vIENvbnZlcnQgKiogdG8gYSBzcGVjaWFsIHRva2VuIGZpcnN0IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggKlxuICAgIHBhdCA9IHBhdC5yZXBsYWNlKC9cXCpcXCovZywgJzo6R0xPQlNUQVI6OicpO1xuICAgIC8vIENvbnZlcnQgcmVtYWluaW5nICogYW5kID9cbiAgICBwYXQgPSBwYXQucmVwbGFjZSgvXFwqL2csICdbXi9dKicpLnJlcGxhY2UoL1xcPy9nLCAnW14vXScpO1xuICAgIC8vIENvbnZlcnQgR0xPQlNUQVJcbiAgICBwYXQgPSBwYXQucmVwbGFjZSgvOjpHTE9CU1RBUjo6L2csICcuKicpO1xuICAgIC8vIEFuY2hvciBwYXR0ZXJuXG4gICAgcGF0ID0gJ14nICsgcGF0ICsgJyQnO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaW5jbHVkZS9leGNsdWRlIHBhdHRlcm5zIGFnYWluc3QgYSBwYXRoIChwb3NpeCBub3JtYWxpemVkKVxuICAgKi9cbiAgcHJpdmF0ZSBwYXRoTWF0Y2hlc0ZpbHRlcnMoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBvc2l4UGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAvLyBBcHBseSBleGNsdWRlIGZpcnN0XG4gICAgaWYgKHRoaXMuZXhjbHVkZVJlZ2V4ZXMuc29tZShyeCA9PiByeC50ZXN0KHBvc2l4UGF0aCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGluY2x1ZGVzIHByb3ZpZGVkLCBtdXN0IG1hdGNoIGF0IGxlYXN0IG9uZSBpbmNsdWRlXG4gICAgaWYgKHRoaXMuaW5jbHVkZVJlZ2V4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5jbHVkZVJlZ2V4ZXMuc29tZShyeCA9PiByeC50ZXN0KHBvc2l4UGF0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gaW5jbHVkZXMgbWVhbnMgaW5jbHVkZSBhbGwgKGFmdGVyIGV4Y2x1ZGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIExlZ2FjeSB3YWxrIG1ldGhvZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKHdhbGtzIHNpbmdsZSBkaXJlY3RvcnkpXG4gICAqL1xuICBwcml2YXRlIHdhbGsoZGlyOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZzLnJlYWRkaXJTeW5jKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pLmZsYXRNYXAoZW50cnkgPT4ge1xuICAgICAgY29uc3QgZnVsbCA9IHBhdGgucmVzb2x2ZShkaXIsIGVudHJ5Lm5hbWUpO1xuICAgICAgcmV0dXJuIGVudHJ5LmlzRGlyZWN0b3J5KCkgPyB0aGlzLndhbGsoZnVsbCkgOiBbZnVsbF07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgZmlsZSBzaG91bGQgYmUgc2tpcHBlZCBhcyBhIHNvdXJjZSBmaWxlIChjb25maWcsIHNldHVwLCBldGMuKVxuICAgKi9cbiAgcHJpdmF0ZSBzaG91bGRTa2lwU291cmNlRmlsZShmaWxlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSk7XG4gICAgY29uc3QgZGlybmFtZSA9IHBhdGguZGlybmFtZShmaWxlKTtcbiAgICBcbiAgICAvLyBTa2lwIGZpbGVzIGluIHRlc3QtcmVsYXRlZCBkaXJlY3Rvcmllc1xuICAgIGlmIChkaXJuYW1lLmluY2x1ZGVzKCdtYW51YWwtdGVzdHMnKSB8fCBkaXJuYW1lLmluY2x1ZGVzKCdmaXh0dXJlcycpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2tpcFBhdHRlcm5zID0gW1xuICAgICAgL15qZXN0XFwuY29uZmlnXFwuLywgICAgICAgICAgLy8gSmVzdCBjb25maWcgZmlsZXNcbiAgICAgIC9eamVzdC1zZXR1cFxcLi8sICAgICAgICAgICAgLy8gSmVzdCBzZXR1cCBmaWxlc1xuICAgICAgL15zZXR1cFxcLi8sICAgICAgICAgICAgICAgICAvLyBTZXR1cCBmaWxlc1xuICAgICAgL15jb25maWdcXC4vLCAgICAgICAgICAgICAgICAvLyBDb25maWcgZmlsZXMgIFxuICAgICAgLy1kZW1vXFwuLywgICAgICAgICAgICAgICAgICAvLyBEZW1vIGZpbGVzXG4gICAgICAvLWV4YW1wbGVcXC4vLCAgICAgICAgICAgICAgIC8vIEV4YW1wbGUgZmlsZXNcbiAgICAgIC9cXC5jb25maWdcXC4vLCAgICAgICAgICAgICAgIC8vIEFueSBjb25maWcgZmlsZXNcbiAgICAgIC9eZXhhbXBsZVxcLi8sICAgICAgICAgICAgICAgLy8gRmlsZXMgbmFtZWQgXCJleGFtcGxlLipcIlxuICAgICAgL15kZW1vXFwuLywgICAgICAgICAgICAgICAgICAvLyBGaWxlcyBuYW1lZCBcImRlbW8uKlwiXG4gICAgICAvcXRlc3RzLXJ1bm5lclxcLi8sICAgICAgICAgIC8vIEdlbmVyYXRlZCBydW5uZXIgZmlsZXNcbiAgICAgIC9zZXR1cE11bHRpcGxlLywgICAgICAgICAgICAvLyBUZXN0IHNldHVwIGhlbHBlcnNcbiAgICAgIC9yZWxvYWRDaGVjay8sICAgICAgICAgICAgICAvLyBUZXN0IHV0aWxpdGllc1xuICAgICAgL3Rlc3RTZXR1cC8sICAgICAgICAgICAgICAgIC8vIFRlc3Qgc2V0dXAgZmlsZXNcbiAgICBdO1xuICAgIFxuICAgIHJldHVybiBza2lwUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChiYXNlbmFtZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhdGVnb3JpemUgZGlzY292ZXJlZCBmaWxlcyBpbnRvIHNvdXJjZSBmaWxlcyBhbmQgZXhpc3RpbmcgdGVzdHNcbiAgICovXG4gIHByaXZhdGUgY2F0ZWdvcml6ZUZpbGVzKGZpbGVzOiBzdHJpbmdbXSk6IEZpbGVDYXRlZ29yaXphdGlvbiB7XG4gICAgY29uc3Qgc291cmNlRmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgZXhpc3RpbmdUZXN0czogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKGZpbGUpO1xuICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGZpbGVzIHdpdGggaW52YWxpZCBleHRlbnNpb25zXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLlZBTElEX0VYVFMuaW5jbHVkZXMoZXh0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IENMSSBpbmNsdWRlL2V4Y2x1ZGUgZmlsdGVycyBhZ2FpbnN0IHByb2plY3QtcmVsYXRpdmUgcGF0aFxuICAgICAgY29uc3QgcmVsRnJvbUN3ZCA9IHBhdGgucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgZmlsZSk7XG4gICAgICBpZiAoIXRoaXMucGF0aE1hdGNoZXNGaWx0ZXJzKHJlbEZyb21Dd2QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBjb25maWcsIGRlbW8sIGFuZCBzZXR1cCBmaWxlc1xuICAgICAgaWYgKHRoaXMuc2hvdWxkU2tpcFNvdXJjZUZpbGUoZmlsZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdGVzdCBmaWxlXG4gICAgICBpZiAodGhpcy5pc1Rlc3RGaWxlKGJhc2VuYW1lKSkge1xuICAgICAgICBleGlzdGluZ1Rlc3RzLnB1c2goZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHNvdXJjZSBmaWxlIGFscmVhZHkgaGFzIGEgY29ycmVzcG9uZGluZyB0ZXN0XG4gICAgICAgIGNvbnN0IGhhc1Rlc3QgPSB0aGlzLmhhc0NvcnJlc3BvbmRpbmdUZXN0KGZpbGUsIGZpbGVzKTtcbiAgICAgICAgaWYgKCFoYXNUZXN0KSB7XG4gICAgICAgICAgc291cmNlRmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7IHNvdXJjZUZpbGVzLCBleGlzdGluZ1Rlc3RzIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgZmlsZW5hbWUgaW5kaWNhdGVzIGl0J3MgYSB0ZXN0IGZpbGVcbiAgICovXG4gIHByaXZhdGUgaXNUZXN0RmlsZShmaWxlbmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGVzdFBhdHRlcm5zID0gW1xuICAgICAgL1xcLnRlc3RcXC4vLFxuICAgICAgL1xcLnNwZWNcXC4vLFxuICAgICAgL190ZXN0XFwuLyxcbiAgICAgIC9fc3BlY1xcLi8sXG4gICAgICAvXFwuZTJlXFwuLyxcbiAgICAgIC9cXC5pbnRlZ3JhdGlvblxcLi9cbiAgICBdO1xuICAgIFxuICAgIHJldHVybiB0ZXN0UGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChmaWxlbmFtZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc291cmNlIGZpbGUgaGFzIGEgY29ycmVzcG9uZGluZyB0ZXN0IGZpbGVcbiAgICovXG4gIHByaXZhdGUgaGFzQ29ycmVzcG9uZGluZ1Rlc3Qoc291cmNlRmlsZTogc3RyaW5nLCBhbGxGaWxlczogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoc291cmNlRmlsZSk7XG4gICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHNvdXJjZUZpbGUsIHBhdGguZXh0bmFtZShzb3VyY2VGaWxlKSk7XG4gICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKHNvdXJjZUZpbGUpO1xuICAgIFxuICAgIC8vIENvbW1vbiB0ZXN0IGZpbGUgcGF0dGVybnMgdG8gbG9vayBmb3IgLSBUeXBlU2NyaXB0IEVTIG1vZHVsZSBvbmx5XG4gICAgY29uc3QgdGVzdFBhdHRlcm5zID0gW1xuICAgICAgYCR7YmFzZW5hbWV9LnRlc3QudHNgLFxuICAgICAgYCR7YmFzZW5hbWV9LkdlbmVyYXRlVGVzdC50ZXN0LnRzYCwgIC8vIFVwZGF0ZWQgZ2VuZXJhdGVkIHVuaXQgdGVzdCBwYXR0ZXJuICBcbiAgICAgIGAke2Jhc2VuYW1lfUdlbmVyYXRlZFRlc3QudGVzdC50c2AsICAvLyBMZWdhY3kgcGF0dGVybiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIGAke2Jhc2VuYW1lfS5zcGVjLnRzYCxcbiAgICAgIGAke2Jhc2VuYW1lfV90ZXN0LnRzYCxcbiAgICAgIGAke2Jhc2VuYW1lfV9zcGVjLnRzYCxcbiAgICAgIGAke2Jhc2VuYW1lfS50ZXN0JHtleHR9YCxcbiAgICAgIGAke2Jhc2VuYW1lfS5zcGVjJHtleHR9YFxuICAgIF07XG4gICAgXG4gICAgLy8gTG9vayBmb3IgdGVzdCBmaWxlcyBpbiB0aGUgc2FtZSBkaXJlY3RvcnlcbiAgICBjb25zdCBzYW1lRGlyZWN0b3J5VGVzdHMgPSB0ZXN0UGF0dGVybnMubWFwKHBhdHRlcm4gPT4gXG4gICAgICBwYXRoLmpvaW4oZGlyLCBwYXR0ZXJuKVxuICAgICk7XG4gICAgXG4gICAgLy8gTG9vayBmb3IgdGVzdCBmaWxlcyBpbiBjb21tb24gdGVzdCBkaXJlY3Rvcmllc1xuICAgIGNvbnN0IHRlc3REaXJlY3RvcmllcyA9IFsndGVzdHMnLCAndGVzdCcsICdfX3Rlc3RzX18nLCAnc3BlYyddO1xuICAgIGNvbnN0IHRlc3REaXJlY3RvcnlUZXN0cyA9IHRlc3REaXJlY3Rvcmllcy5mbGF0TWFwKHRlc3REaXIgPT4ge1xuICAgICAgY29uc3QgdGVzdFBhdGggPSBwYXRoLmpvaW4oZGlyLCB0ZXN0RGlyKTtcbiAgICAgIHJldHVybiB0ZXN0UGF0dGVybnMubWFwKHBhdHRlcm4gPT4gcGF0aC5qb2luKHRlc3RQYXRoLCBwYXR0ZXJuKSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZXNlIHRlc3QgZmlsZXMgZXhpc3RcbiAgICBjb25zdCBhbGxUZXN0UGF0aHMgPSBbLi4uc2FtZURpcmVjdG9yeVRlc3RzLCAuLi50ZXN0RGlyZWN0b3J5VGVzdHNdO1xuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSBwYXRocyBmb3IgY29tcGFyaXNvbiAtIGNvbnZlcnQgYm90aCB0byBhYnNvbHV0ZSBwYXRoc1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBbGxGaWxlcyA9IGFsbEZpbGVzLm1hcChmaWxlID0+IHBhdGgucmVzb2x2ZShmaWxlKSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFRlc3RQYXRocyA9IGFsbFRlc3RQYXRocy5tYXAodGVzdFBhdGggPT4gcGF0aC5yZXNvbHZlKHRlc3RQYXRoKSk7XG4gICAgXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUZXN0UGF0aHMuc29tZSh0ZXN0UGF0aCA9PiBcbiAgICAgIG5vcm1hbGl6ZWRBbGxGaWxlcy5pbmNsdWRlcyh0ZXN0UGF0aClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBzb3VyY2UgZmlsZSBvciBjb250ZW50IGluZGljYXRlcyBSZWFjdCB1c2FnZVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RSZWFjdFVzYWdlKGZpbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nID0gJycpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBmaWxlIGV4dGVuc2lvblxuICAgIGlmIChmaWxlLmVuZHNXaXRoKCcudHN4JykgfHwgZmlsZS5lbmRzV2l0aCgnLmpzeCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIFJlYWN0IGltcG9ydHNcbiAgICBjb25zdCByZWFjdEltcG9ydHMgPSAvaW1wb3J0LiooPzpyZWFjdHxSZWFjdHxAdHlwZXNcXC9yZWFjdCkvaS50ZXN0KGNvbnRlbnQpO1xuICAgIGlmIChyZWFjdEltcG9ydHMpIHJldHVybiB0cnVlO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBKU1ggcGF0dGVybnNcbiAgICBjb25zdCBqc3hQYXR0ZXJucyA9IFtcbiAgICAgIC88W0EtWl1bYS16QS1aMC05XSpbXFxzXFwvPl0vLCAvLyBDb21wb25lbnQgdGFncyBsaWtlIDxNeUNvbXBvbmVudFxuICAgICAgLzxbYS16XStbXFxzXFwvPl0vLCAvLyBIVE1MIHRhZ3MgbGlrZSA8ZGl2PlxuICAgICAgL1JlYWN0XFwuY3JlYXRlRWxlbWVudC8sIC8vIFJlYWN0LmNyZWF0ZUVsZW1lbnQgY2FsbHNcbiAgICAgIC9qc3guKjovLCAgLy8gSlNYIHByYWdtYVxuICAgIF07XG4gICAgXG4gICAgcmV0dXJuIGpzeFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoY29udGVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBleHBvcnQgbmFtZSBpcyBsaWtlbHkgYSBSZWFjdCBob29rXG4gICAqL1xuICBwcml2YXRlIGlzUmVhY3RIb29rKGV4cG9ydE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBleHBvcnROYW1lLnN0YXJ0c1dpdGgoJ3VzZScpICYmIGV4cG9ydE5hbWUubGVuZ3RoID4gMztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgZXhwb3J0IG5hbWUgaXMgbGlrZWx5IGEgUmVhY3QgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIGlzUmVhY3RDb21wb25lbnQoZXhwb3J0TmFtZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgPSAnJyk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIGl0IHN0YXJ0cyB3aXRoIHVwcGVyY2FzZSAoY29tcG9uZW50IGNvbnZlbnRpb24pXG4gICAgaWYgKCEvXltBLVpdLy50ZXN0KGV4cG9ydE5hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gdGhhdCBtaWdodCByZXR1cm4gSlNYXG4gICAgY29uc3QgY29tcG9uZW50UGF0dGVybnMgPSBbXG4gICAgICBuZXcgUmVnRXhwKGBmdW5jdGlvblxcXFxzKyR7ZXhwb3J0TmFtZX1cXFxccypcXFxcKGApLFxuICAgICAgbmV3IFJlZ0V4cChgY29uc3RcXFxccyske2V4cG9ydE5hbWV9XFxcXHMqPVxcXFxzKlxcXFwoYCksXG4gICAgICBuZXcgUmVnRXhwKGBleHBvcnRcXFxccytmdW5jdGlvblxcXFxzKyR7ZXhwb3J0TmFtZX1cXFxccypcXFxcKGApLFxuICAgICAgbmV3IFJlZ0V4cChgJHtleHBvcnROYW1lfVxcXFxzKj1cXFxccypcXFxcKC4qXFxcXClcXFxccyo9PmApIC8vIEFycm93IGZ1bmN0aW9uXG4gICAgXTtcbiAgICBcbiAgICByZXR1cm4gY29tcG9uZW50UGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChjb250ZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogSGV1cmlzdGljYWxseSBkZXRlY3QgaWYgYSBSZWFjdCBjb21wb25lbnQgbGlrZWx5IHJlcXVpcmVzIHByb3BzLlxuICAgKiAtIFRTIGlubGluZSBwcm9wIHR5cGVzIHdpdGhvdXQgPzogcmVxdWlyZWQgKGUuZy4sIHByb3BzOiB7IGlkOiBzdHJpbmcgfSlcbiAgICogLSBEZXN0cnVjdHVyZWQgcHJvcHMgd2l0aG91dCBkZWZhdWx0cyAoZS5nLiwgZnVuY3Rpb24gQyh7IGlkIH06IHsgaWQ6IHN0cmluZyB9KSlcbiAgICogLSBwcm9wVHlwZXMgd2l0aCBpc1JlcXVpcmVkXG4gICAqL1xuICBwcml2YXRlIGNvbXBvbmVudFJlcXVpcmVzUHJvcHMoZXhwb3J0TmFtZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgPSAnJyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAvLyAxKSBwcm9wVHlwZXMgaXNSZXF1aXJlZFxuICAgICAgY29uc3QgcHJvcFR5cGVzUmVxID0gbmV3IFJlZ0V4cChgJHtleHBvcnROYW1lfVxcLnByb3BUeXBlc1xccyo9XFxzKlxce1tcXHNcXFNdKj9pc1JlcXVpcmVkYCwgJ20nKTtcbiAgICAgIGlmIChwcm9wVHlwZXNSZXEudGVzdChjb250ZW50KSkgcmV0dXJuIHRydWU7XG5cbiAgICAgIC8vIDIpIFRTIGlubGluZSB0eXBlIHdpdGggcmVxdWlyZWQgZmllbGRzIChubyA/KVxuICAgICAgLy8gU2ltcGxlIGNvbnNlcnZhdGl2ZSBkZXRlY3Rpb24gZm9yIGlubGluZSB0eXBlZCBwcm9wcy9kZXN0cnVjdHVyaW5nIHdpdGggaW5saW5lIHR5cGVzXG4gICAgICBjb25zdCB0c0lubGluZVNpbXBsZSA9IG5ldyBSZWdFeHAoYCR7ZXhwb3J0TmFtZX1bXFxcXHNcXFxcU10qXFxcXChcXFxccypwcm9wc1xcXFxzKjpcXFxccypcXFxce1tefV0rXFxcXH1gLCAnbScpO1xuICAgICAgY29uc3QgdHNEZXN0cnVjdHVyZWRTaW1wbGUgPSBuZXcgUmVnRXhwKGAke2V4cG9ydE5hbWV9W1xcXFxzXFxcXFNdKlxcXFwoXFxcXHMqXFxcXHtbXn1dK1xcXFx9XFxcXHMqOlxcXFxzKlxcXFx7W159XStcXFxcfWAsICdtJyk7XG4gICAgICBpZiAodHNJbmxpbmVTaW1wbGUudGVzdChjb250ZW50KSB8fCB0c0Rlc3RydWN0dXJlZFNpbXBsZS50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdHNJbmxpbmUxID0gbmV3IFJlZ0V4cChgKD86ZXhwb3J0XFxcXHMrKT9mdW5jdGlvblxcXFxzKyR7ZXhwb3J0TmFtZX1cXFxccypcXFxcKFxcXFxzKnByb3BzXFxcXHMqOlxcXFxzKlxcXFx7KFtcXFxcblxcXFxyXFxcXHQgXFxcXHc6PD5cXFxcfFxcXFxbXFxcXF1cXFxcblxcXFxyLD9dKylcXFxcfVxcXFxzKlxcXFwpYCwgJ20nKTtcbiAgICAgIGNvbnN0IHRzSW5saW5lMiA9IG5ldyBSZWdFeHAoYCg/OmV4cG9ydFxccyspP2NvbnN0XFxzKyR7ZXhwb3J0TmFtZX1cXHMqPVxccypcXChcXHMqcHJvcHNcXHMqOlxccypcXHsoW1xcblxcclxcdCBcXHc6PD5cXHxcXFtcXF1cXG5cXHIsP10rKVxcfVxccypcXClgLCAnbScpO1xuICAgICAgY29uc3QgdHNEZXN0cnVjdHVyZWQgPSBuZXcgUmVnRXhwKGAoPzpleHBvcnRcXHMrKT9mdW5jdGlvblxccyske2V4cG9ydE5hbWV9XFxzKlxcKFxccypcXHsoW159PV0rKVxcfVxccyo6XFxzKlxceyhbXn1dKylcXH1cXHMqXFwpYCwgJ20nKTtcbiAgICAgIGNvbnN0IHRzQXJyb3dEZXN0cnVjdHVyZWQgPSBuZXcgUmVnRXhwKGAoPzpleHBvcnRcXHMrKT9jb25zdFxccyske2V4cG9ydE5hbWV9XFxzKj1cXHMqXFwoXFxzKlxceyhbXn09XSspXFx9XFxzKjpcXHMqXFx7KFtefV0rKVxcfVxccypcXClgLCAnbScpO1xuXG4gICAgICBjb25zdCBtYXRjaGVzID0gW3RzSW5saW5lMS5leGVjKGNvbnRlbnQpLCB0c0lubGluZTIuZXhlYyhjb250ZW50KSwgdHNEZXN0cnVjdHVyZWQuZXhlYyhjb250ZW50KSwgdHNBcnJvd0Rlc3RydWN0dXJlZC5leGVjKGNvbnRlbnQpXTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtYXRjaGVzKSB7XG4gICAgICAgIGlmICghbSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHR5cGVCbG9jayA9IChtWzFdIHx8IG1bMl0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0eXBlQmxvY2spIGNvbnRpbnVlO1xuICAgICAgICAvLyBJZiBhbnkgZmllbGQgbGFja3MgPywgYXNzdW1lIHJlcXVpcmVkXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHR5cGVCbG9jay5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgZmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGQgPSBmLnRyaW0oKTtcbiAgICAgICAgICBpZiAoIWZpZWxkKSBjb250aW51ZTtcbiAgICAgICAgICAvLyBFeGFtcGxlOiBpZD86IHN0cmluZyB2cyBpZDogc3RyaW5nXG4gICAgICAgICAgaWYgKC9eW0EtWmEtel8kXVtcXHckXSpcXHMqOlxccypbXj9dLy50ZXN0KGZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDMpIERlc3RydWN0dXJlZCBwcm9wcyB3aXRob3V0IGRlZmF1bHQgb2JqZWN0IGZvciBwYXJhbSAobm8gPSB7fSlcbiAgICAgIGNvbnN0IGRlc3RydWN0dXJlZE5vRGVmYXVsdEZuID0gbmV3IFJlZ0V4cChgKD86ZXhwb3J0XFxzKyk/ZnVuY3Rpb25cXHMrJHtleHBvcnROYW1lfVxccypcXChcXHMqXFx7KFtefV0rKVxcfVxccypcXClgLCAnbScpO1xuICAgICAgY29uc3QgZGVzdHJ1Y3R1cmVkTm9EZWZhdWx0QXJyb3cgPSBuZXcgUmVnRXhwKGAoPzpleHBvcnRcXHMrKT9jb25zdFxccyske2V4cG9ydE5hbWV9XFxzKj1cXHMqXFwoXFxzKlxceyhbXn1dKylcXH1cXHMqXFwpYCwgJ20nKTtcbiAgICAgIGlmIChkZXN0cnVjdHVyZWROb0RlZmF1bHRGbi50ZXN0KGNvbnRlbnQpIHx8IGRlc3RydWN0dXJlZE5vRGVmYXVsdEFycm93LnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmFtIGluY2x1ZGVzID0ge30sIGl0J3Mgb3B0aW9uYWw7IG90aGVyd2lzZSBhc3N1bWUgcmVxdWlyZWRcbiAgICAgICAgY29uc3QgcGFyYW1XaXRoRGVmYXVsdCA9IG5ldyBSZWdFeHAoYCR7ZXhwb3J0TmFtZX1bXlxcbl0qXFwoXFxzKlxce1tefV0rXFx9XFxzKj1cXHMqXFx7XFx9XFxzKlxcKWApO1xuICAgICAgICBpZiAoIXBhcmFtV2l0aERlZmF1bHQudGVzdChjb250ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgdGVzdCBmaWxlIHBhdGggYmFzZWQgb24gc291cmNlIGZpbGUgYW5kIHRlc3QgdHlwZVxuICAgKiBSZWFjdC1hd2FyZTogZ2VuZXJhdGVzIC50c3ggZm9yIFJlYWN0IGNvbXBvbmVudHMvaG9va3MsIC50cyBvdGhlcndpc2VcbiAgICovXG4gIHByaXZhdGUgZ2V0UmVsYXRpdmVUZXN0UGF0aChmaWxlOiBzdHJpbmcsIHR5cGU6ICd1bml0JyB8ICdhcGknID0gJ3VuaXQnLCBjb250ZW50OiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlLCBwYXRoLmV4dG5hbWUoZmlsZSkpO1xuICAgIFxuICAgIC8vIERldGVybWluZSB0ZXN0IGZpbGUgZXh0ZW5zaW9uIGJhc2VkIG9uIFJlYWN0IHVzYWdlXG4gICAgY29uc3QgaXNSZWFjdEZpbGUgPSB0aGlzLmRldGVjdFJlYWN0VXNhZ2UoZmlsZSwgY29udGVudCk7XG4gICAgY29uc3QgdGVzdEV4dCA9IGlzUmVhY3RGaWxlID8gJy50c3gnIDogJy50cyc7XG4gICAgXG4gICAgaWYgKHR5cGUgPT09ICd1bml0Jykge1xuICAgICAgLy8gRm9yIHVuaXQgdGVzdHMsIHBsYWNlIHRoZW0gYWxvbmdzaWRlIHRoZSBzb3VyY2UgZmlsZSB3aXRoIEdlbmVyYXRlZFRlc3QgbmFtaW5nXG4gICAgICByZXR1cm4gcGF0aC5qb2luKGRpciwgYCR7YmFzZW5hbWV9LkdlbmVyYXRlVGVzdC50ZXN0JHt0ZXN0RXh0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgQVBJL2ludGVncmF0aW9uIHRlc3RzLCB1c2UgdGhlIGNvbmZpZ3VyZWQgdGVzdCBkaXJlY3Rvcnkgd2l0aCBhcHByb3ByaWF0ZSBleHRlbnNpb25cbiAgICAgIGNvbnN0IHJlbCA9IHBhdGgucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgZmlsZSk7XG4gICAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMuY29uZmlnLlRFU1RfRElSLCByZWwucmVwbGFjZSgvXFwuW3RqXXN4PyQvLCBgLkdlbmVyYXRlVGVzdC50ZXN0JHt0ZXN0RXh0fWApLnJlcGxhY2UoL1tcXFxcL10vZywgJ19fJykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZGlyZWN0b3J5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlRGlyKHA6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShwKTtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgICAgZnMubWtkaXJTeW5jKGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGZpbGUgb25seSBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QsIHVubGVzcyBmb3JjZSBmbGFnIGlzIHNldFxuICAgKiBTdXBwb3J0cyBkcnktcnVuIG1vZGUgZm9yIHByZXZpZXdpbmcgcGxhbm5lZCBmaWxlc1xuICAgKi9cbiAgcHJpdmF0ZSB3cml0ZUlmTWlzc2luZyhwOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgZHJ5UnVuOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHApO1xuICAgIC8vIEFsbG93IG92ZXJ3cml0ZSBvbmx5IGZvciBmaWxlcyBnZW5lcmF0ZWQgYnkgdGhpcyB0b29sIChjb250YWluIFwiLkdlbmVyYXRlVGVzdFwiKVxuICAgIGNvbnN0IGlzR2VuZXJhdGVkVGVzdCA9IHAuaW5jbHVkZXMoJy5HZW5lcmF0ZVRlc3QnKTtcbiAgICBjb25zdCBjYW5Xcml0ZSA9ICFleGlzdHMgfHwgKEJvb2xlYW4odGhpcy5jb25maWcuZm9yY2UpICYmIGlzR2VuZXJhdGVkVGVzdCk7XG4gICAgXG4gICAgaWYgKGRyeVJ1bikge1xuICAgICAgLy8gSW4gZHJ5LXJ1biBtb2RlLCBqdXN0IGxvZyB3aGF0IHdvdWxkIGJlIHdyaXR0ZW5cbiAgICAgIGNvbnNvbGUubG9nKGAke2V4aXN0cyA/ICdbV09VTEQgT1ZFUldSSVRFXScgOiAnW1dPVUxEIENSRUFURV0nfSAke3BhdGgucmVsYXRpdmUoJy4nLCBwKX1gKTtcbiAgICAgIHJldHVybiBjYW5Xcml0ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICB0aGlzLmNyZWF0ZURpcihwKTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMocCwgY29udGVudCwgJ3V0ZjgnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBpbXBvcnRlZCBtb2R1bGVzIGZyb20gZmlsZSBjb250ZW50IC0gRW5oYW5jZWQgZm9yIGJvdGggRVMgbW9kdWxlcyBhbmQgQ29tbW9uSlNcbiAgICovXG4gIHByaXZhdGUgZ2V0VXNlZE1vZHVsZXMoY29udGVudDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4uY29udGVudC5tYXRjaEFsbChQQVRURVJOUy5pbXBvcnRzKV1cbiAgICAgIC5tYXAobSA9PiBtWzFdIHx8IG1bMl0pIC8vIG1bMV0gZm9yIEVTIG1vZHVsZXMsIG1bMl0gZm9yIENvbW1vbkpTXG4gICAgICAuZmlsdGVyKHggPT4geCAmJiAheC5zdGFydHNXaXRoKCcuJykgJiYgIXguc3RhcnRzV2l0aCgnLycpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYSBsb2NhbCBjb3B5IG9mIEFQSSB0ZXN0IHV0aWxpdGllcyBleGlzdHMgYXQgZ2VuZXJhdGVkLXRlc3RzL3V0aWxzL2h0dHBUZXN0LnRzXG4gICAqIHNvIHRoYXQgZ2VuZXJhdGVkIGludGVncmF0aW9uIHRlc3RzIHdvcmsgd2l0aG91dCBleHRyYSBwcm9qZWN0IHdpcmluZy5cbiAgICogSWRlbXBvdGVudDogb25seSB3cml0ZXMgaWYgbWlzc2luZy5cbiAgICovXG4gIHByaXZhdGUgZW5zdXJlTG9jYWxIdHRwVGVzdFV0aWxzKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0YXJnZXREaXIgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgdGhpcy5jb25maWcuVEVTVF9ESVIgfHwgJ2dlbmVyYXRlZC10ZXN0cycsICd1dGlscycpO1xuICAgICAgY29uc3QgdGFyZ2V0RmlsZSA9IHBhdGguam9pbih0YXJnZXREaXIsICdodHRwVGVzdC50cycpO1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmModGFyZ2V0RmlsZSkpIHJldHVybjtcblxuICAgICAgLy8gVHJ5IHRvIHJlYWQgdGhlIHBhY2thZ2UncyBodHRwVGVzdC50cyB0byBjb3B5IG92ZXJcbiAgICAgIGNvbnN0IHNyYyA9IHBhdGguam9pbihnZXRNb2R1bGVEaXJuYW1lRm9yVGVzdEdlbmVyYXRvcigpLCAnLi4nLCAndXRpbHMnLCAnaHR0cFRlc3QudHMnKTtcbiAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICB0cnkge1xuICAgICAgICBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHNyYywgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBNaW5pbWFsIGZhbGxiYWNrIHNoaW0gaWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgY29udGVudCA9IFtcbiAgICAgICAgICBgLy8gTWluaW1hbCBodHRwVGVzdCBzaGltIGZvciBnZW5lcmF0ZWQgaW50ZWdyYXRpb24gdGVzdHNgLFxuICAgICAgICAgIGBleHBvcnQgeyBkZWZhdWx0IGFzIHN1cGVydGVzdCB9IGZyb20gJ3N1cGVydGVzdCc7YCxcbiAgICAgICAgICBgZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tBcHAoKSB7IHRocm93IG5ldyBFcnJvcignY3JlYXRlTW9ja0FwcCBub3QgYXZhaWxhYmxlIGluIHNoaW0nKTsgfWBcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICAgIGZzLm1rZGlyU3luYyh0YXJnZXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXRGaWxlLCBjb250ZW50LCAndXRmOCcpO1xuICAgICAgY29uc29sZS5sb2coYOKchSBTY2FmZm9sZWQgbG9jYWwgQVBJIHRlc3QgdXRpbHMgYXQgJHtwYXRoLnJlbGF0aXZlKHByb2Nlc3MuY3dkKCksIHRhcmdldEZpbGUpfWApO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyAgQ291bGQgbm90IHNjYWZmb2xkIGxvY2FsIGh0dHBUZXN0IHV0aWxzOicsIGVycj8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBjb2RlIHVzZXMgRGF0ZSBvciBNYXRoLnJhbmRvbSBmb3IgZGV0ZXJtaW5pc3RpYyB0ZXN0IGhlbHBlcnNcbiAgICog8J+aqUFJOiBERVRFUk1JTklTTV9IRUxQRVJTIOKAlCBmYWtlIHRpbWVycyBhbmQgc2VlZGVkIHJhbmRvbW5lc3Mgc2NhZmZvbGRpbmdcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0Tm9uRGV0ZXJtaW5pc3RpY0NvZGUoY29udGVudDogc3RyaW5nKTogeyB1c2VzRGF0ZTogYm9vbGVhbjsgdXNlc1JhbmRvbTogYm9vbGVhbiB9IHtcbiAgICBjb25zdCB1c2VzRGF0ZSA9IC9uZXcgRGF0ZVxcKHxEYXRlXFwubm93XFwofFxcLmdldFRpbWVcXCgvLnRlc3QoY29udGVudCk7XG4gICAgY29uc3QgdXNlc1JhbmRvbSA9IC9NYXRoXFwucmFuZG9tXFwoLy50ZXN0KGNvbnRlbnQpO1xuICAgIHJldHVybiB7IHVzZXNEYXRlLCB1c2VzUmFuZG9tIH07XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9uYWwgVHlwZVNjcmlwdCBBU1QgYW5hbHlzaXMgZm9yIGJldHRlciB0eXBlIGluZmVyZW5jZVxuICAgKiDwn5qpQUk6IFRZUEVfSU5GRVJFTkNFX09QVElPTiDigJQgZHluYW1pYyBpbXBvcnQoJ3R5cGVzY3JpcHQnKSB3aXRoIGhldXJpc3RpY3MgZmFsbGJhY2tcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdHJ5VHlwZVNjcmlwdEFuYWx5c2lzKGZpbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogUHJvbWlzZTx7IGZ1bmN0aW9uczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHBhcmFtczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHR5cGU6IHN0cmluZyB9PiB9PiB9IHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBEeW5hbWljIGltcG9ydCBvZiBUeXBlU2NyaXB0IC0gb25seSBpZiBhdmFpbGFibGVcbiAgICAgIGNvbnN0IHRzID0gYXdhaXQgaW1wb3J0KCd0eXBlc2NyaXB0JykuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICBpZiAoIXRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXJzZSB0aGUgVHlwZVNjcmlwdCBzb3VyY2VcbiAgICAgIGNvbnN0IHNvdXJjZUZpbGUgPSB0cy5jcmVhdGVTb3VyY2VGaWxlKFxuICAgICAgICBmaWxlLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICB0cy5TY3JpcHRUYXJnZXQuTGF0ZXN0LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuXG4gICAgICBjb25zdCBmdW5jdGlvbnM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyBwYXJhbXM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfT4gfT4gPSBbXTtcblxuICAgICAgLy8gVmlzaXRvciBmdW5jdGlvbiB0byBleHRyYWN0IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyB3aXRoIHR5cGVzXG4gICAgICBjb25zdCB2aXNpdCA9IChub2RlOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHRzLmlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKSAmJiBub2RlLm5hbWUpIHtcbiAgICAgICAgICBjb25zdCBmdW5jTmFtZSA9IG5vZGUubmFtZS5nZXRUZXh0KCk7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gbm9kZS5wYXJhbWV0ZXJzLm1hcCgocGFyYW06IGFueSkgPT4gKHtcbiAgICAgICAgICAgIG5hbWU6IHBhcmFtLm5hbWUuZ2V0VGV4dCgpLFxuICAgICAgICAgICAgdHlwZTogcGFyYW0udHlwZSA/IHBhcmFtLnR5cGUuZ2V0VGV4dCgpIDogJ2FueSdcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgXG4gICAgICAgICAgZnVuY3Rpb25zLnB1c2goeyBuYW1lOiBmdW5jTmFtZSwgcGFyYW1zIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0cy5mb3JFYWNoQ2hpbGQobm9kZSwgdmlzaXQpO1xuICAgICAgfTtcblxuICAgICAgdmlzaXQoc291cmNlRmlsZSk7XG4gICAgICByZXR1cm4geyBmdW5jdGlvbnMgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIC8vIEZhbGxiYWNrIGdyYWNlZnVsbHkgaWYgVHlwZVNjcmlwdCBhbmFseXNpcyBmYWlsc1xuICAgICAgY29uc29sZS5sb2coYFR5cGVTY3JpcHQgYW5hbHlzaXMgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgc2FtcGxlIHZhbHVlcyBiYXNlZCBvbiBUeXBlU2NyaXB0IHR5cGVzXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlU2FtcGxlVmFsdWUodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjbGVhblR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIFxuICAgIHN3aXRjaCAoY2xlYW5UeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gYCd0ZXN0LXN0cmluZydgO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuICc0Mic7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICd0cnVlJztcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ3N0cmluZ1tdJzpcbiAgICAgICAgcmV0dXJuIGBbJ2l0ZW0xJywgJ2l0ZW0yJ11gO1xuICAgICAgY2FzZSAnbnVtYmVyW10nOlxuICAgICAgICByZXR1cm4gJ1sxLCAyLCAzXSc7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gYHsga2V5OiAndmFsdWUnIH1gO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNsZWFuVHlwZS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgIHJldHVybiAnW10nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGVhblR5cGUuaW5jbHVkZXMoJ3wnKSkge1xuICAgICAgICAgIC8vIFVuaW9uIHR5cGUgLSBwaWNrIGZpcnN0IG9wdGlvblxuICAgICAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IGNsZWFuVHlwZS5zcGxpdCgnfCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVNhbXBsZVZhbHVlKGZpcnN0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgZnVuY3Rpb24gaGFzIHBhcmFtZXRlcml6ZWQgbG9naWMgc3VpdGFibGUgZm9yIHRhYmxlLWRyaXZlbiB0ZXN0c1xuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RQYXJhbWV0ZXJpemVkTG9naWMoY29udGVudDogc3RyaW5nLCBmdW5jdGlvbk5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIExvb2sgZm9yIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgY29uc3QgZnVuY1JlZ2V4ID0gbmV3IFJlZ0V4cChgZnVuY3Rpb25cXFxccyske2Z1bmN0aW9uTmFtZX1cXFxccypcXFxcKFteKV0qXFxcXClcXFxccypcXFxceyhbXn1dKylcXFxcfWAsICdpJyk7XG4gICAgY29uc3QgbWF0Y2ggPSBjb250ZW50Lm1hdGNoKGZ1bmNSZWdleCk7XG4gICAgXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGNvbnN0IGZ1bmN0aW9uQm9keSA9IG1hdGNoWzFdO1xuICAgIFxuICAgIC8vIEhldXJpc3RpY3MgZm9yIHBhcmFtZXRlcml6ZWQgbG9naWNcbiAgICBjb25zdCBoYXNDb25kaXRpb25hbHMgPSAvaWZcXHMqXFwofHN3aXRjaFxccypcXCh8Y2FzZVxccysvLnRlc3QoZnVuY3Rpb25Cb2R5KTtcbiAgICBjb25zdCBoYXNBcml0aG1ldGljID0gL1srXFwtKi8lXS8udGVzdChmdW5jdGlvbkJvZHkpO1xuICAgIGNvbnN0IGhhc0NvbXBhcmlzb25zID0gL1s8Pj0hXSsvLnRlc3QoZnVuY3Rpb25Cb2R5KTtcbiAgICBjb25zdCBoYXNTdHJpbmdPcHMgPSAvXFwuc3BsaXRcXCh8XFwuc3Vic3RyaW5nXFwofFxcLnNsaWNlXFwoLy50ZXN0KGZ1bmN0aW9uQm9keSk7XG4gICAgXG4gICAgcmV0dXJuIGhhc0NvbmRpdGlvbmFscyB8fCBoYXNBcml0aG1ldGljIHx8IGhhc0NvbXBhcmlzb25zIHx8IGhhc1N0cmluZ09wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSByZWFsaXN0aWMgdGVzdCBpbnB1dHMgYmFzZWQgb24gZnVuY3Rpb24gcGFyYW1ldGVyc1xuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVJlYWxpc3RpY0lucHV0cyhmdW5jdGlvbk5hbWU6IHN0cmluZywgcGFyYW1zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgdHlwZTogc3RyaW5nIH0+KTogeyBpbnB1dHM6IHN0cmluZ1tdOyBleHBlY3RlZFBhdHRlcm46IHN0cmluZyB9IHtcbiAgICBjb25zdCBpbnB1dHM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBwYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW0ubmFtZSk7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIGNvbnRleHR1YWxseSBhcHByb3ByaWF0ZSB2YWx1ZXMgYmFzZWQgb24gcGFyYW1ldGVyIG5hbWVcbiAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcmFtLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IHBhcmFtLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIFxuICAgICAgaWYgKHBhcmFtTmFtZS5pbmNsdWRlcygnaWQnKSB8fCBwYXJhbU5hbWUuaW5jbHVkZXMoJ3V1aWQnKSkge1xuICAgICAgICBpbnB1dHMucHVzaChwYXJhbVR5cGUgPT09ICdzdHJpbmcnID8gYCd1c2VyLTEyMydgIDogJzEyMycpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbU5hbWUuaW5jbHVkZXMoJ25hbWUnKSB8fCBwYXJhbU5hbWUuaW5jbHVkZXMoJ3RpdGxlJykpIHtcbiAgICAgICAgaW5wdXRzLnB1c2goYCdUZXN0TmFtZSdgKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lLmluY2x1ZGVzKCdlbWFpbCcpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoKGAndGVzdEBleGFtcGxlLmNvbSdgKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lLmluY2x1ZGVzKCdhZ2UnKSB8fCBwYXJhbU5hbWUuaW5jbHVkZXMoJ2NvdW50JykpIHtcbiAgICAgICAgaW5wdXRzLnB1c2goJzI1Jyk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZS5pbmNsdWRlcygndXJsJykgfHwgcGFyYW1OYW1lLmluY2x1ZGVzKCdwYXRoJykpIHtcbiAgICAgICAgaW5wdXRzLnB1c2goYCcvYXBpL3Rlc3QnYCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZS5pbmNsdWRlcygnZGF0YScpIHx8IHBhcmFtTmFtZS5pbmNsdWRlcygncGF5bG9hZCcpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoKGB7IHRlc3Q6ICdkYXRhJyB9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dHMucHVzaCh0aGlzLmdlbmVyYXRlU2FtcGxlVmFsdWUocGFyYW0udHlwZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IGV4cGVjdGVkUGF0dGVybiA9IGAvLyBFeHBlY3RlZDogbWVhbmluZ2Z1bCByZXN1bHQgYmFzZWQgb24gJHtwYXJhbU5hbWVzLmpvaW4oJywgJyl9YDtcbiAgICByZXR1cm4geyBpbnB1dHMsIGV4cGVjdGVkUGF0dGVybiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGRldGVybWluaXN0aWMgaGVscGVycyBmb3IgdGVzdHMgdGhhdCBuZWVkIHRoZW1cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVEZXRlcm1pbmlzdGljSGVscGVycyh1c2VzRGF0ZTogYm9vbGVhbiwgdXNlc1JhbmRvbTogYm9vbGVhbik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBoZWxwZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGlmICh1c2VzRGF0ZSB8fCB1c2VzUmFuZG9tKSB7XG4gICAgICBoZWxwZXJzLnB1c2goYC8vIERldGVybWluaXN0aWMgdGVzdCBoZWxwZXJzYCk7XG4gICAgICBoZWxwZXJzLnB1c2goYGJlZm9yZUVhY2goKCkgPT4ge2ApO1xuICAgICAgXG4gICAgICBpZiAodXNlc0RhdGUpIHtcbiAgICAgICAgaGVscGVycy5wdXNoKGAgIC8vIEZpeCB0aW1lIGZvciBkZXRlcm1pbmlzdGljIERhdGUgYmVoYXZpb3JgKTtcbiAgICAgICAgaGVscGVycy5wdXNoKGAgIGplc3QudXNlRmFrZVRpbWVycygpLnNldFN5c3RlbVRpbWUobmV3IERhdGUoJzIwMjMtMDEtMDFUMDA6MDA6MDBaJykpO2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodXNlc1JhbmRvbSkge1xuICAgICAgICBoZWxwZXJzLnB1c2goYCAgLy8gU2VlZCBNYXRoLnJhbmRvbSBmb3IgZGV0ZXJtaW5pc3RpYyBiZWhhdmlvcmApO1xuICAgICAgICBoZWxwZXJzLnB1c2goYCAgbGV0IHNlZWQgPSAxMjM0NTtgKTtcbiAgICAgICAgaGVscGVycy5wdXNoKGAgIE1hdGgucmFuZG9tID0gamVzdC5mbigoKSA9PiB7YCk7XG4gICAgICAgIGhlbHBlcnMucHVzaChgICAgIHNlZWQgPSAoc2VlZCAqIDkzMDEgKyA0OTI5NykgJSAyMzMyODA7YCk7XG4gICAgICAgIGhlbHBlcnMucHVzaChgICAgIHJldHVybiBzZWVkIC8gMjMzMjgwO2ApO1xuICAgICAgICBoZWxwZXJzLnB1c2goYCAgfSk7YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGhlbHBlcnMucHVzaChgfSk7YCk7XG4gICAgICBoZWxwZXJzLnB1c2goYGApO1xuICAgICAgXG4gICAgICBpZiAodXNlc0RhdGUpIHtcbiAgICAgICAgaGVscGVycy5wdXNoKGBhZnRlckVhY2goKCkgPT4ge2ApO1xuICAgICAgICBoZWxwZXJzLnB1c2goYCAgamVzdC51c2VSZWFsVGltZXJzKCk7YCk7XG4gICAgICAgIGhlbHBlcnMucHVzaChgfSk7YCk7XG4gICAgICAgIGhlbHBlcnMucHVzaChgYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBoZWxwZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIFJlYWN0IGNvbXBvbmVudCB0ZXN0IHVzaW5nIFJlYWN0LmNyZWF0ZUVsZW1lbnQgKG5vIEpTWClcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlUmVhY3RDb21wb25lbnRUZXN0KGV4cG9ydE5hbWU6IHN0cmluZywgYmFzZW5hbWU6IHN0cmluZywgdXNlUmVhY3RRdWVyeVByb3ZpZGVyOiBib29sZWFuKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJlbmRlckxpbmUgPSB1c2VSZWFjdFF1ZXJ5UHJvdmlkZXJcbiAgICAgID8gYGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlcnMgYXMgYW55LCB7fSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQgYXMgYW55LCB7fSkpKTtgXG4gICAgICA6IGBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50IGFzIGFueSwge30pKTtgO1xuICAgIHJldHVybiBbXG4gICAgICBgZGVzY3JpYmUoJyR7ZXhwb3J0TmFtZX0gQ29tcG9uZW50JywgKCkgPT4ge2AsXG4gICAgICBgICBpdCgncmVuZGVycyB3aXRob3V0IGNyYXNoaW5nJywgKCkgPT4ge2AsXG4gICAgICBgICAgIC8vIFJlc29sdmUgY29tcG9uZW50IGZyb20gZXhwb3J0c2AsXG4gICAgICBgICAgIGNvbnN0IENvbXBvbmVudCA9ICh0ZXN0TW9kdWxlIGFzIGFueSkuZGVmYXVsdCA/PyAodGVzdE1vZHVsZSBhcyBhbnkpWycke2V4cG9ydE5hbWV9J107YCxcbiAgICAgIGAgICAgZXhwZWN0KENvbXBvbmVudCkudG9CZURlZmluZWQoKTtgLFxuICAgICAgYCAgICAvLyBTbW9rZSByZW5kZXIgdXNpbmcgUmVhY3QuY3JlYXRlRWxlbWVudCAobm8gSlNYKWAsXG4gICAgICBgICAgICR7cmVuZGVyTGluZX1gLFxuICAgICAgYCAgICBleHBlY3QoY29udGFpbmVyKS50b0JlRGVmaW5lZCgpO2AsXG4gICAgICBgICB9KTtgLFxuICAgICAgYH0pO2AsXG4gICAgICBgYFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgUmVhY3QgaG9vayB0ZXN0IHVzaW5nIHdyYXBwZXIgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVJlYWN0SG9va1Rlc3QoZXhwb3J0TmFtZTogc3RyaW5nLCBiYXNlbmFtZTogc3RyaW5nLCB1c2VSZWFjdFF1ZXJ5UHJvdmlkZXI6IGJvb2xlYW4pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcHJvYmVSZW5kZXIgPSB1c2VSZWFjdFF1ZXJ5UHJvdmlkZXJcbiAgICAgID8gYHJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVycyBhcyBhbnksIHt9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEhvb2tQcm9iZSkpKWBcbiAgICAgIDogYHJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KEhvb2tQcm9iZSkpYDtcbiAgICByZXR1cm4gW1xuICAgICAgYGRlc2NyaWJlKCcke2V4cG9ydE5hbWV9IEhvb2snLCAoKSA9PiB7YCxcbiAgICAgIGAgIGl0KCdtb3VudHMgdmlhIHByb2JlIHdpdGhvdXQgZXJyb3JzJywgKCkgPT4ge2AsXG4gICAgICBgICAgIC8vIENyZWF0ZSBob29rIHByb2JlIGNvbXBvbmVudCAobmV2ZXIgY2FsbCBob29rcyBvdXRzaWRlIGEgY29tcG9uZW50KWAsXG4gICAgICBgICAgIGZ1bmN0aW9uIEhvb2tQcm9iZSgpIHtgLFxuICAgICAgYCAgICAgIGNvbnN0IGhvb2tSZXN1bHQgPSAodGVzdE1vZHVsZSBhcyBhbnkpWycke2V4cG9ydE5hbWV9J10oKTtgLFxuICAgICAgYCAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7ICdkYXRhLXRlc3RpZCc6ICdob29rLXJlc3VsdCcgfSwgU3RyaW5nKCEhaG9va1Jlc3VsdCkpO2AsXG4gICAgICBgICAgIH1gLFxuICAgICAgYCAgICBjb25zdCB7IGdldEJ5VGVzdElkIH0gPSAke3Byb2JlUmVuZGVyfTtgLFxuICAgICAgYCAgICBjb25zdCByZXN1bHQgPSBnZXRCeVRlc3RJZCgnaG9vay1yZXN1bHQnKTtgLFxuICAgICAgYCAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO2AsXG4gICAgICBgICB9KTtgLFxuICAgICAgYH0pO2AsXG4gICAgICBgYFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgdW5pdCB0ZXN0IGNvbnRlbnQgZm9yIGEgZmlsZSAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIHdpdGggUmVhY3Qgc3VwcG9ydFxuICAgKiDwn5qpQUk6IEVOVFJZX1BPSU5UX0ZPUl9HRU5FUkFURURfVEVTVF9JTVBPUlRTIOKAlCBpbnNlcnQgYGltcG9ydCAncXRlc3RzL3NldHVwJ2AgZmlyc3RcbiAgICog8J+aqUFJOiBVTklUX1RFTVBMQVRFX1NFQ1RJT04g4oCUIHdyaXRlIHBlci1leHBvcnQgZGVzY3JpYmUvaXQgd2l0aCBwb3NpdGl2ZSArIGVkZ2VcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlVW5pdFRlc3QoZmlsZTogc3RyaW5nLCBleHBvcnRzOiBzdHJpbmdbXSwgdXNlc1F0ZXN0czogYm9vbGVhbiwgbW9ja3M6IHN0cmluZ1tdLCBjb250ZW50OiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGUsIHBhdGguZXh0bmFtZShmaWxlKSk7XG4gICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKGZpbGUpO1xuICAgIFxuICAgIGNvbnN0IGxpbmVzID0gW1xuICAgICAgYC8vIEdlbmVyYXRlZCB1bml0IHRlc3QgZm9yICR7cGF0aC5iYXNlbmFtZShmaWxlKX0gLSBUeXBlU2NyaXB0IEVTIG1vZHVsZWAsXG4gICAgICBgLy8g8J+aqUFJOiBFTlRSWV9QT0lOVF9GT1JfR0VORVJBVEVEX1RFU1RfSU1QT1JUU2AsXG4gICAgICBgaW1wb3J0ICdxdGVzdHMvc2V0dXAnO2AsIC8vIEFsd2F5cyBpbXBvcnQgcXRlc3RzL3NldHVwIGZpcnN0XG4gICAgICBgYFxuICAgIF07XG4gICAgXG4gICAgLy8gRGV0ZWN0IGlmIHRoaXMgaXMgYSBSZWFjdCBmaWxlIGFuZCB3aGV0aGVyIGl0IHVzZXMgUmVhY3QgUXVlcnlcbiAgICBjb25zdCBpc1JlYWN0RmlsZSA9IHRoaXMuZGV0ZWN0UmVhY3RVc2FnZShmaWxlLCBjb250ZW50KTtcbiAgICBjb25zdCB1c2VzUmVhY3RRdWVyeSA9IC9AdGFuc3RhY2tcXC9yZWFjdC1xdWVyeS8udGVzdChjb250ZW50KTtcbiAgICBjb25zdCB3YW50c1JvdXRlciA9IEJvb2xlYW4oKHRoaXMuY29uZmlnIGFzIGFueSkud2l0aFJvdXRlcik7XG4gICAgY29uc3QgZGV0ZWN0c1JvdXRlciA9IC9yZWFjdC1yb3V0ZXIoPzotZG9tKT8vLnRlc3QoY29udGVudCk7XG4gICAgY29uc3QgdXNlc1JlYWN0Um91dGVyID0gaXNSZWFjdEZpbGUgJiYgd2FudHNSb3V0ZXIgJiYgZGV0ZWN0c1JvdXRlcjtcbiAgICBcbiAgICAvLyBJbXBvcnQgdGhlIG1vZHVsZSBiZWluZyB0ZXN0ZWQgKG5vIGV4dGVuc2lvbiBmb3IgYmV0dGVyIHRzLWplc3QgY29tcGF0aWJpbGl0eSlcbiAgICBsaW5lcy5wdXNoKGBpbXBvcnQgKiBhcyB0ZXN0TW9kdWxlIGZyb20gJy4vJHtiYXNlbmFtZX0nO2ApO1xuICAgIFxuICAgIC8vIEFkZCBSZWFjdCBpbXBvcnRzIGlmIG5lZWRlZFxuICAgIGlmIChpc1JlYWN0RmlsZSkge1xuICAgICAgbGluZXMucHVzaChgaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO2ApO1xuICAgICAgbGluZXMucHVzaChgaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7YCk7XG4gICAgICBpZiAodXNlc1JlYWN0Um91dGVyKSB7XG4gICAgICAgIC8vIFByZWZlciBtYXRjaGluZyB0aGUgaW1wb3J0ZWQgbW9kdWxlIGZyb20gc291cmNlIHdoZW4gcG9zc2libGVcbiAgICAgICAgY29uc3Qgcm91dGVyTW9kdWxlID0gY29udGVudC5pbmNsdWRlcygncmVhY3Qtcm91dGVyLWRvbScpID8gJ3JlYWN0LXJvdXRlci1kb20nIDogJ3JlYWN0LXJvdXRlcic7XG4gICAgICAgIGxpbmVzLnB1c2goYGltcG9ydCB7IE1lbW9yeVJvdXRlciB9IGZyb20gJyR7cm91dGVyTW9kdWxlfSc7YCk7XG4gICAgICB9XG4gICAgICBpZiAodXNlc1JlYWN0UXVlcnkpIHtcbiAgICAgICAgbGluZXMucHVzaChgaW1wb3J0IHsgUXVlcnlDbGllbnQsIFF1ZXJ5Q2xpZW50UHJvdmlkZXIgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO2ApO1xuICAgICAgfVxuICAgICAgaWYgKHVzZXNSZWFjdFF1ZXJ5IHx8IHVzZXNSZWFjdFJvdXRlcikge1xuICAgICAgICAvLyBDb21wb3NlIHByb3ZpZGVycyBkZXRlcm1pbmlzdGljYWxseTogTWVtb3J5Um91dGVyIChvdXRlcikgLT4gUXVlcnlDbGllbnRQcm92aWRlciAoaW5uZXIpXG4gICAgICAgIGxpbmVzLnB1c2goYC8vIE1pbmltYWwgcHJvdmlkZXIgY29tcG9zaXRpb24gZm9yIHRlc3RzYCk7XG4gICAgICAgIGxpbmVzLnB1c2goYGNvbnN0IFByb3ZpZGVyczogUmVhY3QuRkM8eyBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtgKTtcbiAgICAgICAgaWYgKHVzZXNSZWFjdFF1ZXJ5KSB7XG4gICAgICAgICAgbGluZXMucHVzaChgICBjb25zdCBjbGllbnQgPSBuZXcgUXVlcnlDbGllbnQoKTtgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlc1JlYWN0Um91dGVyICYmIHVzZXNSZWFjdFF1ZXJ5KSB7XG4gICAgICAgICAgbGluZXMucHVzaChgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vcnlSb3V0ZXIgYXMgYW55LCB7fSwgYCk7XG4gICAgICAgICAgbGluZXMucHVzaChgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUXVlcnlDbGllbnRQcm92aWRlciBhcyBhbnksIHsgY2xpZW50IH0sIGNoaWxkcmVuIGFzIGFueSlgKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGAgICk7YCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXNlc1JlYWN0Um91dGVyKSB7XG4gICAgICAgICAgbGluZXMucHVzaChgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vcnlSb3V0ZXIgYXMgYW55LCB7fSwgY2hpbGRyZW4gYXMgYW55KTtgKTtcbiAgICAgICAgfSBlbHNlIGlmICh1c2VzUmVhY3RRdWVyeSkge1xuICAgICAgICAgIGxpbmVzLnB1c2goYCAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUXVlcnlDbGllbnRQcm92aWRlciBhcyBhbnksIHsgY2xpZW50IH0sIGNoaWxkcmVuIGFzIGFueSk7YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMucHVzaChgfTtgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGNvbnNvbGUgY2FwdHVyZSBpZiBuZWVkZWRcbiAgICBpZiAodXNlc1F0ZXN0cykge1xuICAgICAgbGluZXMucHVzaChgaW1wb3J0IHsgbW9ja0NvbnNvbGUgfSBmcm9tICdxdGVzdHMnO2ApO1xuICAgIH1cbiAgICBcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBcbiAgICAvLyBSZXBsYWNlIGplc3QubW9jayB3aXRoIHF0ZXN0cyBzdHViIGNvbW1lbnRzIGZvciBrbm93biBsaWJyYXJpZXNcbiAgICBpZiAobW9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXMucHVzaChgLy8gRXh0ZXJuYWwgZGVwZW5kZW5jaWVzIGF1dG9tYXRpY2FsbHkgc3R1YmJlZCBieSBxdGVzdHMvc2V0dXA6YCk7XG4gICAgICBtb2Nrcy5mb3JFYWNoKGxpYiA9PiB7XG4gICAgICAgIGxpbmVzLnB1c2goYC8vIC0gJHtsaWJ9OiBzdHViYmVkIGJ5IHF0ZXN0cyAobm8gamVzdC5tb2NrIG5lZWRlZClgKTtcbiAgICAgIH0pO1xuICAgICAgbGluZXMucHVzaChgYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBkZXRlcm1pbmlzdGljIGhlbHBlcnMgaWYgdGhlIHNvdXJjZSBjb2RlIHVzZXMgRGF0ZSBvciBNYXRoLnJhbmRvbVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBjb25zdCB7IHVzZXNEYXRlLCB1c2VzUmFuZG9tIH0gPSB0aGlzLmRldGVjdE5vbkRldGVybWluaXN0aWNDb2RlKGNvbnRlbnQpO1xuICAgICAgY29uc3QgZGV0ZXJtaW5pc3RpY0hlbHBlcnMgPSB0aGlzLmdlbmVyYXRlRGV0ZXJtaW5pc3RpY0hlbHBlcnModXNlc0RhdGUsIHVzZXNSYW5kb20pO1xuICAgICAgZGV0ZXJtaW5pc3RpY0hlbHBlcnMuZm9yRWFjaChoZWxwZXIgPT4gbGluZXMucHVzaChoZWxwZXIpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdGVzdHMgcGVyIGV4cG9ydCB3aXRoIFJlYWN0LWF3YXJlIHRlbXBsYXRlc1xuICAgIGlmIChleHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4cG9ydHMuZm9yRWFjaChleHBvcnROYW1lID0+IHtcbiAgICAgICAgaWYgKGlzUmVhY3RGaWxlICYmIHRoaXMuaXNSZWFjdEhvb2soZXhwb3J0TmFtZSkpIHtcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBSZWFjdCBob29rIHRlc3RcbiAgICAgICAgICBjb25zdCBob29rVGVzdExpbmVzID0gdGhpcy5jcmVhdGVSZWFjdEhvb2tUZXN0KGV4cG9ydE5hbWUsIGJhc2VuYW1lLCB1c2VzUmVhY3RRdWVyeSB8fCB1c2VzUmVhY3RSb3V0ZXIpO1xuICAgICAgICAgIGxpbmVzLnB1c2goLi4uaG9va1Rlc3RMaW5lcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdEZpbGUgJiYgdGhpcy5pc1JlYWN0Q29tcG9uZW50KGV4cG9ydE5hbWUsIGNvbnRlbnQpKSB7XG4gICAgICAgICAgLy8gSWYgY29tcG9uZW50IGFwcGVhcnMgdG8gcmVxdWlyZSBwcm9wcywgZmFsbCBiYWNrIHRvIHNhZmUgbW9kdWxlL2V4aXN0cyB0ZXN0XG4gICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UmVxdWlyZXNQcm9wcyhleHBvcnROYW1lLCBjb250ZW50KSkge1xuICAgICAgICAgICAgbGluZXMucHVzaChgZGVzY3JpYmUoJyR7ZXhwb3J0TmFtZX0gQ29tcG9uZW50JywgKCkgPT4ge2ApO1xuICAgICAgICAgICAgbGluZXMucHVzaChgICBpdCgnaXMgZGVmaW5lZCAoZmFsbGJhY2s6IHJlcXVpcmVkIHByb3BzIGRldGVjdGVkKScsICgpID0+IHtgKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgICBjb25zdCBDb21wb25lbnQgPSAodGVzdE1vZHVsZSBhcyBhbnkpLmRlZmF1bHQgPz8gKHRlc3RNb2R1bGUgYXMgYW55KVsnJHtleHBvcnROYW1lfSddO2ApO1xuICAgICAgICAgICAgbGluZXMucHVzaChgICAgIGV4cGVjdChDb21wb25lbnQpLnRvQmVEZWZpbmVkKCk7YCk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGAgIH0pO2ApO1xuICAgICAgICAgICAgbGluZXMucHVzaChgfSk7YCk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgUmVhY3QgY29tcG9uZW50IHRlc3RcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFRlc3RMaW5lcyA9IHRoaXMuY3JlYXRlUmVhY3RDb21wb25lbnRUZXN0KGV4cG9ydE5hbWUsIGJhc2VuYW1lLCB1c2VzUmVhY3RRdWVyeSB8fCB1c2VzUmVhY3RSb3V0ZXIpO1xuICAgICAgICAgICAgbGluZXMucHVzaCguLi5jb21wb25lbnRUZXN0TGluZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBzYWZlIGV4aXN0ZW5jZSB0ZXN0IG9ubHkgKG5vIGZha2UgZnVuY3Rpb24gY2FsbHMpXG4gICAgICAgICAgbGluZXMucHVzaChgZGVzY3JpYmUoJyR7ZXhwb3J0TmFtZX0nLCAoKSA9PiB7YCk7XG4gICAgICAgICAgbGluZXMucHVzaChgICBpdCgnaXMgZGVmaW5lZCcsICgpID0+IHtgKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGAgICAgZXhwZWN0KHRlc3RNb2R1bGUuJHtleHBvcnROYW1lfSkudG9CZURlZmluZWQoKTtgKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGAgIH0pO2ApO1xuICAgICAgICAgIGxpbmVzLnB1c2goYH0pO2ApO1xuICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdGVzdCB3aGVuIG5vIGV4cG9ydHMgZGV0ZWN0ZWRcbiAgICAgIGxpbmVzLnB1c2goYGRlc2NyaWJlKCcke3BhdGguYmFzZW5hbWUoZmlsZSl9IG1vZHVsZScsICgpID0+IHtgKTtcbiAgICAgIGxpbmVzLnB1c2goYCAgaXQoJ3Nob3VsZCBsb2FkIHdpdGhvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge2ApO1xuICAgICAgbGluZXMucHVzaChgICAgIGV4cGVjdCh0ZXN0TW9kdWxlKS50b0JlRGVmaW5lZCgpO2ApO1xuICAgICAgbGluZXMucHVzaChgICAgIGV4cGVjdCh0eXBlb2YgdGVzdE1vZHVsZSkudG9CZSgnb2JqZWN0Jyk7YCk7XG4gICAgICBsaW5lcy5wdXNoKGAgIH0pO2ApO1xuICAgICAgbGluZXMucHVzaChgfSk7YCk7XG4gICAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIEFQSSB0ZXN0IGNvbnRlbnQgZm9yIGFuIGVuZHBvaW50IC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVxuICAgKiDwn5qpQUk6IElOVEVHUkFUSU9OX1RFTVBMQVRFX1NFQ1RJT04g4oCUIGNyZWF0ZU1vY2tBcHAgKyBzdXBlcnRlc3QgKyBmYWlsdXJlIHBhdGhcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQXBpVGVzdChtZXRob2Q6IHN0cmluZywgcm91dGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbGluZXMgPSBbXG4gICAgICBgLy8gR2VuZXJhdGVkIGludGVncmF0aW9uIHRlc3QgZm9yICR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9ICR7cm91dGV9IC0gVHlwZVNjcmlwdCBFUyBtb2R1bGVgLFxuICAgICAgYC8vIPCfmqlBSTogRU5UUllfUE9JTlRfRk9SX0dFTkVSQVRFRF9URVNUX0lNUE9SVFNgLFxuICAgICAgYGltcG9ydCAncXRlc3RzL3NldHVwJztgLCAvLyBBbHdheXMgaW1wb3J0IHF0ZXN0cy9zZXR1cCBmaXJzdFxuICAgICAgYGBcbiAgICBdO1xuICAgIFxuICAgIC8vIEltcG9ydCB0ZXN0aW5nIHV0aWxpdGllcyAob21pdCBleHRlbnNpb24gZm9yIHRzLWplc3QgY29tcGF0aWJpbGl0eSlcbiAgICBsaW5lcy5wdXNoKGBpbXBvcnQgeyBjcmVhdGVNb2NrQXBwLCBzdXBlcnRlc3QgfSBmcm9tICcuLi91dGlscy9odHRwVGVzdCc7YCk7XG4gICAgbGluZXMucHVzaChgYCk7XG4gICAgXG4gICAgLy8g8J+aqUFJOiBERVRFUk1JTklTTV9IRUxQRVJTIOKAlCBmYWtlIHRpbWVycyBhbmQgc2VlZGVkIHJhbmRvbW5lc3Mgc2NhZmZvbGRpbmdcbiAgICBsaW5lcy5wdXNoKGAvLyBEZXRlcm1pbmlzdGljIHRlc3QgaGVscGVyc2ApO1xuICAgIGxpbmVzLnB1c2goYGJlZm9yZUVhY2goKCkgPT4ge2ApO1xuICAgIGxpbmVzLnB1c2goYCAgLy8gVXNlIGZha2UgdGltZXJzIGZvciBkZXRlcm1pbmlzdGljIHRpbWUtYmFzZWQgYmVoYXZpb3JgKTtcbiAgICBsaW5lcy5wdXNoKGAgIGplc3QudXNlRmFrZVRpbWVycygpLnNldFN5c3RlbVRpbWUobmV3IERhdGUoJzIwMjMtMDEtMDFUMDA6MDA6MDBaJykpO2ApO1xuICAgIGxpbmVzLnB1c2goYH0pO2ApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIGxpbmVzLnB1c2goYGFmdGVyRWFjaCgoKSA9PiB7YCk7XG4gICAgbGluZXMucHVzaChgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtgKTtcbiAgICBsaW5lcy5wdXNoKGB9KTtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgdGVzdCBzZXNzaW9uIGZvciBBUEkgaXNvbGF0aW9uXG4gICAgbGluZXMucHVzaChgLy8gRGV0ZXJtaW5pc3RpYyB1bmlxdWUgcm91dGUgZm9yIHBhcmFsbGVsIHRlc3Qgc2FmZXR5YCk7XG4gICAgbGluZXMucHVzaChgY29uc3QgdGVzdEhhc2ggPSByZXF1aXJlKCdjcnlwdG8nKS5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoJyR7cm91dGV9JykuZGlnZXN0KCdoZXgnKS5zbGljZSgwLCA4KTtgKTtcbiAgICBsaW5lcy5wdXNoKGBjb25zdCB1bmlxdWVSb3V0ZSA9ICcke3JvdXRlfScgKyAoJyR7cm91dGV9Jy5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nKSArICd0ZXN0SWQ9JyArIHRlc3RIYXNoO2ApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIFxuICAgIC8vIFR5cGVTY3JpcHQgdGVzdCBzdWl0ZVxuICAgIGxpbmVzLnB1c2goYGRlc2NyaWJlKCcke21ldGhvZC50b1VwcGVyQ2FzZSgpfSAke3JvdXRlfScsICgpID0+IHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgIGxldCBhcHA6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZU1vY2tBcHA+O2ApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIGxpbmVzLnB1c2goYCAgYmVmb3JlRWFjaCgoKSA9PiB7YCk7XG4gICAgbGluZXMucHVzaChgICAgIGFwcCA9IGNyZWF0ZU1vY2tBcHAoKTtgKTtcbiAgICBsaW5lcy5wdXNoKGAgIH0pO2ApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIFxuICAgIC8vIFN1Y2Nlc3MgdGVzdCBjYXNlXG4gICAgbGluZXMucHVzaChgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICAvLyBTZXR1cCByb3V0ZSBoYW5kbGVyYCk7XG4gICAgbGluZXMucHVzaChgICAgIGFwcC4ke21ldGhvZC50b0xvd2VyQ2FzZSgpfSh1bmlxdWVSb3V0ZSwgKHJlcSwgcmVzKSA9PiB7YCk7XG4gICAgbGluZXMucHVzaChgICAgICAgcmVzLnN0YXR1c0NvZGUgPSAyMDA7YCk7XG4gICAgbGluZXMucHVzaChgICAgICAgcmVzLnNldEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgICByZXMuZW5kKEpTT04uc3RyaW5naWZ5KHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgICAgIHN1Y2Nlc3M6IHRydWUsYCk7XG4gICAgbGluZXMucHVzaChgICAgICAgICBtZXNzYWdlOiAnUmVxdWVzdCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5J2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIH0pKTtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgfSk7YCk7XG4gICAgbGluZXMucHVzaChgYCk7XG4gICAgbGluZXMucHVzaChgICAgIC8vIEV4ZWN1dGUgdGVzdGApO1xuICAgIGxpbmVzLnB1c2goYCAgICBjb25zdCByZXMgPSBhd2FpdCBzdXBlcnRlc3QoYXBwKWApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIC4ke21ldGhvZC50b0xvd2VyQ2FzZSgpfSh1bmlxdWVSb3V0ZSlgKTtcbiAgICBpZiAobWV0aG9kLnRvTG93ZXJDYXNlKCkgIT09ICdnZXQnKSB7XG4gICAgICBsaW5lcy5wdXNoKGAgICAgICAuc2VuZCh7IHRlc3REYXRhOiAndmFsaWQgaW5wdXQnIH0pYCk7XG4gICAgfVxuICAgIGxpbmVzLnB1c2goYCAgICAgIC5leHBlY3QoMjAwKTtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgLy8gVmVyaWZ5IHJlc3BvbnNlYCk7XG4gICAgbGluZXMucHVzaChgICAgIGV4cGVjdChyZXMuYm9keS5zdWNjZXNzKS50b0JlKHRydWUpO2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICBleHBlY3QocmVzLmJvZHkubWVzc2FnZSkudG9CZSgnUmVxdWVzdCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5Jyk7YCk7XG4gICAgbGluZXMucHVzaChgICB9KTtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBcbiAgICAvLyBGYWlsdXJlIHRlc3QgY2FzZSAgXG4gICAgbGluZXMucHVzaChgICBpdCgnc2hvdWxkIGhhbmRsZSBub3QgZm91bmQgY2FzZScsIGFzeW5jICgpID0+IHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgLy8gRG9uJ3Qgc2V0dXAgYW55IHJvdXRlIGhhbmRsZXJzIHRvIHNpbXVsYXRlIDQwNGApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIGxpbmVzLnB1c2goYCAgICAvLyBFeGVjdXRlIHRlc3RgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgY29uc3QgcmVzID0gYXdhaXQgc3VwZXJ0ZXN0KGFwcClgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgICAuJHttZXRob2QudG9Mb3dlckNhc2UoKX0oJy9ub25leGlzdGVudC1yb3V0ZScpYCk7XG4gICAgaWYgKG1ldGhvZC50b0xvd2VyQ2FzZSgpICE9PSAnZ2V0Jykge1xuICAgICAgbGluZXMucHVzaChgICAgICAgLnNlbmQoeyB0ZXN0RGF0YTogJ2FueSBkYXRhJyB9KWApO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKGAgICAgICAuZXhwZWN0KDQwNCk7YCk7XG4gICAgbGluZXMucHVzaChgYCk7XG4gICAgbGluZXMucHVzaChgICAgIC8vIFZlcmlmeSBlcnJvciByZXNwb25zZWApO1xuICAgIGxpbmVzLnB1c2goYCAgICBleHBlY3QocmVzLmJvZHkuZXJyb3IpLnRvQmUoJ05vdCBGb3VuZCcpO2ApO1xuICAgIGxpbmVzLnB1c2goYCAgfSk7YCk7XG4gICAgbGluZXMucHVzaChgfSk7YCk7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gICAgXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVsbGlnZW50bHkgZXh0cmFjdCBleHBvcnRzIGZyb20gYm90aCBFUyBtb2R1bGVzIGFuZCBDb21tb25KU1xuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0RXhwb3J0cyhjb250ZW50OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZXhwb3J0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBjb21tZW50cyB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXNcbiAgICBjb25zdCBjbGVhbkNvbnRlbnQgPSBjb250ZW50XG4gICAgICAucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJykgLy8gUmVtb3ZlIC8qICovIGNvbW1lbnRzXG4gICAgICAucmVwbGFjZSgvXFwvXFwvLiokL2dtLCAnJyk7IC8vIFJlbW92ZSAvLyBjb21tZW50c1xuICAgIFxuICAgIC8vIEV4dHJhY3QgRVMgbW9kdWxlIGV4cG9ydHMgKGV4cG9ydCBjb25zdC9mdW5jdGlvbi9jbGFzcylcbiAgICBjb25zdCBlc0V4cG9ydHMgPSBbLi4uY2xlYW5Db250ZW50Lm1hdGNoQWxsKFBBVFRFUk5TLmV4cG9ydHNFUyldO1xuICAgIGVzRXhwb3J0cy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkgZXhwb3J0cy5hZGQobWF0Y2hbMV0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgRVMgbW9kdWxlIG5hbWVkIGV4cG9ydHM6IGV4cG9ydCB7IG5hbWUxLCBuYW1lMiwgbmFtZTMgfVxuICAgIGNvbnN0IG5hbWVkRXhwb3J0cyA9IFsuLi5jbGVhbkNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuZXhwb3J0c05hbWVkKV07XG4gICAgbmFtZWRFeHBvcnRzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBuYW1lZCBleHBvcnRzIGxpc3RcbiAgICAgICAgY29uc3QgZXhwb3J0TGlzdCA9IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKG5hbWUgPT4gbmFtZS50cmltKCkpO1xuICAgICAgICBleHBvcnRMaXN0LmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgLy8gSGFuZGxlIHBvdGVudGlhbCBhbGlhc2VzOiBcIm5hbWUgYXMgYWxpYXNcIiAtPiB1c2UgXCJuYW1lXCJcbiAgICAgICAgICBjb25zdCBjbGVhbk5hbWUgPSBuYW1lLnNwbGl0KCcgYXMgJylbMF0udHJpbSgpO1xuICAgICAgICAgIGlmIChjbGVhbk5hbWUgJiYgL15bYS16QS1aMC05X10rJC8udGVzdChjbGVhbk5hbWUpKSB7XG4gICAgICAgICAgICBleHBvcnRzLmFkZChjbGVhbk5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCBFUyBtb2R1bGUgZGVmYXVsdCBleHBvcnRzOiBleHBvcnQgZGVmYXVsdCBTb21lTmFtZVxuICAgIGNvbnN0IGRlZmF1bHRFeHBvcnRzID0gWy4uLmNsZWFuQ29udGVudC5tYXRjaEFsbChQQVRURVJOUy5leHBvcnRzRGVmYXVsdCldO1xuICAgIGRlZmF1bHRFeHBvcnRzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKG1hdGNoWzFdKSBleHBvcnRzLmFkZChtYXRjaFsxXSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCBDb21tb25KUyBleHBvcnRzXG4gICAgY29uc3QgY29tbW9uSlNFeHBvcnRzID0gWy4uLmNsZWFuQ29udGVudC5tYXRjaEFsbChQQVRURVJOUy5leHBvcnRzQ29tbW9uSlMpXTtcbiAgICBjb21tb25KU0V4cG9ydHMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAvLyBtYXRjaFsxXSA9IG1vZHVsZS5leHBvcnRzLm5hbWUsIG1hdGNoWzJdID0gZXhwb3J0cy5uYW1lLCBtYXRjaFszXSA9IHNpbmdsZSBhc3NpZ25tZW50XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICAgICAgaWYgKG1hdGNoW2ldKSBleHBvcnRzLmFkZChtYXRjaFtpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIG1vZHVsZS5leHBvcnRzID0geyBuYW1lMSwgbmFtZTIsIC4uLiB9IHBhdHRlcm5cbiAgICBjb25zdCBvYmplY3RFeHBvcnRNYXRjaCA9IGNsZWFuQ29udGVudC5tYXRjaCgvbW9kdWxlXFwuZXhwb3J0c1xccyo9XFxzKlxceyhbXn1dKylcXH0vKTtcbiAgICBpZiAob2JqZWN0RXhwb3J0TWF0Y2gpIHtcbiAgICAgIGNvbnN0IG9iamVjdENvbnRlbnQgPSBvYmplY3RFeHBvcnRNYXRjaFsxXTtcbiAgICAgIGNvbnN0IHByb3BlcnR5TWF0Y2hlcyA9IG9iamVjdENvbnRlbnQubWF0Y2hBbGwoL1xcYihcXHcrKSg/Olxccyo6XFxzKlxcdyspP1xccypbLH1dL2cpO1xuICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBwcm9wZXJ0eU1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoWzFdKSBleHBvcnRzLmFkZChtYXRjaFsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBBcnJheS5mcm9tKGV4cG9ydHMpLmZpbHRlcihuYW1lID0+IG5hbWUgJiYgbmFtZS5sZW5ndGggPiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmFseXplIGEgc2luZ2xlIGZpbGUgYW5kIGdlbmVyYXRlIGFwcHJvcHJpYXRlIHRlc3RzIC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVxuICAgKi9cbiAgYXN5bmMgYW5hbHl6ZShmaWxlOiBzdHJpbmcsIGRyeVJ1bjogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKGZpbGUpO1xuICAgIGlmICghdGhpcy5jb25maWcuVkFMSURfRVhUUy5pbmNsdWRlcyhleHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgIGNvbnN0IHVzZXNRdGVzdHMgPSBQQVRURVJOUy5xdGVzdHMudGVzdChjb250ZW50KTtcbiAgICBjb25zdCBpbXBvcnRzID0gdGhpcy5nZXRVc2VkTW9kdWxlcyhjb250ZW50KTtcbiAgICBjb25zdCBtb2NrVGFyZ2V0cyA9IGltcG9ydHMuZmlsdGVyKGkgPT4gXG4gICAgICB0aGlzLmNvbmZpZy5LTk9XTl9NT0NLUy5pbmNsdWRlcyhpKSAmJiBpICE9PSAncXRlc3RzJ1xuICAgICk7XG5cbiAgICAvLyBVc2UgaW50ZWxsaWdlbnQgZXhwb3J0IGRldGVjdGlvbiBmb3IgYm90aCBFUyBtb2R1bGVzIGFuZCBDb21tb25KU1xuICAgIGxldCBleHBvcnRzID0gdGhpcy5leHRyYWN0RXhwb3J0cyhjb250ZW50KTtcbiAgICAvLyBJZiBBU1QgbW9kZSByZXF1ZXN0ZWQsIGF0dGVtcHQgdG8gYXVnbWVudCBleHBvcnRzIHZpYSBUeXBlU2NyaXB0IHBhcnNlclxuICAgIGlmICh0aGlzLmNvbmZpZy5tb2RlID09PSAnYXN0Jykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXN0SW5mbyA9IGF3YWl0IHRoaXMudHJ5VHlwZVNjcmlwdEFuYWx5c2lzKGZpbGUsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoYXN0SW5mbyAmJiBBcnJheS5pc0FycmF5KGFzdEluZm8uZnVuY3Rpb25zKSkge1xuICAgICAgICAgIGNvbnN0IGFzdEV4cG9ydHMgPSBhc3RJbmZvLmZ1bmN0aW9ucy5tYXAoZm4gPT4gZm4ubmFtZSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICAgIGV4cG9ydHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLihleHBvcnRzIHx8IFtdKSwgLi4uYXN0RXhwb3J0c10pKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIFN3YWxsb3cgQVNUIGVycm9ycyBhbmQgcHJvY2VlZCB3aXRoIGhldXJpc3RpY1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPiAwICYmICghdGhpcy5jb25maWcuaW50ZWdyYXRpb24pKSB7XG4gICAgICBjb25zdCB0ZXN0UGF0aCA9IHRoaXMuZ2V0UmVsYXRpdmVUZXN0UGF0aChmaWxlLCAndW5pdCcsIGNvbnRlbnQpO1xuICAgICAgY29uc3QgY3JlYXRlZCA9IHRoaXMud3JpdGVJZk1pc3NpbmcoXG4gICAgICAgIHRlc3RQYXRoLCBcbiAgICAgICAgdGhpcy5jcmVhdGVVbml0VGVzdChmaWxlLCBleHBvcnRzLCB1c2VzUXRlc3RzLCBtb2NrVGFyZ2V0cywgY29udGVudCksXG4gICAgICAgIGRyeVJ1blxuICAgICAgKTtcbiAgICAgIGlmIChjcmVhdGVkKSB7XG4gICAgICAgIHRoaXMuc2Nhbm5lZC5wdXNoKHsgXG4gICAgICAgICAgdHlwZTogJ3VuaXQnLCBcbiAgICAgICAgICBmaWxlOiBwYXRoLnJlbGF0aXZlKCcuJywgdGVzdFBhdGgpIFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBBUEkgdGVzdHMgZm9yIGRldGVjdGVkIHJvdXRlcyAtIFR5cGVTY3JpcHQgb25seVxuICAgIGNvbnN0IGFwaXMgPSBbLi4uY29udGVudC5tYXRjaEFsbChQQVRURVJOUy5hcGkpXTtcbiAgICBpZiAoYXBpcy5sZW5ndGggPiAwICYmICghdGhpcy5jb25maWcudW5pdCkpIHtcbiAgICAgIGZvciAoY29uc3QgWywgLCBtZXRob2QsIHJvdXRlXSBvZiBhcGlzKSB7XG4gICAgICAgIGNvbnN0IHRlc3RQYXRoID0gdGhpcy5nZXRSZWxhdGl2ZVRlc3RQYXRoKGZpbGUsICdhcGknLCBjb250ZW50KVxuICAgICAgICAgIC5yZXBsYWNlKC9cXC5HZW5lcmF0ZVRlc3RcXC50ZXN0XFwuKHRzfHRzeCkkLywgYC5HZW5lcmF0ZVRlc3RfXyR7bWV0aG9kLnRvTG93ZXJDYXNlKCl9LnRlc3QuJDFgKTtcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9IHRoaXMud3JpdGVJZk1pc3NpbmcoXG4gICAgICAgICAgdGVzdFBhdGgsIFxuICAgICAgICAgIHRoaXMuY3JlYXRlQXBpVGVzdChtZXRob2QsIHJvdXRlKSxcbiAgICAgICAgICBkcnlSdW5cbiAgICAgICAgKTtcbiAgICAgICAgLy8gSWYgYW4gQVBJIHRlc3Qgd2FzIGNyZWF0ZWQsIGVuc3VyZSBsb2NhbCBodHRwVGVzdCB1dGlsaXRpZXMgZXhpc3QgKGlkZW1wb3RlbnQpXG4gICAgICAgIGlmIChjcmVhdGVkICYmICFkcnlSdW4pIHtcbiAgICAgICAgICB0aGlzLmVuc3VyZUxvY2FsSHR0cFRlc3RVdGlscygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjcmVhdGVkKSB7XG4gICAgICAgICAgdGhpcy5zY2FubmVkLnB1c2goeyBcbiAgICAgICAgICAgIHR5cGU6ICdhcGknLCBcbiAgICAgICAgICAgIGZpbGU6IHBhdGgucmVsYXRpdmUoJy4nLCB0ZXN0UGF0aCkgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIHByb2plY3QgdXNlcyBSZWFjdCBiYXNlZCBvbiBkZXBlbmRlbmNpZXMgYW5kIHNvdXJjZSBmaWxlc1xuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RSZWFjdFByb2plY3QoKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEhvbm9yIGZvcmNlZCBSZWFjdCBtb2RlIGlmIHByb3ZpZGVkIHZpYSBDTElcbiAgICAgIGlmICgodGhpcy5jb25maWcgYXMgYW55KS5yZWFjdCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBDaGVjayBwYWNrYWdlLmpzb24gZm9yIFJlYWN0IGRlcGVuZGVuY2llc1xuICAgICAgY29uc3QgcGFja2FnZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3BhY2thZ2UuanNvbicpO1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGFja2FnZVBhdGgpKSB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGFja2FnZVBhdGgsICd1dGY4JykpO1xuICAgICAgICBjb25zdCBhbGxEZXBzID0ge1xuICAgICAgICAgIC4uLnBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyxcbiAgICAgICAgICAuLi5wYWNrYWdlSnNvbi5kZXZEZXBlbmRlbmNpZXMsXG4gICAgICAgICAgLi4ucGFja2FnZUpzb24ucGVlckRlcGVuZGVuY2llc1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVhY3REZXBzID0gWydyZWFjdCcsICdAdHlwZXMvcmVhY3QnLCAncmVhY3QtZG9tJywgJ0B0eXBlcy9yZWFjdC1kb20nLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnLCAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5J107XG4gICAgICAgIGlmIChyZWFjdERlcHMuc29tZShkZXAgPT4gYWxsRGVwc1tkZXBdKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNjYW4gZm9yIC50c3ggZmlsZXMgb3IgUmVhY3QgaW1wb3J0cyBpbiBzb3VyY2UgY29kZVxuICAgICAgY29uc3QgYWxsRmlsZXMgPSB0aGlzLndhbGtQcm9qZWN0KCk7XG4gICAgICByZXR1cm4gYWxsRmlsZXMuc29tZShmaWxlID0+IHtcbiAgICAgICAgaWYgKGZpbGUuZW5kc1dpdGgoJy50c3gnKSB8fCBmaWxlLmVuZHNXaXRoKCcuanN4JykpIHJldHVybiB0cnVlO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsICd1dGY4Jyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0UmVhY3RVc2FnZShmaWxlLCBjb250ZW50KTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIEplc3QgY29uZmlndXJhdGlvbiBhbmQgc2V0dXAgZmlsZXMgLSBSZWFjdC1hd2FyZSBUeXBlU2NyaXB0IEVTIE1vZHVsZVxuICAgKi9cbiAgc2NhZmZvbGRKZXN0U2V0dXAoKTogdm9pZCB7XG4gICAgY29uc3QgaXNSZWFjdFByb2plY3QgPSB0aGlzLmRldGVjdFJlYWN0UHJvamVjdCgpO1xuICAgIC8vIEdlbmVyYXRlIEplc3QgY29uZmlnIGZvciBUeXBlU2NyaXB0IEVTIG1vZHVsZXMgd2l0aCBSZWFjdCBzdXBwb3J0XG4gICAgY29uc3QgZXh0ZW5zaW9uc1RvVHJlYXRBc0VzbSA9IGlzUmVhY3RQcm9qZWN0ID8gWycudHMnLCAnLnRzeCddIDogWycudHMnXTtcbiAgICBjb25zdCBtb2R1bGVGaWxlRXh0ZW5zaW9ucyA9IGlzUmVhY3RQcm9qZWN0ID8gWyd0cycsICd0c3gnLCAnanMnLCAnanN4JywgJ2pzb24nXSA6IFsndHMnLCAnanMnLCAnanNvbiddO1xuICAgIGNvbnN0IHRlc3RFbnZpcm9ubWVudCA9IGlzUmVhY3RQcm9qZWN0ID8gJ2pzZG9tJyA6ICdub2RlJztcbiAgICBjb25zdCB0ZXN0TWF0Y2hQYXR0ZXJucyA9IGlzUmVhY3RQcm9qZWN0IFxuICAgICAgPyBbXG4gICAgICAgICAgJyoqLyoudGVzdC50cycsXG4gICAgICAgICAgJyoqLyoudGVzdC50c3gnLFxuICAgICAgICAgICcqKi8qLkdlbmVyYXRlVGVzdC50ZXN0LnRzJyxcbiAgICAgICAgICAnKiovKi5HZW5lcmF0ZVRlc3QudGVzdC50c3gnLFxuICAgICAgICAgICcqKi9tYW51YWwtdGVzdHMvKiovKi50ZXN0LnRzJyxcbiAgICAgICAgICAnKiovZ2VuZXJhdGVkLXRlc3RzLyoqLyoudGVzdC50cydcbiAgICAgICAgXVxuICAgICAgOiBbXG4gICAgICAgICAgJyoqLyoudGVzdC50cycsXG4gICAgICAgICAgJyoqLyouR2VuZXJhdGVUZXN0LnRlc3QudHMnLFxuICAgICAgICAgICcqKi9tYW51YWwtdGVzdHMvKiovKi50ZXN0LnRzJyxcbiAgICAgICAgICAnKiovZ2VuZXJhdGVkLXRlc3RzLyoqLyoudGVzdC50cydcbiAgICAgICAgXTtcbiAgICBcbiAgICBjb25zdCB0cmFuc2Zvcm1Db25maWcgPSBpc1JlYWN0UHJvamVjdCBcbiAgICAgID8ge1xuICAgICAgICAgICdeLitcXFxcLnRzeD8kJzogWyd0cy1qZXN0Jywge1xuICAgICAgICAgICAgdXNlRVNNOiB0cnVlLFxuICAgICAgICAgICAgaXNvbGF0ZWRNb2R1bGVzOiB0cnVlLFxuICAgICAgICAgICAgdHNjb25maWc6IHtcbiAgICAgICAgICAgICAganN4OiAncmVhY3QtanN4J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICAgIDoge1xuICAgICAgICAgICdeLitcXFxcLnRzeD8kJzogWyd0cy1qZXN0Jywge1xuICAgICAgICAgICAgdXNlRVNNOiB0cnVlLFxuICAgICAgICAgICAgaXNvbGF0ZWRNb2R1bGVzOiB0cnVlXG4gICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICBcbiAgICBjb25zdCBjb25maWcgPSBgXG4vLyBqZXN0LmNvbmZpZy5qcyAtIFR5cGVTY3JpcHQgRVMgTW9kdWxlIGNvbmZpZ3VyYXRpb24ke2lzUmVhY3RQcm9qZWN0ID8gJyAoUmVhY3QtZW5hYmxlZCknIDogJyd9XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByZXNldDogJ3RzLWplc3QvcHJlc2V0cy9kZWZhdWx0LWVzbScsXG4gIGV4dGVuc2lvbnNUb1RyZWF0QXNFc206ICR7SlNPTi5zdHJpbmdpZnkoZXh0ZW5zaW9uc1RvVHJlYXRBc0VzbSl9LFxuICB0ZXN0RW52aXJvbm1lbnQ6ICcke3Rlc3RFbnZpcm9ubWVudH0nLFxuICBzZXR1cEZpbGVzQWZ0ZXJFbnY6IFsnPHJvb3REaXI+L2plc3Qtc2V0dXAudHMnXSxcbiAgbW9kdWxlRmlsZUV4dGVuc2lvbnM6ICR7SlNPTi5zdHJpbmdpZnkobW9kdWxlRmlsZUV4dGVuc2lvbnMpfSxcbiAgcm9vdHM6IFsnPHJvb3REaXI+J10sXG4gIHRlc3RNYXRjaDogJHtKU09OLnN0cmluZ2lmeSh0ZXN0TWF0Y2hQYXR0ZXJucywgbnVsbCwgNCkucmVwbGFjZSgvXFxuL2csICdcXG4gICcpfSxcbiAgdHJhbnNmb3JtOiAke0pTT04uc3RyaW5naWZ5KHRyYW5zZm9ybUNvbmZpZywgbnVsbCwgNCkucmVwbGFjZSgvXFxuL2csICdcXG4gICcpfSxcbiAgdHJhbnNmb3JtSWdub3JlUGF0dGVybnM6IFtcbiAgICAnbm9kZV9tb2R1bGVzLyg/ISg/OkB0YW5zdGFja3xAcmFkaXgtdWl8bHVjaWRlLXJlYWN0fHJlYWN0LXJlc2l6YWJsZS1wYW5lbHN8Y21ka3x2YXVsKS8pJ1xuICBdLFxuICBtb2R1bGVOYW1lTWFwcGVyOiB7XG4gICAgJ14oXFxcXC57MSwyfS8uKilcXFxcLmpzJCc6ICckMScsXG4gICAgJ15xdGVzdHMvKC4qKSQnOiAnPHJvb3REaXI+L25vZGVfbW9kdWxlcy9xdGVzdHMvJDEnXG4gIH0ke2lzUmVhY3RQcm9qZWN0ID8gJyxcXG4gIC8vIFJlYWN0IFRlc3RpbmcgTGlicmFyeSBjb25maWd1cmF0aW9uXFxuICB0ZXN0RW52aXJvbm1lbnQ6IFxcJ2pzZG9tXFwnLFxcbiAgc2V0dXBGaWxlc0FmdGVyRW52OiBbXFwnPHJvb3REaXI+L2plc3Qtc2V0dXAudHNcXCddJyA6ICcnfVxufTtcbmAudHJpbSgpO1xuXG4gICAgLy8gR2VuZXJhdGUgVHlwZVNjcmlwdCBFUyBtb2R1bGUgc2V0dXAgd2l0aCBSZWFjdCBzdXBwb3J0XG4gICAgY29uc3QgZG9tUG9seWZpbGxzID0gaXNSZWFjdFByb2plY3QgPyBgXG5cbi8vIERPTSBwb2x5ZmlsbHMgZm9yIFJlYWN0IFRlc3RpbmcgTGlicmFyeVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ21hdGNoTWVkaWEnLCB7XG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihxdWVyeSA9PiAoe1xuICAgIG1hdGNoZXM6IGZhbHNlLFxuICAgIG1lZGlhOiBxdWVyeSxcbiAgICBvbmNoYW5nZTogbnVsbCxcbiAgICBhZGRMaXN0ZW5lcjogamVzdC5mbigpLCAvLyBEZXByZWNhdGVkXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGplc3QuZm4oKSwgLy8gRGVwcmVjYXRlZFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgZGlzcGF0Y2hFdmVudDogamVzdC5mbigpLFxuICB9KSksXG59KTtcblxuLy8gUmVzaXplT2JzZXJ2ZXIgcG9seWZpbGxcbmdsb2JhbC5SZXNpemVPYnNlcnZlciA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgb2JzZXJ2ZTogamVzdC5mbigpLFxuICB1bm9ic2VydmU6IGplc3QuZm4oKSxcbiAgZGlzY29ubmVjdDogamVzdC5mbigpLFxufSkpO1xuXG4vLyBJbnRlcnNlY3Rpb25PYnNlcnZlciBwb2x5ZmlsbFxuZ2xvYmFsLkludGVyc2VjdGlvbk9ic2VydmVyID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICBvYnNlcnZlOiBqZXN0LmZuKCksXG4gIHVub2JzZXJ2ZTogamVzdC5mbigpLFxuICBkaXNjb25uZWN0OiBqZXN0LmZuKCksXG59KSk7YCA6ICcnO1xuICAgIFxuICAgIGNvbnN0IHNldHVwID0gYFxuLy8gamVzdC1zZXR1cC50cyAtIEplc3Qgc2V0dXAgZm9yIFR5cGVTY3JpcHQgRVNNJHtpc1JlYWN0UHJvamVjdCA/ICcgd2l0aCBSZWFjdCBzdXBwb3J0JyA6ICcnfVxuLy8gS2VlcCBxdGVzdHMgc2V0dXAgRklSU1QgdG8gZW5zdXJlIGdsb2JhbCBzdHViYmluZyBpcyBhY3RpdmVcbmltcG9ydCAncXRlc3RzL3NldHVwJztcbmltcG9ydCAnamVzdCc7JHtpc1JlYWN0UHJvamVjdCA/IFwiXFxuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2plc3QtZG9tJztcIiA6ICcnfVxuXG4vLyBTZXQgdGVzdCBlbnZpcm9ubWVudCBlYXJseVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAndGVzdCc7XG5cbmJlZm9yZUFsbCgoKSA9PiB7XG4gIGplc3Quc2V0VGltZW91dCgxMDAwMCk7XG59KTtcblxuYWZ0ZXJFYWNoKCgpID0+IHtcbiAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG59KTske2RvbVBvbHlmaWxsc31cbmAudHJpbSgpO1xuXG4gICAgdGhpcy53cml0ZUlmTWlzc2luZygnamVzdC5jb25maWcuanMnLCBjb25maWcpO1xuICAgIHRoaXMud3JpdGVJZk1pc3NpbmcoJ2plc3Qtc2V0dXAudHMnLCBzZXR1cCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgcXRlc3RzIHRlc3QgcnVubmVyIGZpbGUgLSBUeXBlU2NyaXB0IEVTIG1vZHVsZSBjb21wYXRpYmxlXG4gICAqL1xuICBnZW5lcmF0ZVF0ZXN0c1J1bm5lcigpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgLy8gUmVhZCB0aGUgZXhpc3RpbmcgcXRlc3RzLXRzLXJ1bm5lci50cyBhcyB0ZW1wbGF0ZVxuICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGdldE1vZHVsZURpcm5hbWVGb3JUZXN0R2VuZXJhdG9yKCksICcuLicsICdxdGVzdHMtdHMtcnVubmVyLnRzJyk7XG4gICAgICBsZXQgdGVtcGxhdGUgPSAnJztcbiAgICAgIFxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmModGVtcGxhdGVQYXRoKSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IGZzLnJlYWRGaWxlU3luYyh0ZW1wbGF0ZVBhdGgsICd1dGY4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayB0ZW1wbGF0ZSBmb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGVzIHdpdGggY29ycmVjdCBKZXN0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgdGVtcGxhdGUgPSBgXG4vLyBHZW5lcmF0ZWQgcXRlc3RzIHJ1bm5lciAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIGNvbXBhdGlibGVcbmltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuLy8gUnVuIHRlc3RzIHdpdGggVHlwZVNjcmlwdCBzdXBwb3J0IGFuZCBjb3JyZWN0IEplc3QgYXJndW1lbnRzXG5jb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuY29uc3QgdGVzdFByb2Nlc3MgPSBzcGF3bignamVzdCcsIGFyZ3MsIHtcbiAgc3RkaW86ICdpbmhlcml0JyxcbiAgc2hlbGw6IHRydWVcbn0pO1xuXG50ZXN0UHJvY2Vzcy5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gIHByb2Nlc3MuZXhpdChjb2RlIHx8IDApO1xufSk7XG5gLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWx3YXlzIG92ZXJ3cml0ZSBxdGVzdHMtdHMtcnVubmVyLnRzIHRvIGVuc3VyZSBsYXRlc3QgZnVuY3Rpb25hbGl0eSBhbmQgVHlwZVNjcmlwdCBjb21wbGlhbmNlXG4gICAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdxdGVzdHMtdHMtcnVubmVyLnRzJyk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIHRlbXBsYXRlLCAndXRmOCcpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEdlbmVyYXRlZCBxdGVzdHMtdHMtcnVubmVyLnRzIGZvciBUeXBlU2NyaXB0IEVTIG1vZHVsZXMnKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgcXRlc3RzLXRzLXJ1bm5lci50czonLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHBhY2thZ2UuanNvbiB0ZXN0IHNjcmlwdCB0byB1c2UgcXRlc3RzLXRzLXJ1bm5lci50c1xuICAgKi9cbiAgdXBkYXRlUGFja2FnZUpzb25UZXN0U2NyaXB0KCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncGFja2FnZS5qc29uJyk7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGFja2FnZVBhdGgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIHBhY2thZ2UuanNvbiBub3QgZm91bmQsIHNraXBwaW5nIHRlc3Qgc2NyaXB0IHVwZGF0ZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGFja2FnZVBhdGgsICd1dGY4JykpO1xuICAgICAgXG4gICAgICBpZiAoIXBhY2thZ2VKc29uLnNjcmlwdHMpIHtcbiAgICAgICAgcGFja2FnZUpzb24uc2NyaXB0cyA9IHt9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBwYWNrYWdlSnNvbi5zY3JpcHRzLnRlc3QgPSAnbnB4IHRzeCBxdGVzdHMtdHMtcnVubmVyLnRzJztcbiAgICAgIFxuICAgICAgZnMud3JpdGVGaWxlU3luYyhwYWNrYWdlUGF0aCwgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb24sIG51bGwsIDIpLCAndXRmOCcpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBVcGRhdGVkIHBhY2thZ2UuanNvbiB0ZXN0IHNjcmlwdCB0byB1c2UgcXRlc3RzLXRzLXJ1bm5lci50cycpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gIENvdWxkIG5vdCB1cGRhdGUgcGFja2FnZS5qc29uOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FuIGZvciBmaWxlcyB3aXRob3V0IHRlc3RzIGFuZCBnZW5lcmF0ZSB0aGVtIC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUZXN0RmlsZXMoZHJ5UnVuOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBTY2FubmluZyBmb3IgZmlsZXMgdGhhdCBuZWVkIFR5cGVTY3JpcHQgdGVzdHMuLi4nKTtcbiAgICBcbiAgICBjb25zdCBhbGxGaWxlcyA9IHRoaXMud2Fsa1Byb2plY3QoKTtcbiAgICBjb25zdCB7IHNvdXJjZUZpbGVzIH0gPSB0aGlzLmNhdGVnb3JpemVGaWxlcyhhbGxGaWxlcyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk4EgRm91bmQgJHtzb3VyY2VGaWxlcy5sZW5ndGh9IHNvdXJjZSBmaWxlcyB3aXRob3V0IHRlc3RzYCk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdGVzdHMgZm9yIGVhY2ggc291cmNlIGZpbGVcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2Ygc291cmNlRmlsZXMpIHtcbiAgICAgIGF3YWl0IHRoaXMuYW5hbHl6ZShmaWxlLCBkcnlSdW4pO1xuICAgIH1cblxuICAgIC8vIE9uIG5vbi1kcnkgcnVucywgYWx3YXlzIHNjYWZmb2xkIEplc3QgYW5kIHJ1bm5lciBldmVuIGlmIHRoZXJlIHdlcmUgbm8gbmV3IGZpbGVzXG4gICAgaWYgKCFkcnlSdW4pIHtcbiAgICAgIHRoaXMuc2NhZmZvbGRKZXN0U2V0dXAoKTtcbiAgICAgIHRoaXMuZ2VuZXJhdGVRdGVzdHNSdW5uZXIoKTtcbiAgICAgIC8vIE9ubHkgdXBkYXRlIHBhY2thZ2UuanNvbiBpZiByZXF1ZXN0ZWQgdmlhIENMSSBmbGFnXG4gICAgICBpZiAoKHRoaXMuY29uZmlnIGFzIGFueSkudXBkYXRlUGFja2FnZVNjcmlwdCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhY2thZ2VKc29uVGVzdFNjcmlwdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygn4oS577iPIERyeSBydW46IFNraXBwaW5nIEplc3QgY29uZmlnIGFuZCBydW5uZXIgZ2VuZXJhdGlvbicpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBHZW5lcmF0ZWQgJHt0aGlzLnNjYW5uZWQubGVuZ3RofSBUeXBlU2NyaXB0IHRlc3QgZmlsZXM6YCk7XG4gICAgdGhpcy5zY2FubmVkLmZvckVhY2godGVzdCA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgICAgJHt0ZXN0LnR5cGV9OiAke3Rlc3QuZmlsZX1gKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc2NhbiByZXN1bHRzXG4gICAqL1xuICBnZXRSZXN1bHRzKCk6IFNjYW5uZWRUZXN0W10ge1xuICAgIHJldHVybiB0aGlzLnNjYW5uZWQ7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBUZXN0R2VuZXJhdG9yIGNsYXNzIHVzaW5nIEVTIG1vZHVsZSBzeW50YXhcbmV4cG9ydCB7IFRlc3RHZW5lcmF0b3IgfTtcbmV4cG9ydCBkZWZhdWx0IFRlc3RHZW5lcmF0b3I7XG4iXSwidmVyc2lvbiI6M30=