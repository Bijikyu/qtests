5ebe121ad521232cc18cdb121cca2cf5
"use strict";
/**
 * Test Generator for qtests Framework - TypeScript Implementation
 *
 * Automatically generates unit tests and API tests by scanning source code.
 * Analyzes JavaScript/TypeScript files to detect exports, imports, and API routes,
 * then creates appropriate test files with proper structure and mocking.
 *
 * Features:
 * - Unit test generation for exported functions/classes
 * - API test generation for Express routes
 * - Automatic mock setup for known libraries
 * - Jest configuration scaffolding
 * - Support for qtests framework integration
 * - TypeScript ES module only (no version duplication)
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestGenerator = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const esm_globals_js_1 = require("../utils/esm-globals.js");
// ES Module __dirname equivalent - lazy initialization to avoid Jest issues
let moduleDirname;
function getModuleDirnameForTestGenerator() {
    if (moduleDirname === undefined) {
        // Use a try-catch to handle Jest environment gracefully
        try {
            // Use eval to hide import.meta from Jest's static parser
            const importMetaUrl = (0, eval)('import.meta.url');
            moduleDirname = (0, esm_globals_js_1.getModuleDirname)(importMetaUrl);
        }
        catch (error) {
            // Fallback for Jest environment
            moduleDirname = process.cwd();
        }
    }
    return moduleDirname;
}
// Configuration constants - TypeScript ES module only
const DEFAULT_CONFIG = {
    SRC_DIR: '.',
    TEST_DIR: 'generated-tests',
    KNOWN_MOCKS: ['axios', 'node-fetch', 'pg', 'mongoose', 'fs', 'redis'],
    VALID_EXTS: ['.ts', '.js', '.tsx', '.jsx']
};
// Regex patterns for code analysis - Enhanced for both ES modules and CommonJS
const PATTERNS = {
    qtests: /from ['"]qtests['"]|require\(['"]qtests['"]\)/,
    api: /\b(app|router)\.(get|post|put|delete|patch)\s*\(\s*['"`]([^'"`]+)['"`]/gi,
    // ES module exports: export const, export function, export class
    exportsES: /^\s*export\s+(?:const|function|class)\s+([a-zA-Z0-9_]+)/gm,
    // ES module named exports: export { name1, name2, name3 }
    exportsNamed: /export\s*\{\s*([^}]+)\s*\}/g,
    // ES module default exports: export default SomeName
    exportsDefault: /export\s+default\s+([a-zA-Z0-9_]+)/g,
    // CommonJS exports: module.exports = {}, module.exports.name =, exports.name =
    exportsCommonJS: /(?:module\.exports\.([a-zA-Z0-9_]+)\s*=|exports\.([a-zA-Z0-9_]+)\s*=|module\.exports\s*=\s*([a-zA-Z0-9_]+))/gm,
    // Function declarations that might be exported
    functionDeclarations: /^\s*(?:async\s+)?function\s+([a-zA-Z0-9_]+)\s*\(/gm,
    // Class declarations that might be exported
    classDeclarations: /^\s*class\s+([a-zA-Z0-9_]+)/gm,
    imports: /from ['"]([^'"]+)['"]|require\(['"]([^'"]+)['"]\)/g
};
class TestGenerator {
    constructor(options = {}) {
        // Precompiled include/exclude regexes for fast filtering
        this.includeRegexes = [];
        this.excludeRegexes = [];
        this.config = { ...DEFAULT_CONFIG, ...options };
        this.scanned = [];
        this.isESModule = this.detectESModule(); // Detect module type once during initialization
        // Compile include/exclude glob patterns to regex for matching
        this.includeRegexes = (this.config.include || []).map(this.globToRegExp);
        this.excludeRegexes = (this.config.exclude || []).map(this.globToRegExp);
    }
    /**
     * Detect if the current project uses ES modules or CommonJS
     * Since we're now "TypeScript ES module only", this defaults to true for TypeScript projects
     */
    detectESModule() {
        try {
            // Check package.json for explicit "type": "module"
            const packagePath = path_1.default.resolve(process.cwd(), 'package.json');
            if (fs_1.default.existsSync(packagePath)) {
                const packageJson = JSON.parse(fs_1.default.readFileSync(packagePath, 'utf8'));
                if (packageJson.type === 'module') {
                    return true;
                }
                // For TypeScript ES module only approach, prefer ES modules when TypeScript is detected
                if (packageJson.devDependencies?.typescript || packageJson.dependencies?.typescript) {
                    return true;
                }
            }
            // Check for ES module patterns in source files (excluding test files and node_modules)
            const sourceFiles = this.walkProject()
                .filter(file => {
                const ext = path_1.default.extname(file);
                const isValidExt = this.config.VALID_EXTS.includes(ext);
                const isTestFile = this.isTestFile(path_1.default.basename(file));
                const isNodeModules = file.includes('node_modules');
                return isValidExt && !isTestFile && !isNodeModules;
            })
                .slice(0, 10); // Sample first 10 files for performance
            let esModuleCount = 0;
            let commonJSCount = 0;
            for (const file of sourceFiles) {
                try {
                    const content = fs_1.default.readFileSync(file, 'utf8');
                    // Look for ES module patterns (import OR export statements)
                    if (content.includes('import ') || content.includes('export ')) {
                        esModuleCount++;
                    }
                    // Look for CommonJS patterns
                    if (content.includes('require(') || content.includes('module.exports')) {
                        commonJSCount++;
                    }
                }
                catch (error) {
                    // Skip files we can't read
                    continue;
                }
            }
            // For TypeScript ES module only approach, prefer ES modules when equal or when TypeScript files are present
            if (esModuleCount === 0 && commonJSCount === 0) {
                return true; // Default to ES modules for TypeScript ES module only approach
            }
            if (esModuleCount === 0) {
                return false; // No ES module patterns found, default to CommonJS
            }
            return esModuleCount >= commonJSCount; // Changed from > to >= to prefer ES modules
        }
        catch (error) {
            // Default to ES modules for TypeScript ES module only approach
            return true;
        }
    }
    /**
     * Check if directory should be skipped during discovery
     */
    shouldSkipDirectory(dirName) {
        const skipPatterns = [
            'node_modules', '.git', '.next', 'dist', 'build', 'coverage',
            '.vscode', '.idea', 'docs', 'documentation', 'assets', 'public', 'static',
            '.replit_cache', '.config', '.npm', 'logs',
            'examples', 'demo', 'demos', 'samples', 'bin',
            // Skip common test and generated directories
            '__mocks__', '__tests__', 'tests', 'test', 'generated-tests',
            // Skip manual test directories and fixtures
            'manual-tests', 'fixtures', 'test-fixtures'
        ];
        return skipPatterns.includes(dirName) || dirName.startsWith('.');
    }
    /**
     * Walk entire project directory structure, respecting skip patterns
     */
    walkProject() {
        const root = this.config.SRC_DIR
            ? path_1.default.resolve(process.cwd(), this.config.SRC_DIR)
            : process.cwd();
        return this.walkRecursive(root);
    }
    /**
     * Recursively walk directory and return all file paths, skipping irrelevant directories
     */
    walkRecursive(dir) {
        if (!fs_1.default.existsSync(dir)) {
            return [];
        }
        return fs_1.default.readdirSync(dir, { withFileTypes: true }).flatMap(entry => {
            const full = path_1.default.resolve(dir, entry.name);
            if (entry.isDirectory()) {
                // Skip directories that shouldn't contain tests or source files
                if (this.shouldSkipDirectory(entry.name)) {
                    return [];
                }
                return this.walkRecursive(full);
            }
            else {
                return [full];
            }
        });
    }
    /**
     * Convert a glob pattern (supports *, **, ?) into a RegExp
     * - *  matches any sequence except path separator
     * - ** matches any sequence including path separators
     * - ?  matches a single character except path separator
     */
    globToRegExp(pattern) {
        // Normalize to posix style for matching
        let pat = pattern.replace(/\\/g, '/');
        // Escape regex special chars, except our glob tokens * ?
        pat = pat.replace(/([.+^${}()|\[\]\\])/g, '\\$1');
        // Convert ** to a special token first to avoid conflict with *
        pat = pat.replace(/\*\*/g, '::GLOBSTAR::');
        // Convert remaining * and ?
        pat = pat.replace(/\*/g, '[^/]*').replace(/\?/g, '[^/]');
        // Convert GLOBSTAR
        pat = pat.replace(/::GLOBSTAR::/g, '.*');
        // Anchor pattern
        pat = '^' + pat + '$';
        return new RegExp(pat);
    }
    /**
     * Check include/exclude patterns against a path (posix normalized)
     */
    pathMatchesFilters(filePath) {
        const posixPath = filePath.replace(/\\/g, '/');
        // Apply exclude first
        if (this.excludeRegexes.some(rx => rx.test(posixPath))) {
            return false;
        }
        // If includes provided, must match at least one include
        if (this.includeRegexes.length > 0) {
            return this.includeRegexes.some(rx => rx.test(posixPath));
        }
        return true; // No includes means include all (after excludes)
    }
    /**
     * Legacy walk method for backwards compatibility (walks single directory)
     */
    walk(dir) {
        if (!fs_1.default.existsSync(dir)) {
            return [];
        }
        return fs_1.default.readdirSync(dir, { withFileTypes: true }).flatMap(entry => {
            const full = path_1.default.resolve(dir, entry.name);
            return entry.isDirectory() ? this.walk(full) : [full];
        });
    }
    /**
     * Check if file should be skipped as a source file (config, setup, etc.)
     */
    shouldSkipSourceFile(file) {
        const basename = path_1.default.basename(file);
        const dirname = path_1.default.dirname(file);
        // Skip files in test-related directories
        if (dirname.includes('manual-tests') || dirname.includes('fixtures')) {
            return true;
        }
        const skipPatterns = [
            /^jest\.config\./, // Jest config files
            /^jest-setup\./, // Jest setup files
            /^setup\./, // Setup files
            /^config\./, // Config files  
            /-demo\./, // Demo files
            /-example\./, // Example files
            /\.config\./, // Any config files
            /^example\./, // Files named "example.*"
            /^demo\./, // Files named "demo.*"
            /qtests-runner\./, // Generated runner files
            /setupMultiple/, // Test setup helpers
            /reloadCheck/, // Test utilities
            /testSetup/, // Test setup files
        ];
        return skipPatterns.some(pattern => pattern.test(basename));
    }
    /**
     * Categorize discovered files into source files and existing tests
     */
    categorizeFiles(files) {
        const sourceFiles = [];
        const existingTests = [];
        files.forEach(file => {
            const ext = path_1.default.extname(file);
            const basename = path_1.default.basename(file);
            // Skip files with invalid extensions
            if (!this.config.VALID_EXTS.includes(ext)) {
                return;
            }
            // Apply CLI include/exclude filters against project-relative path
            const relFromCwd = path_1.default.relative(process.cwd(), file);
            if (!this.pathMatchesFilters(relFromCwd)) {
                return;
            }
            // Skip config, demo, and setup files
            if (this.shouldSkipSourceFile(file)) {
                return;
            }
            // Check if this is a test file
            if (this.isTestFile(basename)) {
                existingTests.push(file);
            }
            else {
                // Check if this source file already has a corresponding test
                const hasTest = this.hasCorrespondingTest(file, files);
                if (!hasTest) {
                    sourceFiles.push(file);
                }
            }
        });
        return { sourceFiles, existingTests };
    }
    /**
     * Check if filename indicates it's a test file
     */
    isTestFile(filename) {
        const testPatterns = [
            /\.test\./,
            /\.spec\./,
            /_test\./,
            /_spec\./,
            /\.e2e\./,
            /\.integration\./
        ];
        return testPatterns.some(pattern => pattern.test(filename));
    }
    /**
     * Check if a source file has a corresponding test file
     */
    hasCorrespondingTest(sourceFile, allFiles) {
        const dir = path_1.default.dirname(sourceFile);
        const basename = path_1.default.basename(sourceFile, path_1.default.extname(sourceFile));
        const ext = path_1.default.extname(sourceFile);
        // Common test file patterns to look for - TypeScript ES module only
        const testPatterns = [
            `${basename}.test.ts`,
            `${basename}.GenerateTest.test.ts`, // Updated generated unit test pattern  
            `${basename}GeneratedTest.test.ts`, // Legacy pattern for backwards compatibility
            `${basename}.spec.ts`,
            `${basename}_test.ts`,
            `${basename}_spec.ts`,
            `${basename}.test${ext}`,
            `${basename}.spec${ext}`
        ];
        // Look for test files in the same directory
        const sameDirectoryTests = testPatterns.map(pattern => path_1.default.join(dir, pattern));
        // Look for test files in common test directories
        const testDirectories = ['tests', 'test', '__tests__', 'spec'];
        const testDirectoryTests = testDirectories.flatMap(testDir => {
            const testPath = path_1.default.join(dir, testDir);
            return testPatterns.map(pattern => path_1.default.join(testPath, pattern));
        });
        // Check if any of these test files exist
        const allTestPaths = [...sameDirectoryTests, ...testDirectoryTests];
        // Normalize paths for comparison - convert both to absolute paths
        const normalizedAllFiles = allFiles.map(file => path_1.default.resolve(file));
        const normalizedTestPaths = allTestPaths.map(testPath => path_1.default.resolve(testPath));
        return normalizedTestPaths.some(testPath => normalizedAllFiles.includes(testPath));
    }
    /**
     * Detect if source file or content indicates React usage
     */
    detectReactUsage(file, content = '') {
        // Check file extension
        if (file.endsWith('.tsx') || file.endsWith('.jsx')) {
            return true;
        }
        // Check for React imports
        const reactImports = /import.*(?:react|React|@types\/react)/i.test(content);
        if (reactImports)
            return true;
        // Check for JSX patterns
        const jsxPatterns = [
            /<[A-Z][a-zA-Z0-9]*[\s\/>]/, // Component tags like <MyComponent
            /<[a-z]+[\s\/>]/, // HTML tags like <div>
            /React\.createElement/, // React.createElement calls
            /jsx.*:/, // JSX pragma
        ];
        return jsxPatterns.some(pattern => pattern.test(content));
    }
    /**
     * Detect if export name is likely a React hook
     */
    isReactHook(exportName) {
        return exportName.startsWith('use') && exportName.length > 3;
    }
    /**
     * Detect if export name is likely a React component
     */
    isReactComponent(exportName, content = '') {
        // Check if it starts with uppercase (component convention)
        if (!/^[A-Z]/.test(exportName))
            return false;
        // Check if it's defined as a function that might return JSX
        const componentPatterns = [
            new RegExp(`function\\s+${exportName}\\s*\\(`),
            new RegExp(`const\\s+${exportName}\\s*=\\s*\\(`),
            new RegExp(`export\\s+function\\s+${exportName}\\s*\\(`),
            new RegExp(`${exportName}\\s*=\\s*\\(.*\\)\\s*=>`) // Arrow function
        ];
        return componentPatterns.some(pattern => pattern.test(content));
    }
    /**
     * Heuristically detect if a React component likely requires props.
     * - TS inline prop types without ?: required (e.g., props: { id: string })
     * - Destructured props without defaults (e.g., function C({ id }: { id: string }))
     * - propTypes with isRequired
     */
    componentRequiresProps(exportName, content = '') {
        try {
            // 1) propTypes isRequired
            const propTypesReq = new RegExp(`${exportName}\.propTypes\s*=\s*\{[\s\S]*?isRequired`, 'm');
            if (propTypesReq.test(content))
                return true;
            // 2) TS inline type with required fields (no ?)
            const tsInline1 = new RegExp(`function\s+${exportName}\s*\(\s*props\s*:\s*\{([\n\r\t \w:<>\|\[\]\n\r,?]+)\}\s*\)`, 'm');
            const tsInline2 = new RegExp(`const\s+${exportName}\s*=\s*\(\s*props\s*:\s*\{([\n\r\t \w:<>\|\[\]\n\r,?]+)\}\s*\)`, 'm');
            const tsDestructured = new RegExp(`function\s+${exportName}\s*\(\s*\{([^}=]+)\}\s*:\s*\{([^}]+)\}\s*\)`, 'm');
            const tsArrowDestructured = new RegExp(`const\s+${exportName}\s*=\s*\(\s*\{([^}=]+)\}\s*:\s*\{([^}]+)\}\s*\)`, 'm');
            const matches = [tsInline1.exec(content), tsInline2.exec(content), tsDestructured.exec(content), tsArrowDestructured.exec(content)];
            for (const m of matches) {
                if (!m)
                    continue;
                const typeBlock = (m[1] || m[2] || '').trim();
                if (!typeBlock)
                    continue;
                // If any field lacks ?, assume required
                const fields = typeBlock.split(',');
                for (const f of fields) {
                    const field = f.trim();
                    if (!field)
                        continue;
                    // Example: id?: string vs id: string
                    if (/^[A-Za-z_$][\w$]*\s*:\s*[^?]/.test(field)) {
                        return true;
                    }
                }
            }
            // 3) Destructured props without default object for param (no = {})
            const destructuredNoDefaultFn = new RegExp(`function\s+${exportName}\s*\(\s*\{([^}]+)\}\s*\)`, 'm');
            const destructuredNoDefaultArrow = new RegExp(`const\s+${exportName}\s*=\s*\(\s*\{([^}]+)\}\s*\)`, 'm');
            if (destructuredNoDefaultFn.test(content) || destructuredNoDefaultArrow.test(content)) {
                // If the param includes = {}, it's optional; otherwise assume required
                const paramWithDefault = new RegExp(`${exportName}[^\n]*\(\s*\{[^}]+\}\s*=\s*\{\}\s*\)`);
                if (!paramWithDefault.test(content))
                    return true;
            }
            return false;
        }
        catch {
            return false;
        }
    }
    /**
     * Generate test file path based on source file and test type
     * React-aware: generates .tsx for React components/hooks, .ts otherwise
     */
    getRelativeTestPath(file, type = 'unit', content = '') {
        const dir = path_1.default.dirname(file);
        const basename = path_1.default.basename(file, path_1.default.extname(file));
        // Determine test file extension based on React usage
        const isReactFile = this.detectReactUsage(file, content);
        const testExt = isReactFile ? '.tsx' : '.ts';
        if (type === 'unit') {
            // For unit tests, place them alongside the source file with GeneratedTest naming
            return path_1.default.join(dir, `${basename}.GenerateTest.test${testExt}`);
        }
        else {
            // For API/integration tests, use the configured test directory with appropriate extension
            const rel = path_1.default.relative(process.cwd(), file);
            return path_1.default.join(this.config.TEST_DIR, rel.replace(/\.[tj]sx?$/, `.GenerateTest.test${testExt}`).replace(/[\\/]/g, '__'));
        }
    }
    /**
     * Create directory if it doesn't exist
     */
    createDir(p) {
        const dir = path_1.default.dirname(p);
        if (!fs_1.default.existsSync(dir)) {
            fs_1.default.mkdirSync(dir, { recursive: true });
        }
    }
    /**
     * Write file only if it doesn't already exist, unless force flag is set
     * Supports dry-run mode for previewing planned files
     */
    writeIfMissing(p, content, dryRun = false) {
        const exists = fs_1.default.existsSync(p);
        // Allow overwrite only for files generated by this tool (contain ".GenerateTest")
        const isGeneratedTest = p.includes('.GenerateTest');
        const canWrite = !exists || (Boolean(this.config.force) && isGeneratedTest);
        if (dryRun) {
            // In dry-run mode, just log what would be written
            console.log(`${exists ? '[WOULD OVERWRITE]' : '[WOULD CREATE]'} ${path_1.default.relative('.', p)}`);
            return canWrite;
        }
        if (canWrite) {
            this.createDir(p);
            fs_1.default.writeFileSync(p, content, 'utf8');
            return true;
        }
        return false;
    }
    /**
     * Extract imported modules from file content - Enhanced for both ES modules and CommonJS
     */
    getUsedModules(content) {
        return [...content.matchAll(PATTERNS.imports)]
            .map(m => m[1] || m[2]) // m[1] for ES modules, m[2] for CommonJS
            .filter(x => x && !x.startsWith('.') && !x.startsWith('/'));
    }
    /**
     * Ensure a local copy of API test utilities exists at generated-tests/utils/httpTest.ts
     * so that generated integration tests work without extra project wiring.
     * Idempotent: only writes if missing.
     */
    ensureLocalHttpTestUtils() {
        try {
            const targetDir = path_1.default.join(process.cwd(), this.config.TEST_DIR || 'generated-tests', 'utils');
            const targetFile = path_1.default.join(targetDir, 'httpTest.ts');
            if (fs_1.default.existsSync(targetFile))
                return;
            // Try to read the package's httpTest.ts to copy over
            const src = path_1.default.join(getModuleDirnameForTestGenerator(), '..', 'utils', 'httpTest.ts');
            let content = '';
            try {
                content = fs_1.default.readFileSync(src, 'utf8');
            }
            catch {
                // Minimal fallback shim if the source cannot be found
                content = [
                    `// Minimal httpTest shim for generated integration tests`,
                    `export { default as supertest } from 'supertest';`,
                    `export function createMockApp() { throw new Error('createMockApp not available in shim'); }`
                ].join('\n');
            }
            fs_1.default.mkdirSync(targetDir, { recursive: true });
            fs_1.default.writeFileSync(targetFile, content, 'utf8');
            console.log(`âœ… Scaffoled local API test utils at ${path_1.default.relative(process.cwd(), targetFile)}`);
        }
        catch (err) {
            console.warn('âš ï¸  Could not scaffold local httpTest utils:', err?.message || String(err));
        }
    }
    /**
     * Detect if code uses Date or Math.random for deterministic test helpers
     * ðŸš©AI: DETERMINISM_HELPERS â€” fake timers and seeded randomness scaffolding
     */
    detectNonDeterministicCode(content) {
        const usesDate = /new Date\(|Date\.now\(|\.getTime\(/.test(content);
        const usesRandom = /Math\.random\(/.test(content);
        return { usesDate, usesRandom };
    }
    /**
     * Optional TypeScript AST analysis for better type inference
     * ðŸš©AI: TYPE_INFERENCE_OPTION â€” dynamic import('typescript') with heuristics fallback
     */
    async tryTypeScriptAnalysis(file, content) {
        try {
            // Dynamic import of TypeScript - only if available
            const ts = await Promise.resolve().then(() => __importStar(require('typescript'))).catch(() => null);
            if (!ts) {
                return null;
            }
            // Parse the TypeScript source
            const sourceFile = ts.createSourceFile(file, content, ts.ScriptTarget.Latest, true);
            const functions = [];
            // Visitor function to extract function declarations with types
            const visit = (node) => {
                if (ts.isFunctionDeclaration(node) && node.name) {
                    const funcName = node.name.getText();
                    const params = node.parameters.map((param) => ({
                        name: param.name.getText(),
                        type: param.type ? param.type.getText() : 'any'
                    }));
                    functions.push({ name: funcName, params });
                }
                ts.forEachChild(node, visit);
            };
            visit(sourceFile);
            return { functions };
        }
        catch (error) {
            // Fallback gracefully if TypeScript analysis fails
            console.log(`TypeScript analysis failed: ${error.message}`);
            return null;
        }
    }
    /**
     * Generate sample values based on TypeScript types
     */
    generateSampleValue(type) {
        const cleanType = type.toLowerCase().trim();
        switch (cleanType) {
            case 'string':
                return `'test-string'`;
            case 'number':
                return '42';
            case 'boolean':
                return 'true';
            case 'array':
            case 'string[]':
                return `['item1', 'item2']`;
            case 'number[]':
                return '[1, 2, 3]';
            case 'object':
                return `{ key: 'value' }`;
            default:
                if (cleanType.endsWith('[]')) {
                    return '[]';
                }
                if (cleanType.includes('|')) {
                    // Union type - pick first option
                    const firstType = cleanType.split('|')[0].trim();
                    return this.generateSampleValue(firstType);
                }
                return 'undefined';
        }
    }
    /**
     * Detect if function has parameterized logic suitable for table-driven tests
     */
    detectParameterizedLogic(content, functionName) {
        // Look for the function definition
        const funcRegex = new RegExp(`function\\s+${functionName}\\s*\\([^)]*\\)\\s*\\{([^}]+)\\}`, 'i');
        const match = content.match(funcRegex);
        if (!match)
            return false;
        const functionBody = match[1];
        // Heuristics for parameterized logic
        const hasConditionals = /if\s*\(|switch\s*\(|case\s+/.test(functionBody);
        const hasArithmetic = /[+\-*/%]/.test(functionBody);
        const hasComparisons = /[<>=!]+/.test(functionBody);
        const hasStringOps = /\.split\(|\.substring\(|\.slice\(/.test(functionBody);
        return hasConditionals || hasArithmetic || hasComparisons || hasStringOps;
    }
    /**
     * Generate realistic test inputs based on function parameters
     */
    generateRealisticInputs(functionName, params) {
        const inputs = [];
        const paramNames = [];
        params.forEach(param => {
            paramNames.push(param.name);
            // Generate contextually appropriate values based on parameter name
            const paramName = param.name.toLowerCase();
            const paramType = param.type.toLowerCase();
            if (paramName.includes('id') || paramName.includes('uuid')) {
                inputs.push(paramType === 'string' ? `'user-123'` : '123');
            }
            else if (paramName.includes('name') || paramName.includes('title')) {
                inputs.push(`'TestName'`);
            }
            else if (paramName.includes('email')) {
                inputs.push(`'test@example.com'`);
            }
            else if (paramName.includes('age') || paramName.includes('count')) {
                inputs.push('25');
            }
            else if (paramName.includes('url') || paramName.includes('path')) {
                inputs.push(`'/api/test'`);
            }
            else if (paramName.includes('data') || paramName.includes('payload')) {
                inputs.push(`{ test: 'data' }`);
            }
            else {
                inputs.push(this.generateSampleValue(param.type));
            }
        });
        const expectedPattern = `// Expected: meaningful result based on ${paramNames.join(', ')}`;
        return { inputs, expectedPattern };
    }
    /**
     * Generate deterministic helpers for tests that need them
     */
    generateDeterministicHelpers(usesDate, usesRandom) {
        const helpers = [];
        if (usesDate || usesRandom) {
            helpers.push(`// Deterministic test helpers`);
            helpers.push(`beforeEach(() => {`);
            if (usesDate) {
                helpers.push(`  // Fix time for deterministic Date behavior`);
                helpers.push(`  jest.useFakeTimers().setSystemTime(new Date('2023-01-01T00:00:00Z'));`);
            }
            if (usesRandom) {
                helpers.push(`  // Seed Math.random for deterministic behavior`);
                helpers.push(`  let seed = 12345;`);
                helpers.push(`  Math.random = jest.fn(() => {`);
                helpers.push(`    seed = (seed * 9301 + 49297) % 233280;`);
                helpers.push(`    return seed / 233280;`);
                helpers.push(`  });`);
            }
            helpers.push(`});`);
            helpers.push(``);
            if (usesDate) {
                helpers.push(`afterEach(() => {`);
                helpers.push(`  jest.useRealTimers();`);
                helpers.push(`});`);
                helpers.push(``);
            }
        }
        return helpers;
    }
    /**
     * Generate React component test using React.createElement (no JSX)
     */
    createReactComponentTest(exportName, basename, useReactQueryProvider) {
        const renderLine = useReactQueryProvider
            ? `const { container } = render(React.createElement(Providers as any, {}, React.createElement(Component as any, {})));`
            : `const { container } = render(React.createElement(Component as any, {}));`;
        return [
            `describe('${exportName} Component', () => {`,
            `  it('renders without crashing', () => {`,
            `    // Resolve component from exports`,
            `    const Component = (testModule as any).default ?? (testModule as any)['${exportName}'];`,
            `    expect(Component).toBeDefined();`,
            `    // Smoke render using React.createElement (no JSX)`,
            `    ${renderLine}`,
            `    expect(container).toBeDefined();`,
            `  });`,
            `});`,
            ``
        ];
    }
    /**
     * Generate React hook test using wrapper component
     */
    createReactHookTest(exportName, basename, useReactQueryProvider) {
        const probeRender = useReactQueryProvider
            ? `render(React.createElement(Providers as any, {}, React.createElement(HookProbe)))`
            : `render(React.createElement(HookProbe))`;
        return [
            `describe('${exportName} Hook', () => {`,
            `  it('mounts via probe without errors', () => {`,
            `    // Create hook probe component (never call hooks outside a component)`,
            `    function HookProbe() {`,
            `      const hookResult = (testModule as any)['${exportName}']();`,
            `      return React.createElement('div', { 'data-testid': 'hook-result' }, String(!!hookResult));`,
            `    }`,
            `    const { getByTestId } = ${probeRender};`,
            `    const result = getByTestId('hook-result');`,
            `    expect(result).toBeDefined();`,
            `  });`,
            `});`,
            ``
        ];
    }
    /**
     * Generate unit test content for a file - TypeScript ES module with React support
     * ðŸš©AI: ENTRY_POINT_FOR_GENERATED_TEST_IMPORTS â€” insert `import 'qtests/setup'` first
     * ðŸš©AI: UNIT_TEMPLATE_SECTION â€” write per-export describe/it with positive + edge
     */
    createUnitTest(file, exports, usesQtests, mocks, content = '') {
        const basename = path_1.default.basename(file, path_1.default.extname(file));
        const ext = path_1.default.extname(file);
        const lines = [
            `// Generated unit test for ${path_1.default.basename(file)} - TypeScript ES module`,
            `// ðŸš©AI: ENTRY_POINT_FOR_GENERATED_TEST_IMPORTS`,
            `import 'qtests/setup';`, // Always import qtests/setup first
            ``
        ];
        // Detect if this is a React file and whether it uses React Query
        const isReactFile = this.detectReactUsage(file, content);
        const usesReactQuery = /@tanstack\/react-query/.test(content);
        const wantsRouter = Boolean(this.config.withRouter);
        const detectsRouter = /react-router(?:-dom)?/.test(content);
        const usesReactRouter = isReactFile && wantsRouter && detectsRouter;
        // Import the module being tested (no extension for better ts-jest compatibility)
        lines.push(`import * as testModule from './${basename}';`);
        // Add React imports if needed
        if (isReactFile) {
            lines.push(`import * as React from 'react';`);
            lines.push(`import { render } from '@testing-library/react';`);
            if (usesReactRouter) {
                // Prefer matching the imported module from source when possible
                const routerModule = content.includes('react-router-dom') ? 'react-router-dom' : 'react-router';
                lines.push(`import { MemoryRouter } from '${routerModule}';`);
            }
            if (usesReactQuery) {
                lines.push(`import { QueryClient, QueryClientProvider } from '@tanstack/react-query';`);
            }
            if (usesReactQuery || usesReactRouter) {
                // Compose providers deterministically: MemoryRouter (outer) -> QueryClientProvider (inner)
                lines.push(`// Minimal provider composition for tests`);
                lines.push(`const Providers: React.FC<{ children?: React.ReactNode }> = ({ children }) => {`);
                if (usesReactQuery) {
                    lines.push(`  const client = new QueryClient();`);
                }
                if (usesReactRouter && usesReactQuery) {
                    lines.push(`  return React.createElement(MemoryRouter as any, {}, `);
                    lines.push(`    React.createElement(QueryClientProvider as any, { client }, children as any)`);
                    lines.push(`  );`);
                }
                else if (usesReactRouter) {
                    lines.push(`  return React.createElement(MemoryRouter as any, {}, children as any);`);
                }
                else if (usesReactQuery) {
                    lines.push(`  return React.createElement(QueryClientProvider as any, { client }, children as any);`);
                }
                lines.push(`};`);
            }
        }
        // Add console capture if needed
        if (usesQtests) {
            lines.push(`import { mockConsole } from 'qtests';`);
        }
        lines.push(``);
        // Replace jest.mock with qtests stub comments for known libraries
        if (mocks.length > 0) {
            lines.push(`// External dependencies automatically stubbed by qtests/setup:`);
            mocks.forEach(lib => {
                lines.push(`// - ${lib}: stubbed by qtests (no jest.mock needed)`);
            });
            lines.push(``);
        }
        // Add deterministic helpers if the source code uses Date or Math.random
        if (content) {
            const { usesDate, usesRandom } = this.detectNonDeterministicCode(content);
            const deterministicHelpers = this.generateDeterministicHelpers(usesDate, usesRandom);
            deterministicHelpers.forEach(helper => lines.push(helper));
        }
        // Generate tests per export with React-aware templates
        if (exports.length > 0) {
            exports.forEach(exportName => {
                if (isReactFile && this.isReactHook(exportName)) {
                    // Generate React hook test
                    const hookTestLines = this.createReactHookTest(exportName, basename, usesReactQuery || usesReactRouter);
                    lines.push(...hookTestLines);
                }
                else if (isReactFile && this.isReactComponent(exportName, content)) {
                    // If component appears to require props, fall back to safe module/exists test
                    if (this.componentRequiresProps(exportName, content)) {
                        lines.push(`describe('${exportName} Component', () => {`);
                        lines.push(`  it('is defined (fallback: required props detected)', () => {`);
                        lines.push(`    const Component = (testModule as any).default ?? (testModule as any)['${exportName}'];`);
                        lines.push(`    expect(Component).toBeDefined();`);
                        lines.push(`  });`);
                        lines.push(`});`);
                        lines.push('');
                    }
                    else {
                        // Generate React component test
                        const componentTestLines = this.createReactComponentTest(exportName, basename, usesReactQuery || usesReactRouter);
                        lines.push(...componentTestLines);
                    }
                }
                else {
                    // Generate safe existence test only (no fake function calls)
                    lines.push(`describe('${exportName}', () => {`);
                    lines.push(`  it('is defined', () => {`);
                    lines.push(`    expect(testModule.${exportName}).toBeDefined();`);
                    lines.push(`  });`);
                    lines.push(`});`);
                    lines.push('');
                }
            });
        }
        else {
            // Fallback test when no exports detected
            lines.push(`describe('${path_1.default.basename(file)} module', () => {`);
            lines.push(`  it('should load without errors', async () => {`);
            lines.push(`    expect(testModule).toBeDefined();`);
            lines.push(`    expect(typeof testModule).toBe('object');`);
            lines.push(`  });`);
            lines.push(`});`);
            lines.push(``);
        }
        return lines.join('\n');
    }
    /**
     * Generate API test content for an endpoint - TypeScript ES module only
     * ðŸš©AI: INTEGRATION_TEMPLATE_SECTION â€” createMockApp + supertest + failure path
     */
    createApiTest(method, route) {
        const lines = [
            `// Generated integration test for ${method.toUpperCase()} ${route} - TypeScript ES module`,
            `// ðŸš©AI: ENTRY_POINT_FOR_GENERATED_TEST_IMPORTS`,
            `import 'qtests/setup';`, // Always import qtests/setup first
            ``
        ];
        // Import testing utilities (omit extension for ts-jest compatibility)
        lines.push(`import { createMockApp, supertest } from '../utils/httpTest';`);
        lines.push(``);
        // ðŸš©AI: DETERMINISM_HELPERS â€” fake timers and seeded randomness scaffolding
        lines.push(`// Deterministic test helpers`);
        lines.push(`beforeEach(() => {`);
        lines.push(`  // Use fake timers for deterministic time-based behavior`);
        lines.push(`  jest.useFakeTimers().setSystemTime(new Date('2023-01-01T00:00:00Z'));`);
        lines.push(`});`);
        lines.push(``);
        lines.push(`afterEach(() => {`);
        lines.push(`  jest.useRealTimers();`);
        lines.push(`});`);
        lines.push(``);
        // Generate unique test session for API isolation
        lines.push(`// Deterministic unique route for parallel test safety`);
        lines.push(`const testHash = require('crypto').createHash('md5').update('${route}').digest('hex').slice(0, 8);`);
        lines.push(`const uniqueRoute = '${route}' + ('${route}'.includes('?') ? '&' : '?') + 'testId=' + testHash;`);
        lines.push(``);
        // TypeScript test suite
        lines.push(`describe('${method.toUpperCase()} ${route}', () => {`);
        lines.push(`  let app: ReturnType<typeof createMockApp>;`);
        lines.push(``);
        lines.push(`  beforeEach(() => {`);
        lines.push(`    app = createMockApp();`);
        lines.push(`  });`);
        lines.push(``);
        // Success test case
        lines.push(`  it('should return success response', async () => {`);
        lines.push(`    // Setup route handler`);
        lines.push(`    app.${method.toLowerCase()}(uniqueRoute, (req, res) => {`);
        lines.push(`      res.statusCode = 200;`);
        lines.push(`      res.setHeader('content-type', 'application/json');`);
        lines.push(`      res.end(JSON.stringify({`);
        lines.push(`        success: true,`);
        lines.push(`        message: 'Request processed successfully'`);
        lines.push(`      }));`);
        lines.push(`    });`);
        lines.push(``);
        lines.push(`    // Execute test`);
        lines.push(`    const res = await supertest(app)`);
        lines.push(`      .${method.toLowerCase()}(uniqueRoute)`);
        if (method.toLowerCase() !== 'get') {
            lines.push(`      .send({ testData: 'valid input' })`);
        }
        lines.push(`      .expect(200);`);
        lines.push(``);
        lines.push(`    // Verify response`);
        lines.push(`    expect(res.body.success).toBe(true);`);
        lines.push(`    expect(res.body.message).toBe('Request processed successfully');`);
        lines.push(`  });`);
        lines.push(``);
        // Failure test case  
        lines.push(`  it('should handle not found case', async () => {`);
        lines.push(`    // Don't setup any route handlers to simulate 404`);
        lines.push(``);
        lines.push(`    // Execute test`);
        lines.push(`    const res = await supertest(app)`);
        lines.push(`      .${method.toLowerCase()}('/nonexistent-route')`);
        if (method.toLowerCase() !== 'get') {
            lines.push(`      .send({ testData: 'any data' })`);
        }
        lines.push(`      .expect(404);`);
        lines.push(``);
        lines.push(`    // Verify error response`);
        lines.push(`    expect(res.body.error).toBe('Not Found');`);
        lines.push(`  });`);
        lines.push(`});`);
        lines.push('');
        return lines.join('\n');
    }
    /**
     * Intelligently extract exports from both ES modules and CommonJS
     */
    extractExports(content) {
        const exports = new Set();
        // Remove comments to avoid false positives
        const cleanContent = content
            .replace(/\/\*[\s\S]*?\*\//g, '') // Remove /* */ comments
            .replace(/\/\/.*$/gm, ''); // Remove // comments
        // Extract ES module exports (export const/function/class)
        const esExports = [...cleanContent.matchAll(PATTERNS.exportsES)];
        esExports.forEach(match => {
            if (match[1])
                exports.add(match[1]);
        });
        // Extract ES module named exports: export { name1, name2, name3 }
        const namedExports = [...cleanContent.matchAll(PATTERNS.exportsNamed)];
        namedExports.forEach(match => {
            if (match[1]) {
                // Parse the named exports list
                const exportList = match[1].split(',').map(name => name.trim());
                exportList.forEach(name => {
                    // Handle potential aliases: "name as alias" -> use "name"
                    const cleanName = name.split(' as ')[0].trim();
                    if (cleanName && /^[a-zA-Z0-9_]+$/.test(cleanName)) {
                        exports.add(cleanName);
                    }
                });
            }
        });
        // Extract ES module default exports: export default SomeName
        const defaultExports = [...cleanContent.matchAll(PATTERNS.exportsDefault)];
        defaultExports.forEach(match => {
            if (match[1])
                exports.add(match[1]);
        });
        // Extract CommonJS exports
        const commonJSExports = [...cleanContent.matchAll(PATTERNS.exportsCommonJS)];
        commonJSExports.forEach(match => {
            // match[1] = module.exports.name, match[2] = exports.name, match[3] = single assignment
            for (let i = 1; i <= 3; i++) {
                if (match[i])
                    exports.add(match[i]);
            }
        });
        // Handle module.exports = { name1, name2, ... } pattern
        const objectExportMatch = cleanContent.match(/module\.exports\s*=\s*\{([^}]+)\}/);
        if (objectExportMatch) {
            const objectContent = objectExportMatch[1];
            const propertyMatches = objectContent.matchAll(/\b(\w+)(?:\s*:\s*\w+)?\s*[,}]/g);
            for (const match of propertyMatches) {
                if (match[1])
                    exports.add(match[1]);
            }
        }
        return Array.from(exports).filter(name => name && name.length > 0);
    }
    /**
     * Analyze a single file and generate appropriate tests - TypeScript ES module only
     */
    async analyze(file, dryRun = false) {
        const ext = path_1.default.extname(file);
        if (!this.config.VALID_EXTS.includes(ext)) {
            return;
        }
        const content = fs_1.default.readFileSync(file, 'utf8');
        const usesQtests = PATTERNS.qtests.test(content);
        const imports = this.getUsedModules(content);
        const mockTargets = imports.filter(i => this.config.KNOWN_MOCKS.includes(i) && i !== 'qtests');
        // Use intelligent export detection for both ES modules and CommonJS
        let exports = this.extractExports(content);
        // If AST mode requested, attempt to augment exports via TypeScript parser
        if (this.config.mode === 'ast') {
            try {
                const astInfo = await this.tryTypeScriptAnalysis(file, content);
                if (astInfo && Array.isArray(astInfo.functions)) {
                    const astExports = astInfo.functions.map(fn => fn.name).filter(Boolean);
                    exports = Array.from(new Set([...(exports || []), ...astExports]));
                }
            }
            catch {
                // Swallow AST errors and proceed with heuristic
            }
        }
        if (exports.length > 0 && (!this.config.integration)) {
            const testPath = this.getRelativeTestPath(file, 'unit', content);
            const created = this.writeIfMissing(testPath, this.createUnitTest(file, exports, usesQtests, mockTargets, content), dryRun);
            if (created) {
                this.scanned.push({
                    type: 'unit',
                    file: path_1.default.relative('.', testPath)
                });
            }
        }
        // Generate API tests for detected routes - TypeScript only
        const apis = [...content.matchAll(PATTERNS.api)];
        if (apis.length > 0 && (!this.config.unit)) {
            for (const [, , method, route] of apis) {
                const testPath = this.getRelativeTestPath(file, 'api', content)
                    .replace(/\.GenerateTest\.test\.(ts|tsx)$/, `.GenerateTest__${method.toLowerCase()}.test.$1`);
                const created = this.writeIfMissing(testPath, this.createApiTest(method, route), dryRun);
                // If an API test was created, ensure local httpTest utilities exist (idempotent)
                if (created && !dryRun) {
                    this.ensureLocalHttpTestUtils();
                }
                if (created) {
                    this.scanned.push({
                        type: 'api',
                        file: path_1.default.relative('.', testPath)
                    });
                }
            }
        }
    }
    /**
     * Detect if project uses React based on dependencies and source files
     */
    detectReactProject() {
        try {
            // Honor forced React mode if provided via CLI
            if (this.config.react)
                return true;
            // Check package.json for React dependencies
            const packagePath = path_1.default.join(process.cwd(), 'package.json');
            if (fs_1.default.existsSync(packagePath)) {
                const packageJson = JSON.parse(fs_1.default.readFileSync(packagePath, 'utf8'));
                const allDeps = {
                    ...packageJson.dependencies,
                    ...packageJson.devDependencies,
                    ...packageJson.peerDependencies
                };
                const reactDeps = ['react', '@types/react', 'react-dom', '@types/react-dom',
                    '@testing-library/react', '@tanstack/react-query'];
                if (reactDeps.some(dep => allDeps[dep])) {
                    return true;
                }
            }
            // Scan for .tsx files or React imports in source code
            const allFiles = this.walkProject();
            return allFiles.some(file => {
                if (file.endsWith('.tsx') || file.endsWith('.jsx'))
                    return true;
                try {
                    const content = fs_1.default.readFileSync(file, 'utf8');
                    return this.detectReactUsage(file, content);
                }
                catch {
                    return false;
                }
            });
        }
        catch {
            return false;
        }
    }
    /**
     * Create Jest configuration and setup files - React-aware TypeScript ES Module
     */
    scaffoldJestSetup() {
        const isReactProject = this.detectReactProject();
        // Generate Jest config for TypeScript ES modules with React support
        const extensionsToTreatAsEsm = isReactProject ? ['.ts', '.tsx'] : ['.ts'];
        const moduleFileExtensions = isReactProject ? ['ts', 'tsx', 'js', 'jsx', 'json'] : ['ts', 'js', 'json'];
        const testEnvironment = isReactProject ? 'jsdom' : 'node';
        const testMatchPatterns = isReactProject
            ? [
                '**/*.test.ts',
                '**/*.test.tsx',
                '**/*.GenerateTest.test.ts',
                '**/*.GenerateTest.test.tsx',
                '**/manual-tests/**/*.test.ts',
                '**/generated-tests/**/*.test.ts'
            ]
            : [
                '**/*.test.ts',
                '**/*.GenerateTest.test.ts',
                '**/manual-tests/**/*.test.ts',
                '**/generated-tests/**/*.test.ts'
            ];
        const transformConfig = isReactProject
            ? {
                '^.+\\.tsx?$': ['ts-jest', {
                        useESM: true,
                        isolatedModules: true,
                        tsconfig: {
                            jsx: 'react-jsx'
                        }
                    }]
            }
            : {
                '^.+\\.tsx?$': ['ts-jest', {
                        useESM: true,
                        isolatedModules: true
                    }]
            };
        const config = `
// jest.config.js - TypeScript ES Module configuration${isReactProject ? ' (React-enabled)' : ''}
export default {
  preset: 'ts-jest/presets/default-esm',
  extensionsToTreatAsEsm: ${JSON.stringify(extensionsToTreatAsEsm)},
  testEnvironment: '${testEnvironment}',
  setupFilesAfterEnv: ['<rootDir>/jest-setup.ts'],
  moduleFileExtensions: ${JSON.stringify(moduleFileExtensions)},
  roots: ['<rootDir>'],
  testMatch: ${JSON.stringify(testMatchPatterns, null, 4).replace(/\n/g, '\n  ')},
  transform: ${JSON.stringify(transformConfig, null, 4).replace(/\n/g, '\n  ')},
  transformIgnorePatterns: [
    'node_modules/(?!(?:@tanstack|@radix-ui|lucide-react|react-resizable-panels|cmdk|vaul)/)'
  ],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
    '^qtests/(.*)$': '<rootDir>/node_modules/qtests/$1'
  }${isReactProject ? ',\n  // React Testing Library configuration\n  testEnvironment: \'jsdom\',\n  setupFilesAfterEnv: [\'<rootDir>/jest-setup.ts\']' : ''}
};
`.trim();
        // Generate TypeScript ES module setup with React support
        const domPolyfills = isReactProject ? `

// DOM polyfills for React Testing Library
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // Deprecated
    removeListener: jest.fn(), // Deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// ResizeObserver polyfill
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));

// IntersectionObserver polyfill
global.IntersectionObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));` : '';
        const setup = `
// jest-setup.ts - Jest setup for TypeScript ESM${isReactProject ? ' with React support' : ''}
// Keep qtests setup FIRST to ensure global stubbing is active
import 'qtests/setup';
import 'jest';${isReactProject ? "\nimport '@testing-library/jest-dom';" : ''}

// Set test environment early
process.env.NODE_ENV = 'test';

beforeAll(() => {
  jest.setTimeout(10000);
});

afterEach(() => {
  jest.clearAllMocks();
});${domPolyfills}
`.trim();
        this.writeIfMissing('jest.config.js', config);
        this.writeIfMissing('jest-setup.ts', setup);
    }
    /**
     * Generate qtests test runner file - TypeScript ES module compatible
     */
    generateQtestsRunner() {
        try {
            // Read the existing qtests-ts-runner.ts as template
            const templatePath = path_1.default.join(getModuleDirnameForTestGenerator(), '..', 'qtests-ts-runner.ts');
            let template = '';
            if (fs_1.default.existsSync(templatePath)) {
                template = fs_1.default.readFileSync(templatePath, 'utf8');
            }
            else {
                // Fallback template for TypeScript ES modules with correct Jest configuration
                template = `
// Generated qtests runner - TypeScript ES module compatible
import { spawn } from 'child_process';
import path from 'path';

// Run tests with TypeScript support and correct Jest arguments
const args = process.argv.slice(2);
const testProcess = spawn('jest', args, {
  stdio: 'inherit',
  shell: true
});

testProcess.on('exit', (code) => {
  process.exit(code || 0);
});
`.trim();
            }
            // Always overwrite qtests-ts-runner.ts to ensure latest functionality and TypeScript compliance
            const outputPath = path_1.default.join(process.cwd(), 'qtests-ts-runner.ts');
            fs_1.default.writeFileSync(outputPath, template, 'utf8');
            console.log('âœ… Generated qtests-ts-runner.ts for TypeScript ES modules');
        }
        catch (error) {
            console.error('Failed to generate qtests-ts-runner.ts:', error.message);
        }
    }
    /**
     * Update package.json test script to use qtests-ts-runner.ts
     */
    updatePackageJsonTestScript() {
        try {
            const packagePath = path_1.default.join(process.cwd(), 'package.json');
            if (!fs_1.default.existsSync(packagePath)) {
                console.log('âš ï¸  package.json not found, skipping test script update');
                return;
            }
            const packageJson = JSON.parse(fs_1.default.readFileSync(packagePath, 'utf8'));
            if (!packageJson.scripts) {
                packageJson.scripts = {};
            }
            packageJson.scripts.test = 'npx tsx qtests-ts-runner.ts';
            fs_1.default.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2), 'utf8');
            console.log('âœ… Updated package.json test script to use qtests-ts-runner.ts');
        }
        catch (error) {
            console.log('âš ï¸  Could not update package.json:', error.message);
        }
    }
    /**
     * Scan for files without tests and generate them - TypeScript ES module only
     */
    async generateTestFiles(dryRun = false) {
        console.log('ðŸ” Scanning for files that need TypeScript tests...');
        const allFiles = this.walkProject();
        const { sourceFiles } = this.categorizeFiles(allFiles);
        console.log(`ðŸ“ Found ${sourceFiles.length} source files without tests`);
        // Generate tests for each source file
        for (const file of sourceFiles) {
            await this.analyze(file, dryRun);
        }
        // On non-dry runs, always scaffold Jest and runner even if there were no new files
        if (!dryRun) {
            this.scaffoldJestSetup();
            this.generateQtestsRunner();
            // Only update package.json if requested via CLI flag
            if (this.config.updatePackageScript) {
                this.updatePackageJsonTestScript();
            }
        }
        else {
            console.log('â„¹ï¸ Dry run: Skipping Jest config and runner generation');
        }
        console.log(`ðŸ“ Generated ${this.scanned.length} TypeScript test files:`);
        this.scanned.forEach(test => {
            console.log(`   ${test.type}: ${test.file}`);
        });
    }
    /**
     * Get scan results
     */
    getResults() {
        return this.scanned;
    }
}
exports.TestGenerator = TestGenerator;
exports.default = TestGenerator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bkYsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ1osSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7WUFDNUIscURBQXFEO1lBQ3JELElBQUssSUFBSSxDQUFDLE1BQWMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2dCQUM3QyxJQUFJLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztZQUNyQyxDQUFDO1FBQ0gsQ0FBQzthQUFNLENBQUM7WUFDTixPQUFPLENBQUMsR0FBRyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7UUFDeEUsQ0FBQztRQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSx5QkFBeUIsQ0FBQyxDQUFDO1FBQzFFLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQy9DLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0NBQ0Y7QUFHUSxzQ0FBYTtBQUN0QixrQkFBZSxhQUFhLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvdGVzdEdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3QgR2VuZXJhdG9yIGZvciBxdGVzdHMgRnJhbWV3b3JrIC0gVHlwZVNjcmlwdCBJbXBsZW1lbnRhdGlvblxuICogXG4gKiBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyB1bml0IHRlc3RzIGFuZCBBUEkgdGVzdHMgYnkgc2Nhbm5pbmcgc291cmNlIGNvZGUuXG4gKiBBbmFseXplcyBKYXZhU2NyaXB0L1R5cGVTY3JpcHQgZmlsZXMgdG8gZGV0ZWN0IGV4cG9ydHMsIGltcG9ydHMsIGFuZCBBUEkgcm91dGVzLFxuICogdGhlbiBjcmVhdGVzIGFwcHJvcHJpYXRlIHRlc3QgZmlsZXMgd2l0aCBwcm9wZXIgc3RydWN0dXJlIGFuZCBtb2NraW5nLlxuICogXG4gKiBGZWF0dXJlczpcbiAqIC0gVW5pdCB0ZXN0IGdlbmVyYXRpb24gZm9yIGV4cG9ydGVkIGZ1bmN0aW9ucy9jbGFzc2VzXG4gKiAtIEFQSSB0ZXN0IGdlbmVyYXRpb24gZm9yIEV4cHJlc3Mgcm91dGVzXG4gKiAtIEF1dG9tYXRpYyBtb2NrIHNldHVwIGZvciBrbm93biBsaWJyYXJpZXNcbiAqIC0gSmVzdCBjb25maWd1cmF0aW9uIHNjYWZmb2xkaW5nXG4gKiAtIFN1cHBvcnQgZm9yIHF0ZXN0cyBmcmFtZXdvcmsgaW50ZWdyYXRpb25cbiAqIC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seSAobm8gdmVyc2lvbiBkdXBsaWNhdGlvbilcbiAqL1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBnZXRNb2R1bGVEaXJuYW1lIH0gZnJvbSAnLi4vdXRpbHMvZXNtLWdsb2JhbHMuanMnO1xuXG4vLyBFUyBNb2R1bGUgX19kaXJuYW1lIGVxdWl2YWxlbnQgLSBsYXp5IGluaXRpYWxpemF0aW9uIHRvIGF2b2lkIEplc3QgaXNzdWVzXG5sZXQgbW9kdWxlRGlybmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuZnVuY3Rpb24gZ2V0TW9kdWxlRGlybmFtZUZvclRlc3RHZW5lcmF0b3IoKTogc3RyaW5nIHtcbiAgaWYgKG1vZHVsZURpcm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFVzZSBhIHRyeS1jYXRjaCB0byBoYW5kbGUgSmVzdCBlbnZpcm9ubWVudCBncmFjZWZ1bGx5XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBldmFsIHRvIGhpZGUgaW1wb3J0Lm1ldGEgZnJvbSBKZXN0J3Mgc3RhdGljIHBhcnNlclxuICAgICAgY29uc3QgaW1wb3J0TWV0YVVybCA9ICgwLCBldmFsKSgnaW1wb3J0Lm1ldGEudXJsJyk7XG4gICAgICBtb2R1bGVEaXJuYW1lID0gZ2V0TW9kdWxlRGlybmFtZShpbXBvcnRNZXRhVXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRmFsbGJhY2sgZm9yIEplc3QgZW52aXJvbm1lbnRcbiAgICAgIG1vZHVsZURpcm5hbWUgPSBwcm9jZXNzLmN3ZCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kdWxlRGlybmFtZTtcbn1cblxuLy8gVHlwZSBkZWZpbml0aW9uc1xuaW50ZXJmYWNlIFRlc3RHZW5lcmF0b3JDb25maWcge1xuICBTUkNfRElSOiBzdHJpbmc7XG4gIFRFU1RfRElSOiBzdHJpbmc7XG4gIEtOT1dOX01PQ0tTOiBzdHJpbmdbXTtcbiAgVkFMSURfRVhUUzogc3RyaW5nW107XG4gIG1vZGU/OiAnaGV1cmlzdGljJyB8ICdhc3QnO1xuICB1bml0PzogYm9vbGVhbjtcbiAgaW50ZWdyYXRpb24/OiBib29sZWFuO1xuICBkcnlSdW4/OiBib29sZWFuO1xuICBmb3JjZT86IGJvb2xlYW47XG4gIGluY2x1ZGU/OiBzdHJpbmdbXTtcbiAgZXhjbHVkZT86IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgU2Nhbm5lZFRlc3Qge1xuICB0eXBlOiAndW5pdCcgfCAnYXBpJztcbiAgZmlsZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmlsZUNhdGVnb3JpemF0aW9uIHtcbiAgc291cmNlRmlsZXM6IHN0cmluZ1tdO1xuICBleGlzdGluZ1Rlc3RzOiBzdHJpbmdbXTtcbn1cblxuLy8gQ29uZmlndXJhdGlvbiBjb25zdGFudHMgLSBUeXBlU2NyaXB0IEVTIG1vZHVsZSBvbmx5XG5jb25zdCBERUZBVUxUX0NPTkZJRzogVGVzdEdlbmVyYXRvckNvbmZpZyA9IHtcbiAgU1JDX0RJUjogJy4nLFxuICBURVNUX0RJUjogJ2dlbmVyYXRlZC10ZXN0cycsXG4gIEtOT1dOX01PQ0tTOiBbJ2F4aW9zJywgJ25vZGUtZmV0Y2gnLCAncGcnLCAnbW9uZ29vc2UnLCAnZnMnLCAncmVkaXMnXSxcbiAgVkFMSURfRVhUUzogWycudHMnLCAnLmpzJywgJy50c3gnLCAnLmpzeCddXG59O1xuXG4vLyBSZWdleCBwYXR0ZXJucyBmb3IgY29kZSBhbmFseXNpcyAtIEVuaGFuY2VkIGZvciBib3RoIEVTIG1vZHVsZXMgYW5kIENvbW1vbkpTXG5jb25zdCBQQVRURVJOUyA9IHtcbiAgcXRlc3RzOiAvZnJvbSBbJ1wiXXF0ZXN0c1snXCJdfHJlcXVpcmVcXChbJ1wiXXF0ZXN0c1snXCJdXFwpLyxcbiAgYXBpOiAvXFxiKGFwcHxyb3V0ZXIpXFwuKGdldHxwb3N0fHB1dHxkZWxldGV8cGF0Y2gpXFxzKlxcKFxccypbJ1wiYF0oW14nXCJgXSspWydcImBdL2dpLFxuICAvLyBFUyBtb2R1bGUgZXhwb3J0czogZXhwb3J0IGNvbnN0LCBleHBvcnQgZnVuY3Rpb24sIGV4cG9ydCBjbGFzc1xuICBleHBvcnRzRVM6IC9eXFxzKmV4cG9ydFxccysoPzpjb25zdHxmdW5jdGlvbnxjbGFzcylcXHMrKFthLXpBLVowLTlfXSspL2dtLFxuICAvLyBFUyBtb2R1bGUgbmFtZWQgZXhwb3J0czogZXhwb3J0IHsgbmFtZTEsIG5hbWUyLCBuYW1lMyB9XG4gIGV4cG9ydHNOYW1lZDogL2V4cG9ydFxccypcXHtcXHMqKFtefV0rKVxccypcXH0vZyxcbiAgLy8gRVMgbW9kdWxlIGRlZmF1bHQgZXhwb3J0czogZXhwb3J0IGRlZmF1bHQgU29tZU5hbWVcbiAgZXhwb3J0c0RlZmF1bHQ6IC9leHBvcnRcXHMrZGVmYXVsdFxccysoW2EtekEtWjAtOV9dKykvZyxcbiAgLy8gQ29tbW9uSlMgZXhwb3J0czogbW9kdWxlLmV4cG9ydHMgPSB7fSwgbW9kdWxlLmV4cG9ydHMubmFtZSA9LCBleHBvcnRzLm5hbWUgPVxuICBleHBvcnRzQ29tbW9uSlM6IC8oPzptb2R1bGVcXC5leHBvcnRzXFwuKFthLXpBLVowLTlfXSspXFxzKj18ZXhwb3J0c1xcLihbYS16QS1aMC05X10rKVxccyo9fG1vZHVsZVxcLmV4cG9ydHNcXHMqPVxccyooW2EtekEtWjAtOV9dKykpL2dtLFxuICAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvbnMgdGhhdCBtaWdodCBiZSBleHBvcnRlZFxuICBmdW5jdGlvbkRlY2xhcmF0aW9uczogL15cXHMqKD86YXN5bmNcXHMrKT9mdW5jdGlvblxccysoW2EtekEtWjAtOV9dKylcXHMqXFwoL2dtLFxuICAvLyBDbGFzcyBkZWNsYXJhdGlvbnMgdGhhdCBtaWdodCBiZSBleHBvcnRlZFxuICBjbGFzc0RlY2xhcmF0aW9uczogL15cXHMqY2xhc3NcXHMrKFthLXpBLVowLTlfXSspL2dtLFxuICBpbXBvcnRzOiAvZnJvbSBbJ1wiXShbXidcIl0rKVsnXCJdfHJlcXVpcmVcXChbJ1wiXShbXidcIl0rKVsnXCJdXFwpL2dcbn07XG5cbmNsYXNzIFRlc3RHZW5lcmF0b3Ige1xuICBwcml2YXRlIGNvbmZpZzogVGVzdEdlbmVyYXRvckNvbmZpZztcbiAgcHJpdmF0ZSBzY2FubmVkOiBTY2FubmVkVGVzdFtdO1xuICBwcml2YXRlIGlzRVNNb2R1bGU6IGJvb2xlYW47XG4gIC8vIFByZWNvbXBpbGVkIGluY2x1ZGUvZXhjbHVkZSByZWdleGVzIGZvciBmYXN0IGZpbHRlcmluZ1xuICBwcml2YXRlIGluY2x1ZGVSZWdleGVzOiBSZWdFeHBbXSA9IFtdO1xuICBwcml2YXRlIGV4Y2x1ZGVSZWdleGVzOiBSZWdFeHBbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8VGVzdEdlbmVyYXRvckNvbmZpZz4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0geyAuLi5ERUZBVUxUX0NPTkZJRywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuc2Nhbm5lZCA9IFtdO1xuICAgIHRoaXMuaXNFU01vZHVsZSA9IHRoaXMuZGV0ZWN0RVNNb2R1bGUoKTsgLy8gRGV0ZWN0IG1vZHVsZSB0eXBlIG9uY2UgZHVyaW5nIGluaXRpYWxpemF0aW9uXG4gICAgLy8gQ29tcGlsZSBpbmNsdWRlL2V4Y2x1ZGUgZ2xvYiBwYXR0ZXJucyB0byByZWdleCBmb3IgbWF0Y2hpbmdcbiAgICB0aGlzLmluY2x1ZGVSZWdleGVzID0gKHRoaXMuY29uZmlnLmluY2x1ZGUgfHwgW10pLm1hcCh0aGlzLmdsb2JUb1JlZ0V4cCk7XG4gICAgdGhpcy5leGNsdWRlUmVnZXhlcyA9ICh0aGlzLmNvbmZpZy5leGNsdWRlIHx8IFtdKS5tYXAodGhpcy5nbG9iVG9SZWdFeHApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiB0aGUgY3VycmVudCBwcm9qZWN0IHVzZXMgRVMgbW9kdWxlcyBvciBDb21tb25KU1xuICAgKiBTaW5jZSB3ZSdyZSBub3cgXCJUeXBlU2NyaXB0IEVTIG1vZHVsZSBvbmx5XCIsIHRoaXMgZGVmYXVsdHMgdG8gdHJ1ZSBmb3IgVHlwZVNjcmlwdCBwcm9qZWN0c1xuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RFU01vZHVsZSgpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgcGFja2FnZS5qc29uIGZvciBleHBsaWNpdCBcInR5cGVcIjogXCJtb2R1bGVcIlxuICAgICAgY29uc3QgcGFja2FnZVBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJ3BhY2thZ2UuanNvbicpO1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGFja2FnZVBhdGgpKSB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGFja2FnZVBhdGgsICd1dGY4JykpO1xuICAgICAgICBpZiAocGFja2FnZUpzb24udHlwZSA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seSBhcHByb2FjaCwgcHJlZmVyIEVTIG1vZHVsZXMgd2hlbiBUeXBlU2NyaXB0IGlzIGRldGVjdGVkXG4gICAgICAgIGlmIChwYWNrYWdlSnNvbi5kZXZEZXBlbmRlbmNpZXM/LnR5cGVzY3JpcHQgfHwgcGFja2FnZUpzb24uZGVwZW5kZW5jaWVzPy50eXBlc2NyaXB0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIEVTIG1vZHVsZSBwYXR0ZXJucyBpbiBzb3VyY2UgZmlsZXMgKGV4Y2x1ZGluZyB0ZXN0IGZpbGVzIGFuZCBub2RlX21vZHVsZXMpXG4gICAgICBjb25zdCBzb3VyY2VGaWxlcyA9IHRoaXMud2Fsa1Byb2plY3QoKVxuICAgICAgICAuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShmaWxlKTtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkRXh0ID0gdGhpcy5jb25maWcuVkFMSURfRVhUUy5pbmNsdWRlcyhleHQpO1xuICAgICAgICAgIGNvbnN0IGlzVGVzdEZpbGUgPSB0aGlzLmlzVGVzdEZpbGUocGF0aC5iYXNlbmFtZShmaWxlKSk7XG4gICAgICAgICAgY29uc3QgaXNOb2RlTW9kdWxlcyA9IGZpbGUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcycpO1xuICAgICAgICAgIHJldHVybiBpc1ZhbGlkRXh0ICYmICFpc1Rlc3RGaWxlICYmICFpc05vZGVNb2R1bGVzO1xuICAgICAgICB9KVxuICAgICAgICAuc2xpY2UoMCwgMTApOyAvLyBTYW1wbGUgZmlyc3QgMTAgZmlsZXMgZm9yIHBlcmZvcm1hbmNlXG4gICAgICBcbiAgICAgIGxldCBlc01vZHVsZUNvdW50ID0gMDtcbiAgICAgIGxldCBjb21tb25KU0NvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIHNvdXJjZUZpbGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgICAgICAgIC8vIExvb2sgZm9yIEVTIG1vZHVsZSBwYXR0ZXJucyAoaW1wb3J0IE9SIGV4cG9ydCBzdGF0ZW1lbnRzKVxuICAgICAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdpbXBvcnQgJykgfHwgY29udGVudC5pbmNsdWRlcygnZXhwb3J0ICcpKSB7XG4gICAgICAgICAgICBlc01vZHVsZUNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIExvb2sgZm9yIENvbW1vbkpTIHBhdHRlcm5zXG4gICAgICAgICAgaWYgKGNvbnRlbnQuaW5jbHVkZXMoJ3JlcXVpcmUoJykgfHwgY29udGVudC5pbmNsdWRlcygnbW9kdWxlLmV4cG9ydHMnKSkge1xuICAgICAgICAgICAgY29tbW9uSlNDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBTa2lwIGZpbGVzIHdlIGNhbid0IHJlYWRcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seSBhcHByb2FjaCwgcHJlZmVyIEVTIG1vZHVsZXMgd2hlbiBlcXVhbCBvciB3aGVuIFR5cGVTY3JpcHQgZmlsZXMgYXJlIHByZXNlbnRcbiAgICAgIGlmIChlc01vZHVsZUNvdW50ID09PSAwICYmIGNvbW1vbkpTQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIERlZmF1bHQgdG8gRVMgbW9kdWxlcyBmb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seSBhcHByb2FjaFxuICAgICAgfVxuICAgICAgaWYgKGVzTW9kdWxlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBFUyBtb2R1bGUgcGF0dGVybnMgZm91bmQsIGRlZmF1bHQgdG8gQ29tbW9uSlNcbiAgICAgIH1cbiAgICAgIHJldHVybiBlc01vZHVsZUNvdW50ID49IGNvbW1vbkpTQ291bnQ7IC8vIENoYW5nZWQgZnJvbSA+IHRvID49IHRvIHByZWZlciBFUyBtb2R1bGVzXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIERlZmF1bHQgdG8gRVMgbW9kdWxlcyBmb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGUgb25seSBhcHByb2FjaFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGRpcmVjdG9yeSBzaG91bGQgYmUgc2tpcHBlZCBkdXJpbmcgZGlzY292ZXJ5XG4gICAqL1xuICBwcml2YXRlIHNob3VsZFNraXBEaXJlY3RvcnkoZGlyTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2tpcFBhdHRlcm5zID0gW1xuICAgICAgJ25vZGVfbW9kdWxlcycsICcuZ2l0JywgJy5uZXh0JywgJ2Rpc3QnLCAnYnVpbGQnLCAnY292ZXJhZ2UnLFxuICAgICAgJy52c2NvZGUnLCAnLmlkZWEnLCAnZG9jcycsICdkb2N1bWVudGF0aW9uJywgJ2Fzc2V0cycsICdwdWJsaWMnLCAnc3RhdGljJyxcbiAgICAgICcucmVwbGl0X2NhY2hlJywgJy5jb25maWcnLCAnLm5wbScsICdsb2dzJyxcbiAgICAgICdleGFtcGxlcycsICdkZW1vJywgJ2RlbW9zJywgJ3NhbXBsZXMnLCAnYmluJyxcbiAgICAgIC8vIFNraXAgY29tbW9uIHRlc3QgYW5kIGdlbmVyYXRlZCBkaXJlY3Rvcmllc1xuICAgICAgJ19fbW9ja3NfXycsICdfX3Rlc3RzX18nLCAndGVzdHMnLCAndGVzdCcsICdnZW5lcmF0ZWQtdGVzdHMnLFxuICAgICAgLy8gU2tpcCBtYW51YWwgdGVzdCBkaXJlY3RvcmllcyBhbmQgZml4dHVyZXNcbiAgICAgICdtYW51YWwtdGVzdHMnLCAnZml4dHVyZXMnLCAndGVzdC1maXh0dXJlcydcbiAgICBdO1xuICAgIHJldHVybiBza2lwUGF0dGVybnMuaW5jbHVkZXMoZGlyTmFtZSkgfHwgZGlyTmFtZS5zdGFydHNXaXRoKCcuJyk7XG4gIH1cblxuICAvKipcbiAgICogV2FsayBlbnRpcmUgcHJvamVjdCBkaXJlY3Rvcnkgc3RydWN0dXJlLCByZXNwZWN0aW5nIHNraXAgcGF0dGVybnNcbiAgICovXG4gIHByaXZhdGUgd2Fsa1Byb2plY3QoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLmNvbmZpZy5TUkNfRElSXG4gICAgICA/IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCB0aGlzLmNvbmZpZy5TUkNfRElSKVxuICAgICAgOiBwcm9jZXNzLmN3ZCgpO1xuICAgIHJldHVybiB0aGlzLndhbGtSZWN1cnNpdmUocm9vdCk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayBkaXJlY3RvcnkgYW5kIHJldHVybiBhbGwgZmlsZSBwYXRocywgc2tpcHBpbmcgaXJyZWxldmFudCBkaXJlY3Rvcmllc1xuICAgKi9cbiAgcHJpdmF0ZSB3YWxrUmVjdXJzaXZlKGRpcjogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmcy5yZWFkZGlyU3luYyhkaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KS5mbGF0TWFwKGVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGZ1bGwgPSBwYXRoLnJlc29sdmUoZGlyLCBlbnRyeS5uYW1lKTtcbiAgICAgIFxuICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgLy8gU2tpcCBkaXJlY3RvcmllcyB0aGF0IHNob3VsZG4ndCBjb250YWluIHRlc3RzIG9yIHNvdXJjZSBmaWxlc1xuICAgICAgICBpZiAodGhpcy5zaG91bGRTa2lwRGlyZWN0b3J5KGVudHJ5Lm5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGtSZWN1cnNpdmUoZnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2Z1bGxdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBnbG9iIHBhdHRlcm4gKHN1cHBvcnRzICosICoqLCA/KSBpbnRvIGEgUmVnRXhwXG4gICAqIC0gKiAgbWF0Y2hlcyBhbnkgc2VxdWVuY2UgZXhjZXB0IHBhdGggc2VwYXJhdG9yXG4gICAqIC0gKiogbWF0Y2hlcyBhbnkgc2VxdWVuY2UgaW5jbHVkaW5nIHBhdGggc2VwYXJhdG9yc1xuICAgKiAtID8gIG1hdGNoZXMgYSBzaW5nbGUgY2hhcmFjdGVyIGV4Y2VwdCBwYXRoIHNlcGFyYXRvclxuICAgKi9cbiAgcHJpdmF0ZSBnbG9iVG9SZWdFeHAocGF0dGVybjogc3RyaW5nKTogUmVnRXhwIHtcbiAgICAvLyBOb3JtYWxpemUgdG8gcG9zaXggc3R5bGUgZm9yIG1hdGNoaW5nXG4gICAgbGV0IHBhdCA9IHBhdHRlcm4ucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgIC8vIEVzY2FwZSByZWdleCBzcGVjaWFsIGNoYXJzLCBleGNlcHQgb3VyIGdsb2IgdG9rZW5zICogP1xuICAgIHBhdCA9IHBhdC5yZXBsYWNlKC8oWy4rXiR7fSgpfFxcW1xcXVxcXFxdKS9nLCAnXFxcXCQxJyk7XG4gICAgLy8gQ29udmVydCAqKiB0byBhIHNwZWNpYWwgdG9rZW4gZmlyc3QgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCAqXG4gICAgcGF0ID0gcGF0LnJlcGxhY2UoL1xcKlxcKi9nLCAnOjpHTE9CU1RBUjo6Jyk7XG4gICAgLy8gQ29udmVydCByZW1haW5pbmcgKiBhbmQgP1xuICAgIHBhdCA9IHBhdC5yZXBsYWNlKC9cXCovZywgJ1teL10qJykucmVwbGFjZSgvXFw/L2csICdbXi9dJyk7XG4gICAgLy8gQ29udmVydCBHTE9CU1RBUlxuICAgIHBhdCA9IHBhdC5yZXBsYWNlKC86OkdMT0JTVEFSOjovZywgJy4qJyk7XG4gICAgLy8gQW5jaG9yIHBhdHRlcm5cbiAgICBwYXQgPSAnXicgKyBwYXQgKyAnJCc7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpbmNsdWRlL2V4Y2x1ZGUgcGF0dGVybnMgYWdhaW5zdCBhIHBhdGggKHBvc2l4IG5vcm1hbGl6ZWQpXG4gICAqL1xuICBwcml2YXRlIHBhdGhNYXRjaGVzRmlsdGVycyhmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcG9zaXhQYXRoID0gZmlsZVBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgIC8vIEFwcGx5IGV4Y2x1ZGUgZmlyc3RcbiAgICBpZiAodGhpcy5leGNsdWRlUmVnZXhlcy5zb21lKHJ4ID0+IHJ4LnRlc3QocG9zaXhQYXRoKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgaW5jbHVkZXMgcHJvdmlkZWQsIG11c3QgbWF0Y2ggYXQgbGVhc3Qgb25lIGluY2x1ZGVcbiAgICBpZiAodGhpcy5pbmNsdWRlUmVnZXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmNsdWRlUmVnZXhlcy5zb21lKHJ4ID0+IHJ4LnRlc3QocG9zaXhQYXRoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvLyBObyBpbmNsdWRlcyBtZWFucyBpbmNsdWRlIGFsbCAoYWZ0ZXIgZXhjbHVkZXMpXG4gIH1cblxuICAvKipcbiAgICogTGVnYWN5IHdhbGsgbWV0aG9kIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAod2Fsa3Mgc2luZ2xlIGRpcmVjdG9yeSlcbiAgICovXG4gIHByaXZhdGUgd2FsayhkaXI6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZnMucmVhZGRpclN5bmMoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSkuZmxhdE1hcChlbnRyeSA9PiB7XG4gICAgICBjb25zdCBmdWxsID0gcGF0aC5yZXNvbHZlKGRpciwgZW50cnkubmFtZSk7XG4gICAgICByZXR1cm4gZW50cnkuaXNEaXJlY3RvcnkoKSA/IHRoaXMud2FsayhmdWxsKSA6IFtmdWxsXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmaWxlIHNob3VsZCBiZSBza2lwcGVkIGFzIGEgc291cmNlIGZpbGUgKGNvbmZpZywgc2V0dXAsIGV0Yy4pXG4gICAqL1xuICBwcml2YXRlIHNob3VsZFNraXBTb3VyY2VGaWxlKGZpbGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlKTtcbiAgICBjb25zdCBkaXJuYW1lID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xuICAgIFxuICAgIC8vIFNraXAgZmlsZXMgaW4gdGVzdC1yZWxhdGVkIGRpcmVjdG9yaWVzXG4gICAgaWYgKGRpcm5hbWUuaW5jbHVkZXMoJ21hbnVhbC10ZXN0cycpIHx8IGRpcm5hbWUuaW5jbHVkZXMoJ2ZpeHR1cmVzJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBza2lwUGF0dGVybnMgPSBbXG4gICAgICAvXmplc3RcXC5jb25maWdcXC4vLCAgICAgICAgICAvLyBKZXN0IGNvbmZpZyBmaWxlc1xuICAgICAgL15qZXN0LXNldHVwXFwuLywgICAgICAgICAgICAvLyBKZXN0IHNldHVwIGZpbGVzXG4gICAgICAvXnNldHVwXFwuLywgICAgICAgICAgICAgICAgIC8vIFNldHVwIGZpbGVzXG4gICAgICAvXmNvbmZpZ1xcLi8sICAgICAgICAgICAgICAgIC8vIENvbmZpZyBmaWxlcyAgXG4gICAgICAvLWRlbW9cXC4vLCAgICAgICAgICAgICAgICAgIC8vIERlbW8gZmlsZXNcbiAgICAgIC8tZXhhbXBsZVxcLi8sICAgICAgICAgICAgICAgLy8gRXhhbXBsZSBmaWxlc1xuICAgICAgL1xcLmNvbmZpZ1xcLi8sICAgICAgICAgICAgICAgLy8gQW55IGNvbmZpZyBmaWxlc1xuICAgICAgL15leGFtcGxlXFwuLywgICAgICAgICAgICAgICAvLyBGaWxlcyBuYW1lZCBcImV4YW1wbGUuKlwiXG4gICAgICAvXmRlbW9cXC4vLCAgICAgICAgICAgICAgICAgIC8vIEZpbGVzIG5hbWVkIFwiZGVtby4qXCJcbiAgICAgIC9xdGVzdHMtcnVubmVyXFwuLywgICAgICAgICAgLy8gR2VuZXJhdGVkIHJ1bm5lciBmaWxlc1xuICAgICAgL3NldHVwTXVsdGlwbGUvLCAgICAgICAgICAgIC8vIFRlc3Qgc2V0dXAgaGVscGVyc1xuICAgICAgL3JlbG9hZENoZWNrLywgICAgICAgICAgICAgIC8vIFRlc3QgdXRpbGl0aWVzXG4gICAgICAvdGVzdFNldHVwLywgICAgICAgICAgICAgICAgLy8gVGVzdCBzZXR1cCBmaWxlc1xuICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHNraXBQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KGJhc2VuYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2F0ZWdvcml6ZSBkaXNjb3ZlcmVkIGZpbGVzIGludG8gc291cmNlIGZpbGVzIGFuZCBleGlzdGluZyB0ZXN0c1xuICAgKi9cbiAgcHJpdmF0ZSBjYXRlZ29yaXplRmlsZXMoZmlsZXM6IHN0cmluZ1tdKTogRmlsZUNhdGVnb3JpemF0aW9uIHtcbiAgICBjb25zdCBzb3VyY2VGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBleGlzdGluZ1Rlc3RzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZmlsZSk7XG4gICAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFNraXAgZmlsZXMgd2l0aCBpbnZhbGlkIGV4dGVuc2lvbnNcbiAgICAgIGlmICghdGhpcy5jb25maWcuVkFMSURfRVhUUy5pbmNsdWRlcyhleHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgQ0xJIGluY2x1ZGUvZXhjbHVkZSBmaWx0ZXJzIGFnYWluc3QgcHJvamVjdC1yZWxhdGl2ZSBwYXRoXG4gICAgICBjb25zdCByZWxGcm9tQ3dkID0gcGF0aC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLCBmaWxlKTtcbiAgICAgIGlmICghdGhpcy5wYXRoTWF0Y2hlc0ZpbHRlcnMocmVsRnJvbUN3ZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbmZpZywgZGVtbywgYW5kIHNldHVwIGZpbGVzXG4gICAgICBpZiAodGhpcy5zaG91bGRTa2lwU291cmNlRmlsZShmaWxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB0ZXN0IGZpbGVcbiAgICAgIGlmICh0aGlzLmlzVGVzdEZpbGUoYmFzZW5hbWUpKSB7XG4gICAgICAgIGV4aXN0aW5nVGVzdHMucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgc291cmNlIGZpbGUgYWxyZWFkeSBoYXMgYSBjb3JyZXNwb25kaW5nIHRlc3RcbiAgICAgICAgY29uc3QgaGFzVGVzdCA9IHRoaXMuaGFzQ29ycmVzcG9uZGluZ1Rlc3QoZmlsZSwgZmlsZXMpO1xuICAgICAgICBpZiAoIWhhc1Rlc3QpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHsgc291cmNlRmlsZXMsIGV4aXN0aW5nVGVzdHMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmaWxlbmFtZSBpbmRpY2F0ZXMgaXQncyBhIHRlc3QgZmlsZVxuICAgKi9cbiAgcHJpdmF0ZSBpc1Rlc3RGaWxlKGZpbGVuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0ZXN0UGF0dGVybnMgPSBbXG4gICAgICAvXFwudGVzdFxcLi8sXG4gICAgICAvXFwuc3BlY1xcLi8sXG4gICAgICAvX3Rlc3RcXC4vLFxuICAgICAgL19zcGVjXFwuLyxcbiAgICAgIC9cXC5lMmVcXC4vLFxuICAgICAgL1xcLmludGVncmF0aW9uXFwuL1xuICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHRlc3RQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KGZpbGVuYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzb3VyY2UgZmlsZSBoYXMgYSBjb3JyZXNwb25kaW5nIHRlc3QgZmlsZVxuICAgKi9cbiAgcHJpdmF0ZSBoYXNDb3JyZXNwb25kaW5nVGVzdChzb3VyY2VGaWxlOiBzdHJpbmcsIGFsbEZpbGVzOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShzb3VyY2VGaWxlKTtcbiAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoc291cmNlRmlsZSwgcGF0aC5leHRuYW1lKHNvdXJjZUZpbGUpKTtcbiAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoc291cmNlRmlsZSk7XG4gICAgXG4gICAgLy8gQ29tbW9uIHRlc3QgZmlsZSBwYXR0ZXJucyB0byBsb29rIGZvciAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHlcbiAgICBjb25zdCB0ZXN0UGF0dGVybnMgPSBbXG4gICAgICBgJHtiYXNlbmFtZX0udGVzdC50c2AsXG4gICAgICBgJHtiYXNlbmFtZX0uR2VuZXJhdGVUZXN0LnRlc3QudHNgLCAgLy8gVXBkYXRlZCBnZW5lcmF0ZWQgdW5pdCB0ZXN0IHBhdHRlcm4gIFxuICAgICAgYCR7YmFzZW5hbWV9R2VuZXJhdGVkVGVzdC50ZXN0LnRzYCwgIC8vIExlZ2FjeSBwYXR0ZXJuIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgYCR7YmFzZW5hbWV9LnNwZWMudHNgLFxuICAgICAgYCR7YmFzZW5hbWV9X3Rlc3QudHNgLFxuICAgICAgYCR7YmFzZW5hbWV9X3NwZWMudHNgLFxuICAgICAgYCR7YmFzZW5hbWV9LnRlc3Qke2V4dH1gLFxuICAgICAgYCR7YmFzZW5hbWV9LnNwZWMke2V4dH1gXG4gICAgXTtcbiAgICBcbiAgICAvLyBMb29rIGZvciB0ZXN0IGZpbGVzIGluIHRoZSBzYW1lIGRpcmVjdG9yeVxuICAgIGNvbnN0IHNhbWVEaXJlY3RvcnlUZXN0cyA9IHRlc3RQYXR0ZXJucy5tYXAocGF0dGVybiA9PiBcbiAgICAgIHBhdGguam9pbihkaXIsIHBhdHRlcm4pXG4gICAgKTtcbiAgICBcbiAgICAvLyBMb29rIGZvciB0ZXN0IGZpbGVzIGluIGNvbW1vbiB0ZXN0IGRpcmVjdG9yaWVzXG4gICAgY29uc3QgdGVzdERpcmVjdG9yaWVzID0gWyd0ZXN0cycsICd0ZXN0JywgJ19fdGVzdHNfXycsICdzcGVjJ107XG4gICAgY29uc3QgdGVzdERpcmVjdG9yeVRlc3RzID0gdGVzdERpcmVjdG9yaWVzLmZsYXRNYXAodGVzdERpciA9PiB7XG4gICAgICBjb25zdCB0ZXN0UGF0aCA9IHBhdGguam9pbihkaXIsIHRlc3REaXIpO1xuICAgICAgcmV0dXJuIHRlc3RQYXR0ZXJucy5tYXAocGF0dGVybiA9PiBwYXRoLmpvaW4odGVzdFBhdGgsIHBhdHRlcm4pKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlc2UgdGVzdCBmaWxlcyBleGlzdFxuICAgIGNvbnN0IGFsbFRlc3RQYXRocyA9IFsuLi5zYW1lRGlyZWN0b3J5VGVzdHMsIC4uLnRlc3REaXJlY3RvcnlUZXN0c107XG4gICAgXG4gICAgLy8gTm9ybWFsaXplIHBhdGhzIGZvciBjb21wYXJpc29uIC0gY29udmVydCBib3RoIHRvIGFic29sdXRlIHBhdGhzXG4gICAgY29uc3Qgbm9ybWFsaXplZEFsbEZpbGVzID0gYWxsRmlsZXMubWFwKGZpbGUgPT4gcGF0aC5yZXNvbHZlKGZpbGUpKTtcbiAgICBjb25zdCBub3JtYWxpemVkVGVzdFBhdGhzID0gYWxsVGVzdFBhdGhzLm1hcCh0ZXN0UGF0aCA9PiBwYXRoLnJlc29sdmUodGVzdFBhdGgpKTtcbiAgICBcbiAgICByZXR1cm4gbm9ybWFsaXplZFRlc3RQYXRocy5zb21lKHRlc3RQYXRoID0+IFxuICAgICAgbm9ybWFsaXplZEFsbEZpbGVzLmluY2x1ZGVzKHRlc3RQYXRoKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIHNvdXJjZSBmaWxlIG9yIGNvbnRlbnQgaW5kaWNhdGVzIFJlYWN0IHVzYWdlXG4gICAqL1xuICBwcml2YXRlIGRldGVjdFJlYWN0VXNhZ2UoZmlsZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgPSAnJyk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGZpbGUgZXh0ZW5zaW9uXG4gICAgaWYgKGZpbGUuZW5kc1dpdGgoJy50c3gnKSB8fCBmaWxlLmVuZHNXaXRoKCcuanN4JykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBmb3IgUmVhY3QgaW1wb3J0c1xuICAgIGNvbnN0IHJlYWN0SW1wb3J0cyA9IC9pbXBvcnQuKig/OnJlYWN0fFJlYWN0fEB0eXBlc1xcL3JlYWN0KS9pLnRlc3QoY29udGVudCk7XG4gICAgaWYgKHJlYWN0SW1wb3J0cykgcmV0dXJuIHRydWU7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIEpTWCBwYXR0ZXJuc1xuICAgIGNvbnN0IGpzeFBhdHRlcm5zID0gW1xuICAgICAgLzxbQS1aXVthLXpBLVowLTldKltcXHNcXC8+XS8sIC8vIENvbXBvbmVudCB0YWdzIGxpa2UgPE15Q29tcG9uZW50XG4gICAgICAvPFthLXpdK1tcXHNcXC8+XS8sIC8vIEhUTUwgdGFncyBsaWtlIDxkaXY+XG4gICAgICAvUmVhY3RcXC5jcmVhdGVFbGVtZW50LywgLy8gUmVhY3QuY3JlYXRlRWxlbWVudCBjYWxsc1xuICAgICAgL2pzeC4qOi8sICAvLyBKU1ggcHJhZ21hXG4gICAgXTtcbiAgICBcbiAgICByZXR1cm4ganN4UGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChjb250ZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGV4cG9ydCBuYW1lIGlzIGxpa2VseSBhIFJlYWN0IGhvb2tcbiAgICovXG4gIHByaXZhdGUgaXNSZWFjdEhvb2soZXhwb3J0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGV4cG9ydE5hbWUuc3RhcnRzV2l0aCgndXNlJykgJiYgZXhwb3J0TmFtZS5sZW5ndGggPiAzO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBleHBvcnQgbmFtZSBpcyBsaWtlbHkgYSBSZWFjdCBjb21wb25lbnRcbiAgICovXG4gIHByaXZhdGUgaXNSZWFjdENvbXBvbmVudChleHBvcnROYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2sgaWYgaXQgc3RhcnRzIHdpdGggdXBwZXJjYXNlIChjb21wb25lbnQgY29udmVudGlvbilcbiAgICBpZiAoIS9eW0EtWl0vLnRlc3QoZXhwb3J0TmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBpdCdzIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB0aGF0IG1pZ2h0IHJldHVybiBKU1hcbiAgICBjb25zdCBjb21wb25lbnRQYXR0ZXJucyA9IFtcbiAgICAgIG5ldyBSZWdFeHAoYGZ1bmN0aW9uXFxcXHMrJHtleHBvcnROYW1lfVxcXFxzKlxcXFwoYCksXG4gICAgICBuZXcgUmVnRXhwKGBjb25zdFxcXFxzKyR7ZXhwb3J0TmFtZX1cXFxccyo9XFxcXHMqXFxcXChgKSxcbiAgICAgIG5ldyBSZWdFeHAoYGV4cG9ydFxcXFxzK2Z1bmN0aW9uXFxcXHMrJHtleHBvcnROYW1lfVxcXFxzKlxcXFwoYCksXG4gICAgICBuZXcgUmVnRXhwKGAke2V4cG9ydE5hbWV9XFxcXHMqPVxcXFxzKlxcXFwoLipcXFxcKVxcXFxzKj0+YCkgLy8gQXJyb3cgZnVuY3Rpb25cbiAgICBdO1xuICAgIFxuICAgIHJldHVybiBjb21wb25lbnRQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KGNvbnRlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZXVyaXN0aWNhbGx5IGRldGVjdCBpZiBhIFJlYWN0IGNvbXBvbmVudCBsaWtlbHkgcmVxdWlyZXMgcHJvcHMuXG4gICAqIC0gVFMgaW5saW5lIHByb3AgdHlwZXMgd2l0aG91dCA/OiByZXF1aXJlZCAoZS5nLiwgcHJvcHM6IHsgaWQ6IHN0cmluZyB9KVxuICAgKiAtIERlc3RydWN0dXJlZCBwcm9wcyB3aXRob3V0IGRlZmF1bHRzIChlLmcuLCBmdW5jdGlvbiBDKHsgaWQgfTogeyBpZDogc3RyaW5nIH0pKVxuICAgKiAtIHByb3BUeXBlcyB3aXRoIGlzUmVxdWlyZWRcbiAgICovXG4gIHByaXZhdGUgY29tcG9uZW50UmVxdWlyZXNQcm9wcyhleHBvcnROYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIDEpIHByb3BUeXBlcyBpc1JlcXVpcmVkXG4gICAgICBjb25zdCBwcm9wVHlwZXNSZXEgPSBuZXcgUmVnRXhwKGAke2V4cG9ydE5hbWV9XFwucHJvcFR5cGVzXFxzKj1cXHMqXFx7W1xcc1xcU10qP2lzUmVxdWlyZWRgLCAnbScpO1xuICAgICAgaWYgKHByb3BUeXBlc1JlcS50ZXN0KGNvbnRlbnQpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gMikgVFMgaW5saW5lIHR5cGUgd2l0aCByZXF1aXJlZCBmaWVsZHMgKG5vID8pXG4gICAgICBjb25zdCB0c0lubGluZTEgPSBuZXcgUmVnRXhwKGBmdW5jdGlvblxccyske2V4cG9ydE5hbWV9XFxzKlxcKFxccypwcm9wc1xccyo6XFxzKlxceyhbXFxuXFxyXFx0IFxcdzo8PlxcfFxcW1xcXVxcblxcciw/XSspXFx9XFxzKlxcKWAsICdtJyk7XG4gICAgICBjb25zdCB0c0lubGluZTIgPSBuZXcgUmVnRXhwKGBjb25zdFxccyske2V4cG9ydE5hbWV9XFxzKj1cXHMqXFwoXFxzKnByb3BzXFxzKjpcXHMqXFx7KFtcXG5cXHJcXHQgXFx3Ojw+XFx8XFxbXFxdXFxuXFxyLD9dKylcXH1cXHMqXFwpYCwgJ20nKTtcbiAgICAgIGNvbnN0IHRzRGVzdHJ1Y3R1cmVkID0gbmV3IFJlZ0V4cChgZnVuY3Rpb25cXHMrJHtleHBvcnROYW1lfVxccypcXChcXHMqXFx7KFtefT1dKylcXH1cXHMqOlxccypcXHsoW159XSspXFx9XFxzKlxcKWAsICdtJyk7XG4gICAgICBjb25zdCB0c0Fycm93RGVzdHJ1Y3R1cmVkID0gbmV3IFJlZ0V4cChgY29uc3RcXHMrJHtleHBvcnROYW1lfVxccyo9XFxzKlxcKFxccypcXHsoW159PV0rKVxcfVxccyo6XFxzKlxceyhbXn1dKylcXH1cXHMqXFwpYCwgJ20nKTtcblxuICAgICAgY29uc3QgbWF0Y2hlcyA9IFt0c0lubGluZTEuZXhlYyhjb250ZW50KSwgdHNJbmxpbmUyLmV4ZWMoY29udGVudCksIHRzRGVzdHJ1Y3R1cmVkLmV4ZWMoY29udGVudCksIHRzQXJyb3dEZXN0cnVjdHVyZWQuZXhlYyhjb250ZW50KV07XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWF0Y2hlcykge1xuICAgICAgICBpZiAoIW0pIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0eXBlQmxvY2sgPSAobVsxXSB8fCBtWzJdIHx8ICcnKS50cmltKCk7XG4gICAgICAgIGlmICghdHlwZUJsb2NrKSBjb250aW51ZTtcbiAgICAgICAgLy8gSWYgYW55IGZpZWxkIGxhY2tzID8sIGFzc3VtZSByZXF1aXJlZFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0eXBlQmxvY2suc3BsaXQoJywnKTtcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIGZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkID0gZi50cmltKCk7XG4gICAgICAgICAgaWYgKCFmaWVsZCkgY29udGludWU7XG4gICAgICAgICAgLy8gRXhhbXBsZTogaWQ/OiBzdHJpbmcgdnMgaWQ6IHN0cmluZ1xuICAgICAgICAgIGlmICgvXltBLVphLXpfJF1bXFx3JF0qXFxzKjpcXHMqW14/XS8udGVzdChmaWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAzKSBEZXN0cnVjdHVyZWQgcHJvcHMgd2l0aG91dCBkZWZhdWx0IG9iamVjdCBmb3IgcGFyYW0gKG5vID0ge30pXG4gICAgICBjb25zdCBkZXN0cnVjdHVyZWROb0RlZmF1bHRGbiA9IG5ldyBSZWdFeHAoYGZ1bmN0aW9uXFxzKyR7ZXhwb3J0TmFtZX1cXHMqXFwoXFxzKlxceyhbXn1dKylcXH1cXHMqXFwpYCwgJ20nKTtcbiAgICAgIGNvbnN0IGRlc3RydWN0dXJlZE5vRGVmYXVsdEFycm93ID0gbmV3IFJlZ0V4cChgY29uc3RcXHMrJHtleHBvcnROYW1lfVxccyo9XFxzKlxcKFxccypcXHsoW159XSspXFx9XFxzKlxcKWAsICdtJyk7XG4gICAgICBpZiAoZGVzdHJ1Y3R1cmVkTm9EZWZhdWx0Rm4udGVzdChjb250ZW50KSB8fCBkZXN0cnVjdHVyZWROb0RlZmF1bHRBcnJvdy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJhbSBpbmNsdWRlcyA9IHt9LCBpdCdzIG9wdGlvbmFsOyBvdGhlcndpc2UgYXNzdW1lIHJlcXVpcmVkXG4gICAgICAgIGNvbnN0IHBhcmFtV2l0aERlZmF1bHQgPSBuZXcgUmVnRXhwKGAke2V4cG9ydE5hbWV9W15cXG5dKlxcKFxccypcXHtbXn1dK1xcfVxccyo9XFxzKlxce1xcfVxccypcXClgKTtcbiAgICAgICAgaWYgKCFwYXJhbVdpdGhEZWZhdWx0LnRlc3QoY29udGVudCkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRlc3QgZmlsZSBwYXRoIGJhc2VkIG9uIHNvdXJjZSBmaWxlIGFuZCB0ZXN0IHR5cGVcbiAgICogUmVhY3QtYXdhcmU6IGdlbmVyYXRlcyAudHN4IGZvciBSZWFjdCBjb21wb25lbnRzL2hvb2tzLCAudHMgb3RoZXJ3aXNlXG4gICAqL1xuICBwcml2YXRlIGdldFJlbGF0aXZlVGVzdFBhdGgoZmlsZTogc3RyaW5nLCB0eXBlOiAndW5pdCcgfCAnYXBpJyA9ICd1bml0JywgY29udGVudDogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKTtcbiAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSwgcGF0aC5leHRuYW1lKGZpbGUpKTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgdGVzdCBmaWxlIGV4dGVuc2lvbiBiYXNlZCBvbiBSZWFjdCB1c2FnZVxuICAgIGNvbnN0IGlzUmVhY3RGaWxlID0gdGhpcy5kZXRlY3RSZWFjdFVzYWdlKGZpbGUsIGNvbnRlbnQpO1xuICAgIGNvbnN0IHRlc3RFeHQgPSBpc1JlYWN0RmlsZSA/ICcudHN4JyA6ICcudHMnO1xuICAgIFxuICAgIGlmICh0eXBlID09PSAndW5pdCcpIHtcbiAgICAgIC8vIEZvciB1bml0IHRlc3RzLCBwbGFjZSB0aGVtIGFsb25nc2lkZSB0aGUgc291cmNlIGZpbGUgd2l0aCBHZW5lcmF0ZWRUZXN0IG5hbWluZ1xuICAgICAgcmV0dXJuIHBhdGguam9pbihkaXIsIGAke2Jhc2VuYW1lfS5HZW5lcmF0ZVRlc3QudGVzdCR7dGVzdEV4dH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIEFQSS9pbnRlZ3JhdGlvbiB0ZXN0cywgdXNlIHRoZSBjb25maWd1cmVkIHRlc3QgZGlyZWN0b3J5IHdpdGggYXBwcm9wcmlhdGUgZXh0ZW5zaW9uXG4gICAgICBjb25zdCByZWwgPSBwYXRoLnJlbGF0aXZlKHByb2Nlc3MuY3dkKCksIGZpbGUpO1xuICAgICAgcmV0dXJuIHBhdGguam9pbih0aGlzLmNvbmZpZy5URVNUX0RJUiwgcmVsLnJlcGxhY2UoL1xcLlt0al1zeD8kLywgYC5HZW5lcmF0ZVRlc3QudGVzdCR7dGVzdEV4dH1gKS5yZXBsYWNlKC9bXFxcXC9dL2csICdfXycpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZURpcihwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUocCk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICAgIGZzLm1rZGlyU3luYyhkaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBmaWxlIG9ubHkgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LCB1bmxlc3MgZm9yY2UgZmxhZyBpcyBzZXRcbiAgICogU3VwcG9ydHMgZHJ5LXJ1biBtb2RlIGZvciBwcmV2aWV3aW5nIHBsYW5uZWQgZmlsZXNcbiAgICovXG4gIHByaXZhdGUgd3JpdGVJZk1pc3NpbmcocDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIGRyeVJ1bjogYm9vbGVhbiA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhwKTtcbiAgICAvLyBBbGxvdyBvdmVyd3JpdGUgb25seSBmb3IgZmlsZXMgZ2VuZXJhdGVkIGJ5IHRoaXMgdG9vbCAoY29udGFpbiBcIi5HZW5lcmF0ZVRlc3RcIilcbiAgICBjb25zdCBpc0dlbmVyYXRlZFRlc3QgPSBwLmluY2x1ZGVzKCcuR2VuZXJhdGVUZXN0Jyk7XG4gICAgY29uc3QgY2FuV3JpdGUgPSAhZXhpc3RzIHx8IChCb29sZWFuKHRoaXMuY29uZmlnLmZvcmNlKSAmJiBpc0dlbmVyYXRlZFRlc3QpO1xuICAgIFxuICAgIGlmIChkcnlSdW4pIHtcbiAgICAgIC8vIEluIGRyeS1ydW4gbW9kZSwganVzdCBsb2cgd2hhdCB3b3VsZCBiZSB3cml0dGVuXG4gICAgICBjb25zb2xlLmxvZyhgJHtleGlzdHMgPyAnW1dPVUxEIE9WRVJXUklURV0nIDogJ1tXT1VMRCBDUkVBVEVdJ30gJHtwYXRoLnJlbGF0aXZlKCcuJywgcCl9YCk7XG4gICAgICByZXR1cm4gY2FuV3JpdGU7XG4gICAgfVxuICAgIFxuICAgIGlmIChjYW5Xcml0ZSkge1xuICAgICAgdGhpcy5jcmVhdGVEaXIocCk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHAsIGNvbnRlbnQsICd1dGY4Jyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgaW1wb3J0ZWQgbW9kdWxlcyBmcm9tIGZpbGUgY29udGVudCAtIEVuaGFuY2VkIGZvciBib3RoIEVTIG1vZHVsZXMgYW5kIENvbW1vbkpTXG4gICAqL1xuICBwcml2YXRlIGdldFVzZWRNb2R1bGVzKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLmNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuaW1wb3J0cyldXG4gICAgICAubWFwKG0gPT4gbVsxXSB8fCBtWzJdKSAvLyBtWzFdIGZvciBFUyBtb2R1bGVzLCBtWzJdIGZvciBDb21tb25KU1xuICAgICAgLmZpbHRlcih4ID0+IHggJiYgIXguc3RhcnRzV2l0aCgnLicpICYmICF4LnN0YXJ0c1dpdGgoJy8nKSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGEgbG9jYWwgY29weSBvZiBBUEkgdGVzdCB1dGlsaXRpZXMgZXhpc3RzIGF0IGdlbmVyYXRlZC10ZXN0cy91dGlscy9odHRwVGVzdC50c1xuICAgKiBzbyB0aGF0IGdlbmVyYXRlZCBpbnRlZ3JhdGlvbiB0ZXN0cyB3b3JrIHdpdGhvdXQgZXh0cmEgcHJvamVjdCB3aXJpbmcuXG4gICAqIElkZW1wb3RlbnQ6IG9ubHkgd3JpdGVzIGlmIG1pc3NpbmcuXG4gICAqL1xuICBwcml2YXRlIGVuc3VyZUxvY2FsSHR0cFRlc3RVdGlscygpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGFyZ2V0RGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIHRoaXMuY29uZmlnLlRFU1RfRElSIHx8ICdnZW5lcmF0ZWQtdGVzdHMnLCAndXRpbHMnKTtcbiAgICAgIGNvbnN0IHRhcmdldEZpbGUgPSBwYXRoLmpvaW4odGFyZ2V0RGlyLCAnaHR0cFRlc3QudHMnKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHRhcmdldEZpbGUpKSByZXR1cm47XG5cbiAgICAgIC8vIFRyeSB0byByZWFkIHRoZSBwYWNrYWdlJ3MgaHR0cFRlc3QudHMgdG8gY29weSBvdmVyXG4gICAgICBjb25zdCBzcmMgPSBwYXRoLmpvaW4oZ2V0TW9kdWxlRGlybmFtZUZvclRlc3RHZW5lcmF0b3IoKSwgJy4uJywgJ3V0aWxzJywgJ2h0dHBUZXN0LnRzJyk7XG4gICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhzcmMsICd1dGY4Jyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gTWluaW1hbCBmYWxsYmFjayBzaGltIGlmIHRoZSBzb3VyY2UgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgIGNvbnRlbnQgPSBbXG4gICAgICAgICAgYC8vIE1pbmltYWwgaHR0cFRlc3Qgc2hpbSBmb3IgZ2VuZXJhdGVkIGludGVncmF0aW9uIHRlc3RzYCxcbiAgICAgICAgICBgZXhwb3J0IHsgZGVmYXVsdCBhcyBzdXBlcnRlc3QgfSBmcm9tICdzdXBlcnRlc3QnO2AsXG4gICAgICAgICAgYGV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb2NrQXBwKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZU1vY2tBcHAgbm90IGF2YWlsYWJsZSBpbiBzaGltJyk7IH1gXG4gICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICBmcy5ta2RpclN5bmModGFyZ2V0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0RmlsZSwgY29udGVudCwgJ3V0ZjgnKTtcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgU2NhZmZvbGVkIGxvY2FsIEFQSSB0ZXN0IHV0aWxzIGF0ICR7cGF0aC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLCB0YXJnZXRGaWxlKX1gKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gIENvdWxkIG5vdCBzY2FmZm9sZCBsb2NhbCBodHRwVGVzdCB1dGlsczonLCBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVycikpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgY29kZSB1c2VzIERhdGUgb3IgTWF0aC5yYW5kb20gZm9yIGRldGVybWluaXN0aWMgdGVzdCBoZWxwZXJzXG4gICAqIPCfmqlBSTogREVURVJNSU5JU01fSEVMUEVSUyDigJQgZmFrZSB0aW1lcnMgYW5kIHNlZWRlZCByYW5kb21uZXNzIHNjYWZmb2xkaW5nXG4gICAqL1xuICBwcml2YXRlIGRldGVjdE5vbkRldGVybWluaXN0aWNDb2RlKGNvbnRlbnQ6IHN0cmluZyk6IHsgdXNlc0RhdGU6IGJvb2xlYW47IHVzZXNSYW5kb206IGJvb2xlYW4gfSB7XG4gICAgY29uc3QgdXNlc0RhdGUgPSAvbmV3IERhdGVcXCh8RGF0ZVxcLm5vd1xcKHxcXC5nZXRUaW1lXFwoLy50ZXN0KGNvbnRlbnQpO1xuICAgIGNvbnN0IHVzZXNSYW5kb20gPSAvTWF0aFxcLnJhbmRvbVxcKC8udGVzdChjb250ZW50KTtcbiAgICByZXR1cm4geyB1c2VzRGF0ZSwgdXNlc1JhbmRvbSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIFR5cGVTY3JpcHQgQVNUIGFuYWx5c2lzIGZvciBiZXR0ZXIgdHlwZSBpbmZlcmVuY2VcbiAgICog8J+aqUFJOiBUWVBFX0lORkVSRU5DRV9PUFRJT04g4oCUIGR5bmFtaWMgaW1wb3J0KCd0eXBlc2NyaXB0Jykgd2l0aCBoZXVyaXN0aWNzIGZhbGxiYWNrXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHRyeVR5cGVTY3JpcHRBbmFseXNpcyhmaWxlOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8eyBmdW5jdGlvbnM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyBwYXJhbXM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfT4gfT4gfSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRHluYW1pYyBpbXBvcnQgb2YgVHlwZVNjcmlwdCAtIG9ubHkgaWYgYXZhaWxhYmxlXG4gICAgICBjb25zdCB0cyA9IGF3YWl0IGltcG9ydCgndHlwZXNjcmlwdCcpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgaWYgKCF0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgdGhlIFR5cGVTY3JpcHQgc291cmNlXG4gICAgICBjb25zdCBzb3VyY2VGaWxlID0gdHMuY3JlYXRlU291cmNlRmlsZShcbiAgICAgICAgZmlsZSxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgdHMuU2NyaXB0VGFyZ2V0LkxhdGVzdCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZnVuY3Rpb25zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcGFyYW1zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgdHlwZTogc3RyaW5nIH0+IH0+ID0gW107XG5cbiAgICAgIC8vIFZpc2l0b3IgZnVuY3Rpb24gdG8gZXh0cmFjdCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgd2l0aCB0eXBlc1xuICAgICAgY29uc3QgdmlzaXQgPSAobm9kZTogYW55KSA9PiB7XG4gICAgICAgIGlmICh0cy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24obm9kZSkgJiYgbm9kZS5uYW1lKSB7XG4gICAgICAgICAgY29uc3QgZnVuY05hbWUgPSBub2RlLm5hbWUuZ2V0VGV4dCgpO1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5vZGUucGFyYW1ldGVycy5tYXAoKHBhcmFtOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBuYW1lOiBwYXJhbS5uYW1lLmdldFRleHQoKSxcbiAgICAgICAgICAgIHR5cGU6IHBhcmFtLnR5cGUgPyBwYXJhbS50eXBlLmdldFRleHQoKSA6ICdhbnknXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGZ1bmN0aW9ucy5wdXNoKHsgbmFtZTogZnVuY05hbWUsIHBhcmFtcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHMuZm9yRWFjaENoaWxkKG5vZGUsIHZpc2l0KTtcbiAgICAgIH07XG5cbiAgICAgIHZpc2l0KHNvdXJjZUZpbGUpO1xuICAgICAgcmV0dXJuIHsgZnVuY3Rpb25zIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAvLyBGYWxsYmFjayBncmFjZWZ1bGx5IGlmIFR5cGVTY3JpcHQgYW5hbHlzaXMgZmFpbHNcbiAgICAgIGNvbnNvbGUubG9nKGBUeXBlU2NyaXB0IGFuYWx5c2lzIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHNhbXBsZSB2YWx1ZXMgYmFzZWQgb24gVHlwZVNjcmlwdCB0eXBlc1xuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVNhbXBsZVZhbHVlKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgY2xlYW5UeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBcbiAgICBzd2l0Y2ggKGNsZWFuVHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIGAndGVzdC1zdHJpbmcnYDtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiAnNDInO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAndHJ1ZSc7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdzdHJpbmdbXSc6XG4gICAgICAgIHJldHVybiBgWydpdGVtMScsICdpdGVtMiddYDtcbiAgICAgIGNhc2UgJ251bWJlcltdJzpcbiAgICAgICAgcmV0dXJuICdbMSwgMiwgM10nO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuIGB7IGtleTogJ3ZhbHVlJyB9YDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjbGVhblR5cGUuZW5kc1dpdGgoJ1tdJykpIHtcbiAgICAgICAgICByZXR1cm4gJ1tdJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xlYW5UeXBlLmluY2x1ZGVzKCd8JykpIHtcbiAgICAgICAgICAvLyBVbmlvbiB0eXBlIC0gcGljayBmaXJzdCBvcHRpb25cbiAgICAgICAgICBjb25zdCBmaXJzdFR5cGUgPSBjbGVhblR5cGUuc3BsaXQoJ3wnKVswXS50cmltKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVTYW1wbGVWYWx1ZShmaXJzdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGZ1bmN0aW9uIGhhcyBwYXJhbWV0ZXJpemVkIGxvZ2ljIHN1aXRhYmxlIGZvciB0YWJsZS1kcml2ZW4gdGVzdHNcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0UGFyYW1ldGVyaXplZExvZ2ljKGNvbnRlbnQ6IHN0cmluZywgZnVuY3Rpb25OYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBMb29rIGZvciB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGNvbnN0IGZ1bmNSZWdleCA9IG5ldyBSZWdFeHAoYGZ1bmN0aW9uXFxcXHMrJHtmdW5jdGlvbk5hbWV9XFxcXHMqXFxcXChbXildKlxcXFwpXFxcXHMqXFxcXHsoW159XSspXFxcXH1gLCAnaScpO1xuICAgIGNvbnN0IG1hdGNoID0gY29udGVudC5tYXRjaChmdW5jUmVnZXgpO1xuICAgIFxuICAgIGlmICghbWF0Y2gpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSBtYXRjaFsxXTtcbiAgICBcbiAgICAvLyBIZXVyaXN0aWNzIGZvciBwYXJhbWV0ZXJpemVkIGxvZ2ljXG4gICAgY29uc3QgaGFzQ29uZGl0aW9uYWxzID0gL2lmXFxzKlxcKHxzd2l0Y2hcXHMqXFwofGNhc2VcXHMrLy50ZXN0KGZ1bmN0aW9uQm9keSk7XG4gICAgY29uc3QgaGFzQXJpdGhtZXRpYyA9IC9bK1xcLSovJV0vLnRlc3QoZnVuY3Rpb25Cb2R5KTtcbiAgICBjb25zdCBoYXNDb21wYXJpc29ucyA9IC9bPD49IV0rLy50ZXN0KGZ1bmN0aW9uQm9keSk7XG4gICAgY29uc3QgaGFzU3RyaW5nT3BzID0gL1xcLnNwbGl0XFwofFxcLnN1YnN0cmluZ1xcKHxcXC5zbGljZVxcKC8udGVzdChmdW5jdGlvbkJvZHkpO1xuICAgIFxuICAgIHJldHVybiBoYXNDb25kaXRpb25hbHMgfHwgaGFzQXJpdGhtZXRpYyB8fCBoYXNDb21wYXJpc29ucyB8fCBoYXNTdHJpbmdPcHM7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgcmVhbGlzdGljIHRlc3QgaW5wdXRzIGJhc2VkIG9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVSZWFsaXN0aWNJbnB1dHMoZnVuY3Rpb25OYW1lOiBzdHJpbmcsIHBhcmFtczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHR5cGU6IHN0cmluZyB9Pik6IHsgaW5wdXRzOiBzdHJpbmdbXTsgZXhwZWN0ZWRQYXR0ZXJuOiBzdHJpbmcgfSB7XG4gICAgY29uc3QgaW5wdXRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHBhcmFtTmFtZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgcGFyYW1zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKHBhcmFtLm5hbWUpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBjb250ZXh0dWFsbHkgYXBwcm9wcmlhdGUgdmFsdWVzIGJhc2VkIG9uIHBhcmFtZXRlciBuYW1lXG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBwYXJhbVR5cGUgPSBwYXJhbS50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBcbiAgICAgIGlmIChwYXJhbU5hbWUuaW5jbHVkZXMoJ2lkJykgfHwgcGFyYW1OYW1lLmluY2x1ZGVzKCd1dWlkJykpIHtcbiAgICAgICAgaW5wdXRzLnB1c2gocGFyYW1UeXBlID09PSAnc3RyaW5nJyA/IGAndXNlci0xMjMnYCA6ICcxMjMnKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lLmluY2x1ZGVzKCduYW1lJykgfHwgcGFyYW1OYW1lLmluY2x1ZGVzKCd0aXRsZScpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoKGAnVGVzdE5hbWUnYCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZS5pbmNsdWRlcygnZW1haWwnKSkge1xuICAgICAgICBpbnB1dHMucHVzaChgJ3Rlc3RAZXhhbXBsZS5jb20nYCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZS5pbmNsdWRlcygnYWdlJykgfHwgcGFyYW1OYW1lLmluY2x1ZGVzKCdjb3VudCcpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoKCcyNScpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbU5hbWUuaW5jbHVkZXMoJ3VybCcpIHx8IHBhcmFtTmFtZS5pbmNsdWRlcygncGF0aCcpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoKGAnL2FwaS90ZXN0J2ApO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbU5hbWUuaW5jbHVkZXMoJ2RhdGEnKSB8fCBwYXJhbU5hbWUuaW5jbHVkZXMoJ3BheWxvYWQnKSkge1xuICAgICAgICBpbnB1dHMucHVzaChgeyB0ZXN0OiAnZGF0YScgfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRzLnB1c2godGhpcy5nZW5lcmF0ZVNhbXBsZVZhbHVlKHBhcmFtLnR5cGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBleHBlY3RlZFBhdHRlcm4gPSBgLy8gRXhwZWN0ZWQ6IG1lYW5pbmdmdWwgcmVzdWx0IGJhc2VkIG9uICR7cGFyYW1OYW1lcy5qb2luKCcsICcpfWA7XG4gICAgcmV0dXJuIHsgaW5wdXRzLCBleHBlY3RlZFBhdHRlcm4gfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGhlbHBlcnMgZm9yIHRlc3RzIHRoYXQgbmVlZCB0aGVtXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlRGV0ZXJtaW5pc3RpY0hlbHBlcnModXNlc0RhdGU6IGJvb2xlYW4sIHVzZXNSYW5kb206IGJvb2xlYW4pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgaGVscGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBpZiAodXNlc0RhdGUgfHwgdXNlc1JhbmRvbSkge1xuICAgICAgaGVscGVycy5wdXNoKGAvLyBEZXRlcm1pbmlzdGljIHRlc3QgaGVscGVyc2ApO1xuICAgICAgaGVscGVycy5wdXNoKGBiZWZvcmVFYWNoKCgpID0+IHtgKTtcbiAgICAgIFxuICAgICAgaWYgKHVzZXNEYXRlKSB7XG4gICAgICAgIGhlbHBlcnMucHVzaChgICAvLyBGaXggdGltZSBmb3IgZGV0ZXJtaW5pc3RpYyBEYXRlIGJlaGF2aW9yYCk7XG4gICAgICAgIGhlbHBlcnMucHVzaChgICBqZXN0LnVzZUZha2VUaW1lcnMoKS5zZXRTeXN0ZW1UaW1lKG5ldyBEYXRlKCcyMDIzLTAxLTAxVDAwOjAwOjAwWicpKTtgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHVzZXNSYW5kb20pIHtcbiAgICAgICAgaGVscGVycy5wdXNoKGAgIC8vIFNlZWQgTWF0aC5yYW5kb20gZm9yIGRldGVybWluaXN0aWMgYmVoYXZpb3JgKTtcbiAgICAgICAgaGVscGVycy5wdXNoKGAgIGxldCBzZWVkID0gMTIzNDU7YCk7XG4gICAgICAgIGhlbHBlcnMucHVzaChgICBNYXRoLnJhbmRvbSA9IGplc3QuZm4oKCkgPT4ge2ApO1xuICAgICAgICBoZWxwZXJzLnB1c2goYCAgICBzZWVkID0gKHNlZWQgKiA5MzAxICsgNDkyOTcpICUgMjMzMjgwO2ApO1xuICAgICAgICBoZWxwZXJzLnB1c2goYCAgICByZXR1cm4gc2VlZCAvIDIzMzI4MDtgKTtcbiAgICAgICAgaGVscGVycy5wdXNoKGAgIH0pO2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBoZWxwZXJzLnB1c2goYH0pO2ApO1xuICAgICAgaGVscGVycy5wdXNoKGBgKTtcbiAgICAgIFxuICAgICAgaWYgKHVzZXNEYXRlKSB7XG4gICAgICAgIGhlbHBlcnMucHVzaChgYWZ0ZXJFYWNoKCgpID0+IHtgKTtcbiAgICAgICAgaGVscGVycy5wdXNoKGAgIGplc3QudXNlUmVhbFRpbWVycygpO2ApO1xuICAgICAgICBoZWxwZXJzLnB1c2goYH0pO2ApO1xuICAgICAgICBoZWxwZXJzLnB1c2goYGApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaGVscGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBSZWFjdCBjb21wb25lbnQgdGVzdCB1c2luZyBSZWFjdC5jcmVhdGVFbGVtZW50IChubyBKU1gpXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVJlYWN0Q29tcG9uZW50VGVzdChleHBvcnROYW1lOiBzdHJpbmcsIGJhc2VuYW1lOiBzdHJpbmcsIHVzZVJlYWN0UXVlcnlQcm92aWRlcjogYm9vbGVhbik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByZW5kZXJMaW5lID0gdXNlUmVhY3RRdWVyeVByb3ZpZGVyXG4gICAgICA/IGBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXJzIGFzIGFueSwge30sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50IGFzIGFueSwge30pKSk7YFxuICAgICAgOiBgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCBhcyBhbnksIHt9KSk7YDtcbiAgICByZXR1cm4gW1xuICAgICAgYGRlc2NyaWJlKCcke2V4cG9ydE5hbWV9IENvbXBvbmVudCcsICgpID0+IHtgLFxuICAgICAgYCAgaXQoJ3JlbmRlcnMgd2l0aG91dCBjcmFzaGluZycsICgpID0+IHtgLFxuICAgICAgYCAgICAvLyBSZXNvbHZlIGNvbXBvbmVudCBmcm9tIGV4cG9ydHNgLFxuICAgICAgYCAgICBjb25zdCBDb21wb25lbnQgPSAodGVzdE1vZHVsZSBhcyBhbnkpLmRlZmF1bHQgPz8gKHRlc3RNb2R1bGUgYXMgYW55KVsnJHtleHBvcnROYW1lfSddO2AsXG4gICAgICBgICAgIGV4cGVjdChDb21wb25lbnQpLnRvQmVEZWZpbmVkKCk7YCxcbiAgICAgIGAgICAgLy8gU21va2UgcmVuZGVyIHVzaW5nIFJlYWN0LmNyZWF0ZUVsZW1lbnQgKG5vIEpTWClgLFxuICAgICAgYCAgICAke3JlbmRlckxpbmV9YCxcbiAgICAgIGAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZURlZmluZWQoKTtgLFxuICAgICAgYCAgfSk7YCxcbiAgICAgIGB9KTtgLFxuICAgICAgYGBcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIFJlYWN0IGhvb2sgdGVzdCB1c2luZyB3cmFwcGVyIGNvbXBvbmVudFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVSZWFjdEhvb2tUZXN0KGV4cG9ydE5hbWU6IHN0cmluZywgYmFzZW5hbWU6IHN0cmluZywgdXNlUmVhY3RRdWVyeVByb3ZpZGVyOiBib29sZWFuKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHByb2JlUmVuZGVyID0gdXNlUmVhY3RRdWVyeVByb3ZpZGVyXG4gICAgICA/IGByZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlcnMgYXMgYW55LCB7fSwgUmVhY3QuY3JlYXRlRWxlbWVudChIb29rUHJvYmUpKSlgXG4gICAgICA6IGByZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChIb29rUHJvYmUpKWA7XG4gICAgcmV0dXJuIFtcbiAgICAgIGBkZXNjcmliZSgnJHtleHBvcnROYW1lfSBIb29rJywgKCkgPT4ge2AsXG4gICAgICBgICBpdCgnbW91bnRzIHZpYSBwcm9iZSB3aXRob3V0IGVycm9ycycsICgpID0+IHtgLFxuICAgICAgYCAgICAvLyBDcmVhdGUgaG9vayBwcm9iZSBjb21wb25lbnQgKG5ldmVyIGNhbGwgaG9va3Mgb3V0c2lkZSBhIGNvbXBvbmVudClgLFxuICAgICAgYCAgICBmdW5jdGlvbiBIb29rUHJvYmUoKSB7YCxcbiAgICAgIGAgICAgICBjb25zdCBob29rUmVzdWx0ID0gKHRlc3RNb2R1bGUgYXMgYW55KVsnJHtleHBvcnROYW1lfSddKCk7YCxcbiAgICAgIGAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2JywgeyAnZGF0YS10ZXN0aWQnOiAnaG9vay1yZXN1bHQnIH0sIFN0cmluZyghIWhvb2tSZXN1bHQpKTtgLFxuICAgICAgYCAgICB9YCxcbiAgICAgIGAgICAgY29uc3QgeyBnZXRCeVRlc3RJZCB9ID0gJHtwcm9iZVJlbmRlcn07YCxcbiAgICAgIGAgICAgY29uc3QgcmVzdWx0ID0gZ2V0QnlUZXN0SWQoJ2hvb2stcmVzdWx0Jyk7YCxcbiAgICAgIGAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtgLFxuICAgICAgYCAgfSk7YCxcbiAgICAgIGB9KTtgLFxuICAgICAgYGBcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHVuaXQgdGVzdCBjb250ZW50IGZvciBhIGZpbGUgLSBUeXBlU2NyaXB0IEVTIG1vZHVsZSB3aXRoIFJlYWN0IHN1cHBvcnRcbiAgICog8J+aqUFJOiBFTlRSWV9QT0lOVF9GT1JfR0VORVJBVEVEX1RFU1RfSU1QT1JUUyDigJQgaW5zZXJ0IGBpbXBvcnQgJ3F0ZXN0cy9zZXR1cCdgIGZpcnN0XG4gICAqIPCfmqlBSTogVU5JVF9URU1QTEFURV9TRUNUSU9OIOKAlCB3cml0ZSBwZXItZXhwb3J0IGRlc2NyaWJlL2l0IHdpdGggcG9zaXRpdmUgKyBlZGdlXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVVuaXRUZXN0KGZpbGU6IHN0cmluZywgZXhwb3J0czogc3RyaW5nW10sIHVzZXNRdGVzdHM6IGJvb2xlYW4sIG1vY2tzOiBzdHJpbmdbXSwgY29udGVudDogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlLCBwYXRoLmV4dG5hbWUoZmlsZSkpO1xuICAgIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShmaWxlKTtcbiAgICBcbiAgICBjb25zdCBsaW5lcyA9IFtcbiAgICAgIGAvLyBHZW5lcmF0ZWQgdW5pdCB0ZXN0IGZvciAke3BhdGguYmFzZW5hbWUoZmlsZSl9IC0gVHlwZVNjcmlwdCBFUyBtb2R1bGVgLFxuICAgICAgYC8vIPCfmqlBSTogRU5UUllfUE9JTlRfRk9SX0dFTkVSQVRFRF9URVNUX0lNUE9SVFNgLFxuICAgICAgYGltcG9ydCAncXRlc3RzL3NldHVwJztgLCAvLyBBbHdheXMgaW1wb3J0IHF0ZXN0cy9zZXR1cCBmaXJzdFxuICAgICAgYGBcbiAgICBdO1xuICAgIFxuICAgIC8vIERldGVjdCBpZiB0aGlzIGlzIGEgUmVhY3QgZmlsZSBhbmQgd2hldGhlciBpdCB1c2VzIFJlYWN0IFF1ZXJ5XG4gICAgY29uc3QgaXNSZWFjdEZpbGUgPSB0aGlzLmRldGVjdFJlYWN0VXNhZ2UoZmlsZSwgY29udGVudCk7XG4gICAgY29uc3QgdXNlc1JlYWN0UXVlcnkgPSAvQHRhbnN0YWNrXFwvcmVhY3QtcXVlcnkvLnRlc3QoY29udGVudCk7XG4gICAgY29uc3Qgd2FudHNSb3V0ZXIgPSBCb29sZWFuKCh0aGlzLmNvbmZpZyBhcyBhbnkpLndpdGhSb3V0ZXIpO1xuICAgIGNvbnN0IGRldGVjdHNSb3V0ZXIgPSAvcmVhY3Qtcm91dGVyKD86LWRvbSk/Ly50ZXN0KGNvbnRlbnQpO1xuICAgIGNvbnN0IHVzZXNSZWFjdFJvdXRlciA9IGlzUmVhY3RGaWxlICYmIHdhbnRzUm91dGVyICYmIGRldGVjdHNSb3V0ZXI7XG4gICAgXG4gICAgLy8gSW1wb3J0IHRoZSBtb2R1bGUgYmVpbmcgdGVzdGVkIChubyBleHRlbnNpb24gZm9yIGJldHRlciB0cy1qZXN0IGNvbXBhdGliaWxpdHkpXG4gICAgbGluZXMucHVzaChgaW1wb3J0ICogYXMgdGVzdE1vZHVsZSBmcm9tICcuLyR7YmFzZW5hbWV9JztgKTtcbiAgICBcbiAgICAvLyBBZGQgUmVhY3QgaW1wb3J0cyBpZiBuZWVkZWRcbiAgICBpZiAoaXNSZWFjdEZpbGUpIHtcbiAgICAgIGxpbmVzLnB1c2goYGltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztgKTtcbiAgICAgIGxpbmVzLnB1c2goYGltcG9ydCB7IHJlbmRlciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO2ApO1xuICAgICAgaWYgKHVzZXNSZWFjdFJvdXRlcikge1xuICAgICAgICAvLyBQcmVmZXIgbWF0Y2hpbmcgdGhlIGltcG9ydGVkIG1vZHVsZSBmcm9tIHNvdXJjZSB3aGVuIHBvc3NpYmxlXG4gICAgICAgIGNvbnN0IHJvdXRlck1vZHVsZSA9IGNvbnRlbnQuaW5jbHVkZXMoJ3JlYWN0LXJvdXRlci1kb20nKSA/ICdyZWFjdC1yb3V0ZXItZG9tJyA6ICdyZWFjdC1yb3V0ZXInO1xuICAgICAgICBsaW5lcy5wdXNoKGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgfSBmcm9tICcke3JvdXRlck1vZHVsZX0nO2ApO1xuICAgICAgfVxuICAgICAgaWYgKHVzZXNSZWFjdFF1ZXJ5KSB7XG4gICAgICAgIGxpbmVzLnB1c2goYGltcG9ydCB7IFF1ZXJ5Q2xpZW50LCBRdWVyeUNsaWVudFByb3ZpZGVyIH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5JztgKTtcbiAgICAgIH1cbiAgICAgIGlmICh1c2VzUmVhY3RRdWVyeSB8fCB1c2VzUmVhY3RSb3V0ZXIpIHtcbiAgICAgICAgLy8gQ29tcG9zZSBwcm92aWRlcnMgZGV0ZXJtaW5pc3RpY2FsbHk6IE1lbW9yeVJvdXRlciAob3V0ZXIpIC0+IFF1ZXJ5Q2xpZW50UHJvdmlkZXIgKGlubmVyKVxuICAgICAgICBsaW5lcy5wdXNoKGAvLyBNaW5pbWFsIHByb3ZpZGVyIGNvbXBvc2l0aW9uIGZvciB0ZXN0c2ApO1xuICAgICAgICBsaW5lcy5wdXNoKGBjb25zdCBQcm92aWRlcnM6IFJlYWN0LkZDPHsgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7YCk7XG4gICAgICAgIGlmICh1c2VzUmVhY3RRdWVyeSkge1xuICAgICAgICAgIGxpbmVzLnB1c2goYCAgY29uc3QgY2xpZW50ID0gbmV3IFF1ZXJ5Q2xpZW50KCk7YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXNSZWFjdFJvdXRlciAmJiB1c2VzUmVhY3RRdWVyeSkge1xuICAgICAgICAgIGxpbmVzLnB1c2goYCAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb3J5Um91dGVyIGFzIGFueSwge30sIGApO1xuICAgICAgICAgIGxpbmVzLnB1c2goYCAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFF1ZXJ5Q2xpZW50UHJvdmlkZXIgYXMgYW55LCB7IGNsaWVudCB9LCBjaGlsZHJlbiBhcyBhbnkpYCk7XG4gICAgICAgICAgbGluZXMucHVzaChgICApO2ApO1xuICAgICAgICB9IGVsc2UgaWYgKHVzZXNSZWFjdFJvdXRlcikge1xuICAgICAgICAgIGxpbmVzLnB1c2goYCAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb3J5Um91dGVyIGFzIGFueSwge30sIGNoaWxkcmVuIGFzIGFueSk7YCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXNlc1JlYWN0UXVlcnkpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKGAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFF1ZXJ5Q2xpZW50UHJvdmlkZXIgYXMgYW55LCB7IGNsaWVudCB9LCBjaGlsZHJlbiBhcyBhbnkpO2ApO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzLnB1c2goYH07YCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBjb25zb2xlIGNhcHR1cmUgaWYgbmVlZGVkXG4gICAgaWYgKHVzZXNRdGVzdHMpIHtcbiAgICAgIGxpbmVzLnB1c2goYGltcG9ydCB7IG1vY2tDb25zb2xlIH0gZnJvbSAncXRlc3RzJztgKTtcbiAgICB9XG4gICAgXG4gICAgbGluZXMucHVzaChgYCk7XG4gICAgXG4gICAgLy8gUmVwbGFjZSBqZXN0Lm1vY2sgd2l0aCBxdGVzdHMgc3R1YiBjb21tZW50cyBmb3Iga25vd24gbGlicmFyaWVzXG4gICAgaWYgKG1vY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxpbmVzLnB1c2goYC8vIEV4dGVybmFsIGRlcGVuZGVuY2llcyBhdXRvbWF0aWNhbGx5IHN0dWJiZWQgYnkgcXRlc3RzL3NldHVwOmApO1xuICAgICAgbW9ja3MuZm9yRWFjaChsaWIgPT4ge1xuICAgICAgICBsaW5lcy5wdXNoKGAvLyAtICR7bGlifTogc3R1YmJlZCBieSBxdGVzdHMgKG5vIGplc3QubW9jayBuZWVkZWQpYCk7XG4gICAgICB9KTtcbiAgICAgIGxpbmVzLnB1c2goYGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgZGV0ZXJtaW5pc3RpYyBoZWxwZXJzIGlmIHRoZSBzb3VyY2UgY29kZSB1c2VzIERhdGUgb3IgTWF0aC5yYW5kb21cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgY29uc3QgeyB1c2VzRGF0ZSwgdXNlc1JhbmRvbSB9ID0gdGhpcy5kZXRlY3ROb25EZXRlcm1pbmlzdGljQ29kZShjb250ZW50KTtcbiAgICAgIGNvbnN0IGRldGVybWluaXN0aWNIZWxwZXJzID0gdGhpcy5nZW5lcmF0ZURldGVybWluaXN0aWNIZWxwZXJzKHVzZXNEYXRlLCB1c2VzUmFuZG9tKTtcbiAgICAgIGRldGVybWluaXN0aWNIZWxwZXJzLmZvckVhY2goaGVscGVyID0+IGxpbmVzLnB1c2goaGVscGVyKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdlbmVyYXRlIHRlc3RzIHBlciBleHBvcnQgd2l0aCBSZWFjdC1hd2FyZSB0ZW1wbGF0ZXNcbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICBleHBvcnRzLmZvckVhY2goZXhwb3J0TmFtZSA9PiB7XG4gICAgICAgIGlmIChpc1JlYWN0RmlsZSAmJiB0aGlzLmlzUmVhY3RIb29rKGV4cG9ydE5hbWUpKSB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgUmVhY3QgaG9vayB0ZXN0XG4gICAgICAgICAgY29uc3QgaG9va1Rlc3RMaW5lcyA9IHRoaXMuY3JlYXRlUmVhY3RIb29rVGVzdChleHBvcnROYW1lLCBiYXNlbmFtZSwgdXNlc1JlYWN0UXVlcnkgfHwgdXNlc1JlYWN0Um91dGVyKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKC4uLmhvb2tUZXN0TGluZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVhY3RGaWxlICYmIHRoaXMuaXNSZWFjdENvbXBvbmVudChleHBvcnROYW1lLCBjb250ZW50KSkge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudCBhcHBlYXJzIHRvIHJlcXVpcmUgcHJvcHMsIGZhbGwgYmFjayB0byBzYWZlIG1vZHVsZS9leGlzdHMgdGVzdFxuICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFJlcXVpcmVzUHJvcHMoZXhwb3J0TmFtZSwgY29udGVudCkpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYGRlc2NyaWJlKCcke2V4cG9ydE5hbWV9IENvbXBvbmVudCcsICgpID0+IHtgKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgaXQoJ2lzIGRlZmluZWQgKGZhbGxiYWNrOiByZXF1aXJlZCBwcm9wcyBkZXRlY3RlZCknLCAoKSA9PiB7YCk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGAgICAgY29uc3QgQ29tcG9uZW50ID0gKHRlc3RNb2R1bGUgYXMgYW55KS5kZWZhdWx0ID8/ICh0ZXN0TW9kdWxlIGFzIGFueSlbJyR7ZXhwb3J0TmFtZX0nXTtgKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgICBleHBlY3QoQ29tcG9uZW50KS50b0JlRGVmaW5lZCgpO2ApO1xuICAgICAgICAgICAgbGluZXMucHVzaChgICB9KTtgKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYH0pO2ApO1xuICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIFJlYWN0IGNvbXBvbmVudCB0ZXN0XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRUZXN0TGluZXMgPSB0aGlzLmNyZWF0ZVJlYWN0Q29tcG9uZW50VGVzdChleHBvcnROYW1lLCBiYXNlbmFtZSwgdXNlc1JlYWN0UXVlcnkgfHwgdXNlc1JlYWN0Um91dGVyKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goLi4uY29tcG9uZW50VGVzdExpbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgc2FmZSBleGlzdGVuY2UgdGVzdCBvbmx5IChubyBmYWtlIGZ1bmN0aW9uIGNhbGxzKVxuICAgICAgICAgIGxpbmVzLnB1c2goYGRlc2NyaWJlKCcke2V4cG9ydE5hbWV9JywgKCkgPT4ge2ApO1xuICAgICAgICAgIGxpbmVzLnB1c2goYCAgaXQoJ2lzIGRlZmluZWQnLCAoKSA9PiB7YCk7XG4gICAgICAgICAgbGluZXMucHVzaChgICAgIGV4cGVjdCh0ZXN0TW9kdWxlLiR7ZXhwb3J0TmFtZX0pLnRvQmVEZWZpbmVkKCk7YCk7XG4gICAgICAgICAgbGluZXMucHVzaChgICB9KTtgKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGB9KTtgKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRlc3Qgd2hlbiBubyBleHBvcnRzIGRldGVjdGVkXG4gICAgICBsaW5lcy5wdXNoKGBkZXNjcmliZSgnJHtwYXRoLmJhc2VuYW1lKGZpbGUpfSBtb2R1bGUnLCAoKSA9PiB7YCk7XG4gICAgICBsaW5lcy5wdXNoKGAgIGl0KCdzaG91bGQgbG9hZCB3aXRob3V0IGVycm9ycycsIGFzeW5jICgpID0+IHtgKTtcbiAgICAgIGxpbmVzLnB1c2goYCAgICBleHBlY3QodGVzdE1vZHVsZSkudG9CZURlZmluZWQoKTtgKTtcbiAgICAgIGxpbmVzLnB1c2goYCAgICBleHBlY3QodHlwZW9mIHRlc3RNb2R1bGUpLnRvQmUoJ29iamVjdCcpO2ApO1xuICAgICAgbGluZXMucHVzaChgICB9KTtgKTtcbiAgICAgIGxpbmVzLnB1c2goYH0pO2ApO1xuICAgICAgbGluZXMucHVzaChgYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBBUEkgdGVzdCBjb250ZW50IGZvciBhbiBlbmRwb2ludCAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHlcbiAgICog8J+aqUFJOiBJTlRFR1JBVElPTl9URU1QTEFURV9TRUNUSU9OIOKAlCBjcmVhdGVNb2NrQXBwICsgc3VwZXJ0ZXN0ICsgZmFpbHVyZSBwYXRoXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUFwaVRlc3QobWV0aG9kOiBzdHJpbmcsIHJvdXRlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGxpbmVzID0gW1xuICAgICAgYC8vIEdlbmVyYXRlZCBpbnRlZ3JhdGlvbiB0ZXN0IGZvciAke21ldGhvZC50b1VwcGVyQ2FzZSgpfSAke3JvdXRlfSAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlYCxcbiAgICAgIGAvLyDwn5qpQUk6IEVOVFJZX1BPSU5UX0ZPUl9HRU5FUkFURURfVEVTVF9JTVBPUlRTYCxcbiAgICAgIGBpbXBvcnQgJ3F0ZXN0cy9zZXR1cCc7YCwgLy8gQWx3YXlzIGltcG9ydCBxdGVzdHMvc2V0dXAgZmlyc3RcbiAgICAgIGBgXG4gICAgXTtcbiAgICBcbiAgICAvLyBJbXBvcnQgdGVzdGluZyB1dGlsaXRpZXMgKG9taXQgZXh0ZW5zaW9uIGZvciB0cy1qZXN0IGNvbXBhdGliaWxpdHkpXG4gICAgbGluZXMucHVzaChgaW1wb3J0IHsgY3JlYXRlTW9ja0FwcCwgc3VwZXJ0ZXN0IH0gZnJvbSAnLi4vdXRpbHMvaHR0cFRlc3QnO2ApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIFxuICAgIC8vIPCfmqlBSTogREVURVJNSU5JU01fSEVMUEVSUyDigJQgZmFrZSB0aW1lcnMgYW5kIHNlZWRlZCByYW5kb21uZXNzIHNjYWZmb2xkaW5nXG4gICAgbGluZXMucHVzaChgLy8gRGV0ZXJtaW5pc3RpYyB0ZXN0IGhlbHBlcnNgKTtcbiAgICBsaW5lcy5wdXNoKGBiZWZvcmVFYWNoKCgpID0+IHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgIC8vIFVzZSBmYWtlIHRpbWVycyBmb3IgZGV0ZXJtaW5pc3RpYyB0aW1lLWJhc2VkIGJlaGF2aW9yYCk7XG4gICAgbGluZXMucHVzaChgICBqZXN0LnVzZUZha2VUaW1lcnMoKS5zZXRTeXN0ZW1UaW1lKG5ldyBEYXRlKCcyMDIzLTAxLTAxVDAwOjAwOjAwWicpKTtgKTtcbiAgICBsaW5lcy5wdXNoKGB9KTtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBsaW5lcy5wdXNoKGBhZnRlckVhY2goKCkgPT4ge2ApO1xuICAgIGxpbmVzLnB1c2goYCAgamVzdC51c2VSZWFsVGltZXJzKCk7YCk7XG4gICAgbGluZXMucHVzaChgfSk7YCk7XG4gICAgbGluZXMucHVzaChgYCk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdW5pcXVlIHRlc3Qgc2Vzc2lvbiBmb3IgQVBJIGlzb2xhdGlvblxuICAgIGxpbmVzLnB1c2goYC8vIERldGVybWluaXN0aWMgdW5pcXVlIHJvdXRlIGZvciBwYXJhbGxlbCB0ZXN0IHNhZmV0eWApO1xuICAgIGxpbmVzLnB1c2goYGNvbnN0IHRlc3RIYXNoID0gcmVxdWlyZSgnY3J5cHRvJykuY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKCcke3JvdXRlfScpLmRpZ2VzdCgnaGV4Jykuc2xpY2UoMCwgOCk7YCk7XG4gICAgbGluZXMucHVzaChgY29uc3QgdW5pcXVlUm91dGUgPSAnJHtyb3V0ZX0nICsgKCcke3JvdXRlfScuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JykgKyAndGVzdElkPScgKyB0ZXN0SGFzaDtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBcbiAgICAvLyBUeXBlU2NyaXB0IHRlc3Qgc3VpdGVcbiAgICBsaW5lcy5wdXNoKGBkZXNjcmliZSgnJHttZXRob2QudG9VcHBlckNhc2UoKX0gJHtyb3V0ZX0nLCAoKSA9PiB7YCk7XG4gICAgbGluZXMucHVzaChgICBsZXQgYXBwOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVNb2NrQXBwPjtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBsaW5lcy5wdXNoKGAgIGJlZm9yZUVhY2goKCkgPT4ge2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICBhcHAgPSBjcmVhdGVNb2NrQXBwKCk7YCk7XG4gICAgbGluZXMucHVzaChgICB9KTtgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBcbiAgICAvLyBTdWNjZXNzIHRlc3QgY2FzZVxuICAgIGxpbmVzLnB1c2goYCAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyByZXNwb25zZScsIGFzeW5jICgpID0+IHtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgLy8gU2V0dXAgcm91dGUgaGFuZGxlcmApO1xuICAgIGxpbmVzLnB1c2goYCAgICBhcHAuJHttZXRob2QudG9Mb3dlckNhc2UoKX0odW5pcXVlUm91dGUsIChyZXEsIHJlcykgPT4ge2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIHJlcy5zdGF0dXNDb2RlID0gMjAwO2ApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgIHJlcy5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7YCk7XG4gICAgbGluZXMucHVzaChgICAgICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7YCk7XG4gICAgbGluZXMucHVzaChgICAgICAgICBzdWNjZXNzOiB0cnVlLGApO1xuICAgIGxpbmVzLnB1c2goYCAgICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseSdgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgICB9KSk7YCk7XG4gICAgbGluZXMucHVzaChgICAgIH0pO2ApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIGxpbmVzLnB1c2goYCAgICAvLyBFeGVjdXRlIHRlc3RgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgY29uc3QgcmVzID0gYXdhaXQgc3VwZXJ0ZXN0KGFwcClgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgICAuJHttZXRob2QudG9Mb3dlckNhc2UoKX0odW5pcXVlUm91dGUpYCk7XG4gICAgaWYgKG1ldGhvZC50b0xvd2VyQ2FzZSgpICE9PSAnZ2V0Jykge1xuICAgICAgbGluZXMucHVzaChgICAgICAgLnNlbmQoeyB0ZXN0RGF0YTogJ3ZhbGlkIGlucHV0JyB9KWApO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKGAgICAgICAuZXhwZWN0KDIwMCk7YCk7XG4gICAgbGluZXMucHVzaChgYCk7XG4gICAgbGluZXMucHVzaChgICAgIC8vIFZlcmlmeSByZXNwb25zZWApO1xuICAgIGxpbmVzLnB1c2goYCAgICBleHBlY3QocmVzLmJvZHkuc3VjY2VzcykudG9CZSh0cnVlKTtgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgZXhwZWN0KHJlcy5ib2R5Lm1lc3NhZ2UpLnRvQmUoJ1JlcXVlc3QgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseScpO2ApO1xuICAgIGxpbmVzLnB1c2goYCAgfSk7YCk7XG4gICAgbGluZXMucHVzaChgYCk7XG4gICAgXG4gICAgLy8gRmFpbHVyZSB0ZXN0IGNhc2UgIFxuICAgIGxpbmVzLnB1c2goYCAgaXQoJ3Nob3VsZCBoYW5kbGUgbm90IGZvdW5kIGNhc2UnLCBhc3luYyAoKSA9PiB7YCk7XG4gICAgbGluZXMucHVzaChgICAgIC8vIERvbid0IHNldHVwIGFueSByb3V0ZSBoYW5kbGVycyB0byBzaW11bGF0ZSA0MDRgKTtcbiAgICBsaW5lcy5wdXNoKGBgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgLy8gRXhlY3V0ZSB0ZXN0YCk7XG4gICAgbGluZXMucHVzaChgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHN1cGVydGVzdChhcHApYCk7XG4gICAgbGluZXMucHVzaChgICAgICAgLiR7bWV0aG9kLnRvTG93ZXJDYXNlKCl9KCcvbm9uZXhpc3RlbnQtcm91dGUnKWApO1xuICAgIGlmIChtZXRob2QudG9Mb3dlckNhc2UoKSAhPT0gJ2dldCcpIHtcbiAgICAgIGxpbmVzLnB1c2goYCAgICAgIC5zZW5kKHsgdGVzdERhdGE6ICdhbnkgZGF0YScgfSlgKTtcbiAgICB9XG4gICAgbGluZXMucHVzaChgICAgICAgLmV4cGVjdCg0MDQpO2ApO1xuICAgIGxpbmVzLnB1c2goYGApO1xuICAgIGxpbmVzLnB1c2goYCAgICAvLyBWZXJpZnkgZXJyb3IgcmVzcG9uc2VgKTtcbiAgICBsaW5lcy5wdXNoKGAgICAgZXhwZWN0KHJlcy5ib2R5LmVycm9yKS50b0JlKCdOb3QgRm91bmQnKTtgKTtcbiAgICBsaW5lcy5wdXNoKGAgIH0pO2ApO1xuICAgIGxpbmVzLnB1c2goYH0pO2ApO1xuICAgIGxpbmVzLnB1c2goJycpO1xuICAgIFxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlbGxpZ2VudGx5IGV4dHJhY3QgZXhwb3J0cyBmcm9tIGJvdGggRVMgbW9kdWxlcyBhbmQgQ29tbW9uSlNcbiAgICovXG4gIHByaXZhdGUgZXh0cmFjdEV4cG9ydHMoY29udGVudDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGV4cG9ydHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgY29tbWVudHMgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzXG4gICAgY29uc3QgY2xlYW5Db250ZW50ID0gY29udGVudFxuICAgICAgLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vZywgJycpIC8vIFJlbW92ZSAvKiAqLyBjb21tZW50c1xuICAgICAgLnJlcGxhY2UoL1xcL1xcLy4qJC9nbSwgJycpOyAvLyBSZW1vdmUgLy8gY29tbWVudHNcbiAgICBcbiAgICAvLyBFeHRyYWN0IEVTIG1vZHVsZSBleHBvcnRzIChleHBvcnQgY29uc3QvZnVuY3Rpb24vY2xhc3MpXG4gICAgY29uc3QgZXNFeHBvcnRzID0gWy4uLmNsZWFuQ29udGVudC5tYXRjaEFsbChQQVRURVJOUy5leHBvcnRzRVMpXTtcbiAgICBlc0V4cG9ydHMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2hbMV0pIGV4cG9ydHMuYWRkKG1hdGNoWzFdKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IEVTIG1vZHVsZSBuYW1lZCBleHBvcnRzOiBleHBvcnQgeyBuYW1lMSwgbmFtZTIsIG5hbWUzIH1cbiAgICBjb25zdCBuYW1lZEV4cG9ydHMgPSBbLi4uY2xlYW5Db250ZW50Lm1hdGNoQWxsKFBBVFRFUk5TLmV4cG9ydHNOYW1lZCldO1xuICAgIG5hbWVkRXhwb3J0cy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgbmFtZWQgZXhwb3J0cyBsaXN0XG4gICAgICAgIGNvbnN0IGV4cG9ydExpc3QgPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKTtcbiAgICAgICAgZXhwb3J0TGlzdC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgIC8vIEhhbmRsZSBwb3RlbnRpYWwgYWxpYXNlczogXCJuYW1lIGFzIGFsaWFzXCIgLT4gdXNlIFwibmFtZVwiXG4gICAgICAgICAgY29uc3QgY2xlYW5OYW1lID0gbmFtZS5zcGxpdCgnIGFzICcpWzBdLnRyaW0oKTtcbiAgICAgICAgICBpZiAoY2xlYW5OYW1lICYmIC9eW2EtekEtWjAtOV9dKyQvLnRlc3QoY2xlYW5OYW1lKSkge1xuICAgICAgICAgICAgZXhwb3J0cy5hZGQoY2xlYW5OYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgRVMgbW9kdWxlIGRlZmF1bHQgZXhwb3J0czogZXhwb3J0IGRlZmF1bHQgU29tZU5hbWVcbiAgICBjb25zdCBkZWZhdWx0RXhwb3J0cyA9IFsuLi5jbGVhbkNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuZXhwb3J0c0RlZmF1bHQpXTtcbiAgICBkZWZhdWx0RXhwb3J0cy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkgZXhwb3J0cy5hZGQobWF0Y2hbMV0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgQ29tbW9uSlMgZXhwb3J0c1xuICAgIGNvbnN0IGNvbW1vbkpTRXhwb3J0cyA9IFsuLi5jbGVhbkNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuZXhwb3J0c0NvbW1vbkpTKV07XG4gICAgY29tbW9uSlNFeHBvcnRzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgLy8gbWF0Y2hbMV0gPSBtb2R1bGUuZXhwb3J0cy5uYW1lLCBtYXRjaFsyXSA9IGV4cG9ydHMubmFtZSwgbWF0Y2hbM10gPSBzaW5nbGUgYXNzaWdubWVudFxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgICAgIGlmIChtYXRjaFtpXSkgZXhwb3J0cy5hZGQobWF0Y2hbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBtb2R1bGUuZXhwb3J0cyA9IHsgbmFtZTEsIG5hbWUyLCAuLi4gfSBwYXR0ZXJuXG4gICAgY29uc3Qgb2JqZWN0RXhwb3J0TWF0Y2ggPSBjbGVhbkNvbnRlbnQubWF0Y2goL21vZHVsZVxcLmV4cG9ydHNcXHMqPVxccypcXHsoW159XSspXFx9Lyk7XG4gICAgaWYgKG9iamVjdEV4cG9ydE1hdGNoKSB7XG4gICAgICBjb25zdCBvYmplY3RDb250ZW50ID0gb2JqZWN0RXhwb3J0TWF0Y2hbMV07XG4gICAgICBjb25zdCBwcm9wZXJ0eU1hdGNoZXMgPSBvYmplY3RDb250ZW50Lm1hdGNoQWxsKC9cXGIoXFx3KykoPzpcXHMqOlxccypcXHcrKT9cXHMqWyx9XS9nKTtcbiAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgcHJvcGVydHlNYXRjaGVzKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSkgZXhwb3J0cy5hZGQobWF0Y2hbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gQXJyYXkuZnJvbShleHBvcnRzKS5maWx0ZXIobmFtZSA9PiBuYW1lICYmIG5hbWUubGVuZ3RoID4gMCk7XG4gIH1cblxuICAvKipcbiAgICogQW5hbHl6ZSBhIHNpbmdsZSBmaWxlIGFuZCBnZW5lcmF0ZSBhcHByb3ByaWF0ZSB0ZXN0cyAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHlcbiAgICovXG4gIGFzeW5jIGFuYWx5emUoZmlsZTogc3RyaW5nLCBkcnlSdW46IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShmaWxlKTtcbiAgICBpZiAoIXRoaXMuY29uZmlnLlZBTElEX0VYVFMuaW5jbHVkZXMoZXh0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICBjb25zdCB1c2VzUXRlc3RzID0gUEFUVEVSTlMucXRlc3RzLnRlc3QoY29udGVudCk7XG4gICAgY29uc3QgaW1wb3J0cyA9IHRoaXMuZ2V0VXNlZE1vZHVsZXMoY29udGVudCk7XG4gICAgY29uc3QgbW9ja1RhcmdldHMgPSBpbXBvcnRzLmZpbHRlcihpID0+IFxuICAgICAgdGhpcy5jb25maWcuS05PV05fTU9DS1MuaW5jbHVkZXMoaSkgJiYgaSAhPT0gJ3F0ZXN0cydcbiAgICApO1xuXG4gICAgLy8gVXNlIGludGVsbGlnZW50IGV4cG9ydCBkZXRlY3Rpb24gZm9yIGJvdGggRVMgbW9kdWxlcyBhbmQgQ29tbW9uSlNcbiAgICBsZXQgZXhwb3J0cyA9IHRoaXMuZXh0cmFjdEV4cG9ydHMoY29udGVudCk7XG4gICAgLy8gSWYgQVNUIG1vZGUgcmVxdWVzdGVkLCBhdHRlbXB0IHRvIGF1Z21lbnQgZXhwb3J0cyB2aWEgVHlwZVNjcmlwdCBwYXJzZXJcbiAgICBpZiAodGhpcy5jb25maWcubW9kZSA9PT0gJ2FzdCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFzdEluZm8gPSBhd2FpdCB0aGlzLnRyeVR5cGVTY3JpcHRBbmFseXNpcyhmaWxlLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGFzdEluZm8gJiYgQXJyYXkuaXNBcnJheShhc3RJbmZvLmZ1bmN0aW9ucykpIHtcbiAgICAgICAgICBjb25zdCBhc3RFeHBvcnRzID0gYXN0SW5mby5mdW5jdGlvbnMubWFwKGZuID0+IGZuLm5hbWUpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICBleHBvcnRzID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi4oZXhwb3J0cyB8fCBbXSksIC4uLmFzdEV4cG9ydHNdKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBTd2FsbG93IEFTVCBlcnJvcnMgYW5kIHByb2NlZWQgd2l0aCBoZXVyaXN0aWNcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoID4gMCAmJiAoIXRoaXMuY29uZmlnLmludGVncmF0aW9uKSkge1xuICAgICAgY29uc3QgdGVzdFBhdGggPSB0aGlzLmdldFJlbGF0aXZlVGVzdFBhdGgoZmlsZSwgJ3VuaXQnLCBjb250ZW50KTtcbiAgICAgIGNvbnN0IGNyZWF0ZWQgPSB0aGlzLndyaXRlSWZNaXNzaW5nKFxuICAgICAgICB0ZXN0UGF0aCwgXG4gICAgICAgIHRoaXMuY3JlYXRlVW5pdFRlc3QoZmlsZSwgZXhwb3J0cywgdXNlc1F0ZXN0cywgbW9ja1RhcmdldHMsIGNvbnRlbnQpLFxuICAgICAgICBkcnlSdW5cbiAgICAgICk7XG4gICAgICBpZiAoY3JlYXRlZCkge1xuICAgICAgICB0aGlzLnNjYW5uZWQucHVzaCh7IFxuICAgICAgICAgIHR5cGU6ICd1bml0JywgXG4gICAgICAgICAgZmlsZTogcGF0aC5yZWxhdGl2ZSgnLicsIHRlc3RQYXRoKSBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgQVBJIHRlc3RzIGZvciBkZXRlY3RlZCByb3V0ZXMgLSBUeXBlU2NyaXB0IG9ubHlcbiAgICBjb25zdCBhcGlzID0gWy4uLmNvbnRlbnQubWF0Y2hBbGwoUEFUVEVSTlMuYXBpKV07XG4gICAgaWYgKGFwaXMubGVuZ3RoID4gMCAmJiAoIXRoaXMuY29uZmlnLnVuaXQpKSB7XG4gICAgICBmb3IgKGNvbnN0IFssICwgbWV0aG9kLCByb3V0ZV0gb2YgYXBpcykge1xuICAgICAgICBjb25zdCB0ZXN0UGF0aCA9IHRoaXMuZ2V0UmVsYXRpdmVUZXN0UGF0aChmaWxlLCAnYXBpJywgY29udGVudClcbiAgICAgICAgICAucmVwbGFjZSgvXFwuR2VuZXJhdGVUZXN0XFwudGVzdFxcLih0c3x0c3gpJC8sIGAuR2VuZXJhdGVUZXN0X18ke21ldGhvZC50b0xvd2VyQ2FzZSgpfS50ZXN0LiQxYCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSB0aGlzLndyaXRlSWZNaXNzaW5nKFxuICAgICAgICAgIHRlc3RQYXRoLCBcbiAgICAgICAgICB0aGlzLmNyZWF0ZUFwaVRlc3QobWV0aG9kLCByb3V0ZSksXG4gICAgICAgICAgZHJ5UnVuXG4gICAgICAgICk7XG4gICAgICAgIC8vIElmIGFuIEFQSSB0ZXN0IHdhcyBjcmVhdGVkLCBlbnN1cmUgbG9jYWwgaHR0cFRlc3QgdXRpbGl0aWVzIGV4aXN0IChpZGVtcG90ZW50KVxuICAgICAgICBpZiAoY3JlYXRlZCAmJiAhZHJ5UnVuKSB7XG4gICAgICAgICAgdGhpcy5lbnN1cmVMb2NhbEh0dHBUZXN0VXRpbHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlYXRlZCkge1xuICAgICAgICAgIHRoaXMuc2Nhbm5lZC5wdXNoKHsgXG4gICAgICAgICAgICB0eXBlOiAnYXBpJywgXG4gICAgICAgICAgICBmaWxlOiBwYXRoLnJlbGF0aXZlKCcuJywgdGVzdFBhdGgpIFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBwcm9qZWN0IHVzZXMgUmVhY3QgYmFzZWQgb24gZGVwZW5kZW5jaWVzIGFuZCBzb3VyY2UgZmlsZXNcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0UmVhY3RQcm9qZWN0KCk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBIb25vciBmb3JjZWQgUmVhY3QgbW9kZSBpZiBwcm92aWRlZCB2aWEgQ0xJXG4gICAgICBpZiAoKHRoaXMuY29uZmlnIGFzIGFueSkucmVhY3QpIHJldHVybiB0cnVlO1xuICAgICAgLy8gQ2hlY2sgcGFja2FnZS5qc29uIGZvciBSZWFjdCBkZXBlbmRlbmNpZXNcbiAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwYWNrYWdlLmpzb24nKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBhY2thZ2VQYXRoKSkge1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgY29uc3QgYWxsRGVwcyA9IHtcbiAgICAgICAgICAuLi5wYWNrYWdlSnNvbi5kZXBlbmRlbmNpZXMsXG4gICAgICAgICAgLi4ucGFja2FnZUpzb24uZGV2RGVwZW5kZW5jaWVzLFxuICAgICAgICAgIC4uLnBhY2thZ2VKc29uLnBlZXJEZXBlbmRlbmNpZXNcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlYWN0RGVwcyA9IFsncmVhY3QnLCAnQHR5cGVzL3JlYWN0JywgJ3JlYWN0LWRvbScsICdAdHlwZXMvcmVhY3QtZG9tJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JywgJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSddO1xuICAgICAgICBpZiAocmVhY3REZXBzLnNvbWUoZGVwID0+IGFsbERlcHNbZGVwXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTY2FuIGZvciAudHN4IGZpbGVzIG9yIFJlYWN0IGltcG9ydHMgaW4gc291cmNlIGNvZGVcbiAgICAgIGNvbnN0IGFsbEZpbGVzID0gdGhpcy53YWxrUHJvamVjdCgpO1xuICAgICAgcmV0dXJuIGFsbEZpbGVzLnNvbWUoZmlsZSA9PiB7XG4gICAgICAgIGlmIChmaWxlLmVuZHNXaXRoKCcudHN4JykgfHwgZmlsZS5lbmRzV2l0aCgnLmpzeCcpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdFJlYWN0VXNhZ2UoZmlsZSwgY29udGVudCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBKZXN0IGNvbmZpZ3VyYXRpb24gYW5kIHNldHVwIGZpbGVzIC0gUmVhY3QtYXdhcmUgVHlwZVNjcmlwdCBFUyBNb2R1bGVcbiAgICovXG4gIHNjYWZmb2xkSmVzdFNldHVwKCk6IHZvaWQge1xuICAgIGNvbnN0IGlzUmVhY3RQcm9qZWN0ID0gdGhpcy5kZXRlY3RSZWFjdFByb2plY3QoKTtcbiAgICAvLyBHZW5lcmF0ZSBKZXN0IGNvbmZpZyBmb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGVzIHdpdGggUmVhY3Qgc3VwcG9ydFxuICAgIGNvbnN0IGV4dGVuc2lvbnNUb1RyZWF0QXNFc20gPSBpc1JlYWN0UHJvamVjdCA/IFsnLnRzJywgJy50c3gnXSA6IFsnLnRzJ107XG4gICAgY29uc3QgbW9kdWxlRmlsZUV4dGVuc2lvbnMgPSBpc1JlYWN0UHJvamVjdCA/IFsndHMnLCAndHN4JywgJ2pzJywgJ2pzeCcsICdqc29uJ10gOiBbJ3RzJywgJ2pzJywgJ2pzb24nXTtcbiAgICBjb25zdCB0ZXN0RW52aXJvbm1lbnQgPSBpc1JlYWN0UHJvamVjdCA/ICdqc2RvbScgOiAnbm9kZSc7XG4gICAgY29uc3QgdGVzdE1hdGNoUGF0dGVybnMgPSBpc1JlYWN0UHJvamVjdCBcbiAgICAgID8gW1xuICAgICAgICAgICcqKi8qLnRlc3QudHMnLFxuICAgICAgICAgICcqKi8qLnRlc3QudHN4JyxcbiAgICAgICAgICAnKiovKi5HZW5lcmF0ZVRlc3QudGVzdC50cycsXG4gICAgICAgICAgJyoqLyouR2VuZXJhdGVUZXN0LnRlc3QudHN4JyxcbiAgICAgICAgICAnKiovbWFudWFsLXRlc3RzLyoqLyoudGVzdC50cycsXG4gICAgICAgICAgJyoqL2dlbmVyYXRlZC10ZXN0cy8qKi8qLnRlc3QudHMnXG4gICAgICAgIF1cbiAgICAgIDogW1xuICAgICAgICAgICcqKi8qLnRlc3QudHMnLFxuICAgICAgICAgICcqKi8qLkdlbmVyYXRlVGVzdC50ZXN0LnRzJyxcbiAgICAgICAgICAnKiovbWFudWFsLXRlc3RzLyoqLyoudGVzdC50cycsXG4gICAgICAgICAgJyoqL2dlbmVyYXRlZC10ZXN0cy8qKi8qLnRlc3QudHMnXG4gICAgICAgIF07XG4gICAgXG4gICAgY29uc3QgdHJhbnNmb3JtQ29uZmlnID0gaXNSZWFjdFByb2plY3QgXG4gICAgICA/IHtcbiAgICAgICAgICAnXi4rXFxcXC50c3g/JCc6IFsndHMtamVzdCcsIHtcbiAgICAgICAgICAgIHVzZUVTTTogdHJ1ZSxcbiAgICAgICAgICAgIGlzb2xhdGVkTW9kdWxlczogdHJ1ZSxcbiAgICAgICAgICAgIHRzY29uZmlnOiB7XG4gICAgICAgICAgICAgIGpzeDogJ3JlYWN0LWpzeCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgICAnXi4rXFxcXC50c3g/JCc6IFsndHMtamVzdCcsIHtcbiAgICAgICAgICAgIHVzZUVTTTogdHJ1ZSxcbiAgICAgICAgICAgIGlzb2xhdGVkTW9kdWxlczogdHJ1ZVxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgXG4gICAgY29uc3QgY29uZmlnID0gYFxuLy8gamVzdC5jb25maWcuanMgLSBUeXBlU2NyaXB0IEVTIE1vZHVsZSBjb25maWd1cmF0aW9uJHtpc1JlYWN0UHJvamVjdCA/ICcgKFJlYWN0LWVuYWJsZWQpJyA6ICcnfVxuZXhwb3J0IGRlZmF1bHQge1xuICBwcmVzZXQ6ICd0cy1qZXN0L3ByZXNldHMvZGVmYXVsdC1lc20nLFxuICBleHRlbnNpb25zVG9UcmVhdEFzRXNtOiAke0pTT04uc3RyaW5naWZ5KGV4dGVuc2lvbnNUb1RyZWF0QXNFc20pfSxcbiAgdGVzdEVudmlyb25tZW50OiAnJHt0ZXN0RW52aXJvbm1lbnR9JyxcbiAgc2V0dXBGaWxlc0FmdGVyRW52OiBbJzxyb290RGlyPi9qZXN0LXNldHVwLnRzJ10sXG4gIG1vZHVsZUZpbGVFeHRlbnNpb25zOiAke0pTT04uc3RyaW5naWZ5KG1vZHVsZUZpbGVFeHRlbnNpb25zKX0sXG4gIHJvb3RzOiBbJzxyb290RGlyPiddLFxuICB0ZXN0TWF0Y2g6ICR7SlNPTi5zdHJpbmdpZnkodGVzdE1hdGNoUGF0dGVybnMsIG51bGwsIDQpLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKX0sXG4gIHRyYW5zZm9ybTogJHtKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1Db25maWcsIG51bGwsIDQpLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKX0sXG4gIHRyYW5zZm9ybUlnbm9yZVBhdHRlcm5zOiBbXG4gICAgJ25vZGVfbW9kdWxlcy8oPyEoPzpAdGFuc3RhY2t8QHJhZGl4LXVpfGx1Y2lkZS1yZWFjdHxyZWFjdC1yZXNpemFibGUtcGFuZWxzfGNtZGt8dmF1bCkvKSdcbiAgXSxcbiAgbW9kdWxlTmFtZU1hcHBlcjoge1xuICAgICdeKFxcXFwuezEsMn0vLiopXFxcXC5qcyQnOiAnJDEnLFxuICAgICdecXRlc3RzLyguKikkJzogJzxyb290RGlyPi9ub2RlX21vZHVsZXMvcXRlc3RzLyQxJ1xuICB9JHtpc1JlYWN0UHJvamVjdCA/ICcsXFxuICAvLyBSZWFjdCBUZXN0aW5nIExpYnJhcnkgY29uZmlndXJhdGlvblxcbiAgdGVzdEVudmlyb25tZW50OiBcXCdqc2RvbVxcJyxcXG4gIHNldHVwRmlsZXNBZnRlckVudjogW1xcJzxyb290RGlyPi9qZXN0LXNldHVwLnRzXFwnXScgOiAnJ31cbn07XG5gLnRyaW0oKTtcblxuICAgIC8vIEdlbmVyYXRlIFR5cGVTY3JpcHQgRVMgbW9kdWxlIHNldHVwIHdpdGggUmVhY3Qgc3VwcG9ydFxuICAgIGNvbnN0IGRvbVBvbHlmaWxscyA9IGlzUmVhY3RQcm9qZWN0ID8gYFxuXG4vLyBET00gcG9seWZpbGxzIGZvciBSZWFjdCBUZXN0aW5nIExpYnJhcnlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdtYXRjaE1lZGlhJywge1xuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24ocXVlcnkgPT4gKHtcbiAgICBtYXRjaGVzOiBmYWxzZSxcbiAgICBtZWRpYTogcXVlcnksXG4gICAgb25jaGFuZ2U6IG51bGwsXG4gICAgYWRkTGlzdGVuZXI6IGplc3QuZm4oKSwgLy8gRGVwcmVjYXRlZFxuICAgIHJlbW92ZUxpc3RlbmVyOiBqZXN0LmZuKCksIC8vIERlcHJlY2F0ZWRcbiAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgIGRpc3BhdGNoRXZlbnQ6IGplc3QuZm4oKSxcbiAgfSkpLFxufSk7XG5cbi8vIFJlc2l6ZU9ic2VydmVyIHBvbHlmaWxsXG5nbG9iYWwuUmVzaXplT2JzZXJ2ZXIgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gIG9ic2VydmU6IGplc3QuZm4oKSxcbiAgdW5vYnNlcnZlOiBqZXN0LmZuKCksXG4gIGRpc2Nvbm5lY3Q6IGplc3QuZm4oKSxcbn0pKTtcblxuLy8gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgcG9seWZpbGxcbmdsb2JhbC5JbnRlcnNlY3Rpb25PYnNlcnZlciA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgb2JzZXJ2ZTogamVzdC5mbigpLFxuICB1bm9ic2VydmU6IGplc3QuZm4oKSxcbiAgZGlzY29ubmVjdDogamVzdC5mbigpLFxufSkpO2AgOiAnJztcbiAgICBcbiAgICBjb25zdCBzZXR1cCA9IGBcbi8vIGplc3Qtc2V0dXAudHMgLSBKZXN0IHNldHVwIGZvciBUeXBlU2NyaXB0IEVTTSR7aXNSZWFjdFByb2plY3QgPyAnIHdpdGggUmVhY3Qgc3VwcG9ydCcgOiAnJ31cbi8vIEtlZXAgcXRlc3RzIHNldHVwIEZJUlNUIHRvIGVuc3VyZSBnbG9iYWwgc3R1YmJpbmcgaXMgYWN0aXZlXG5pbXBvcnQgJ3F0ZXN0cy9zZXR1cCc7XG5pbXBvcnQgJ2plc3QnOyR7aXNSZWFjdFByb2plY3QgPyBcIlxcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9qZXN0LWRvbSc7XCIgOiAnJ31cblxuLy8gU2V0IHRlc3QgZW52aXJvbm1lbnQgZWFybHlcbnByb2Nlc3MuZW52Lk5PREVfRU5WID0gJ3Rlc3QnO1xuXG5iZWZvcmVBbGwoKCkgPT4ge1xuICBqZXN0LnNldFRpbWVvdXQoMTAwMDApO1xufSk7XG5cbmFmdGVyRWFjaCgoKSA9PiB7XG4gIGplc3QuY2xlYXJBbGxNb2NrcygpO1xufSk7JHtkb21Qb2x5ZmlsbHN9XG5gLnRyaW0oKTtcblxuICAgIHRoaXMud3JpdGVJZk1pc3NpbmcoJ2plc3QuY29uZmlnLmpzJywgY29uZmlnKTtcbiAgICB0aGlzLndyaXRlSWZNaXNzaW5nKCdqZXN0LXNldHVwLnRzJywgc2V0dXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHF0ZXN0cyB0ZXN0IHJ1bm5lciBmaWxlIC0gVHlwZVNjcmlwdCBFUyBtb2R1bGUgY29tcGF0aWJsZVxuICAgKi9cbiAgZ2VuZXJhdGVRdGVzdHNSdW5uZXIoKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlYWQgdGhlIGV4aXN0aW5nIHF0ZXN0cy10cy1ydW5uZXIudHMgYXMgdGVtcGxhdGVcbiAgICAgIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihnZXRNb2R1bGVEaXJuYW1lRm9yVGVzdEdlbmVyYXRvcigpLCAnLi4nLCAncXRlc3RzLXRzLXJ1bm5lci50cycpO1xuICAgICAgbGV0IHRlbXBsYXRlID0gJyc7XG4gICAgICBcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHRlbXBsYXRlUGF0aCkpIHtcbiAgICAgICAgdGVtcGxhdGUgPSBmcy5yZWFkRmlsZVN5bmModGVtcGxhdGVQYXRoLCAndXRmOCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdGVtcGxhdGUgZm9yIFR5cGVTY3JpcHQgRVMgbW9kdWxlcyB3aXRoIGNvcnJlY3QgSmVzdCBjb25maWd1cmF0aW9uXG4gICAgICAgIHRlbXBsYXRlID0gYFxuLy8gR2VuZXJhdGVkIHF0ZXN0cyBydW5uZXIgLSBUeXBlU2NyaXB0IEVTIG1vZHVsZSBjb21wYXRpYmxlXG5pbXBvcnQgeyBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbi8vIFJ1biB0ZXN0cyB3aXRoIFR5cGVTY3JpcHQgc3VwcG9ydCBhbmQgY29ycmVjdCBKZXN0IGFyZ3VtZW50c1xuY29uc3QgYXJncyA9IHByb2Nlc3MuYXJndi5zbGljZSgyKTtcbmNvbnN0IHRlc3RQcm9jZXNzID0gc3Bhd24oJ2plc3QnLCBhcmdzLCB7XG4gIHN0ZGlvOiAnaW5oZXJpdCcsXG4gIHNoZWxsOiB0cnVlXG59KTtcblxudGVzdFByb2Nlc3Mub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICBwcm9jZXNzLmV4aXQoY29kZSB8fCAwKTtcbn0pO1xuYC50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsd2F5cyBvdmVyd3JpdGUgcXRlc3RzLXRzLXJ1bm5lci50cyB0byBlbnN1cmUgbGF0ZXN0IGZ1bmN0aW9uYWxpdHkgYW5kIFR5cGVTY3JpcHQgY29tcGxpYW5jZVxuICAgICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncXRlc3RzLXRzLXJ1bm5lci50cycpO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhvdXRwdXRQYXRoLCB0ZW1wbGF0ZSwgJ3V0ZjgnKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBHZW5lcmF0ZWQgcXRlc3RzLXRzLXJ1bm5lci50cyBmb3IgVHlwZVNjcmlwdCBFUyBtb2R1bGVzJyk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIHF0ZXN0cy10cy1ydW5uZXIudHM6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwYWNrYWdlLmpzb24gdGVzdCBzY3JpcHQgdG8gdXNlIHF0ZXN0cy10cy1ydW5uZXIudHNcbiAgICovXG4gIHVwZGF0ZVBhY2thZ2VKc29uVGVzdFNjcmlwdCgpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFja2FnZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3BhY2thZ2UuanNvbicpO1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHBhY2thZ2VQYXRoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPICBwYWNrYWdlLmpzb24gbm90IGZvdW5kLCBza2lwcGluZyB0ZXN0IHNjcmlwdCB1cGRhdGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgIFxuICAgICAgaWYgKCFwYWNrYWdlSnNvbi5zY3JpcHRzKSB7XG4gICAgICAgIHBhY2thZ2VKc29uLnNjcmlwdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcGFja2FnZUpzb24uc2NyaXB0cy50ZXN0ID0gJ25weCB0c3ggcXRlc3RzLXRzLXJ1bm5lci50cyc7XG4gICAgICBcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMocGFja2FnZVBhdGgsIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uLCBudWxsLCAyKSwgJ3V0ZjgnKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVXBkYXRlZCBwYWNrYWdlLmpzb24gdGVzdCBzY3JpcHQgdG8gdXNlIHF0ZXN0cy10cy1ydW5uZXIudHMnKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPICBDb3VsZCBub3QgdXBkYXRlIHBhY2thZ2UuanNvbjonLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NhbiBmb3IgZmlsZXMgd2l0aG91dCB0ZXN0cyBhbmQgZ2VuZXJhdGUgdGhlbSAtIFR5cGVTY3JpcHQgRVMgbW9kdWxlIG9ubHlcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGVzdEZpbGVzKGRyeVJ1bjogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gU2Nhbm5pbmcgZm9yIGZpbGVzIHRoYXQgbmVlZCBUeXBlU2NyaXB0IHRlc3RzLi4uJyk7XG4gICAgXG4gICAgY29uc3QgYWxsRmlsZXMgPSB0aGlzLndhbGtQcm9qZWN0KCk7XG4gICAgY29uc3QgeyBzb3VyY2VGaWxlcyB9ID0gdGhpcy5jYXRlZ29yaXplRmlsZXMoYWxsRmlsZXMpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5OBIEZvdW5kICR7c291cmNlRmlsZXMubGVuZ3RofSBzb3VyY2UgZmlsZXMgd2l0aG91dCB0ZXN0c2ApO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHRlc3RzIGZvciBlYWNoIHNvdXJjZSBmaWxlXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIHNvdXJjZUZpbGVzKSB7XG4gICAgICBhd2FpdCB0aGlzLmFuYWx5emUoZmlsZSwgZHJ5UnVuKTtcbiAgICB9XG5cbiAgICAvLyBPbiBub24tZHJ5IHJ1bnMsIGFsd2F5cyBzY2FmZm9sZCBKZXN0IGFuZCBydW5uZXIgZXZlbiBpZiB0aGVyZSB3ZXJlIG5vIG5ldyBmaWxlc1xuICAgIGlmICghZHJ5UnVuKSB7XG4gICAgICB0aGlzLnNjYWZmb2xkSmVzdFNldHVwKCk7XG4gICAgICB0aGlzLmdlbmVyYXRlUXRlc3RzUnVubmVyKCk7XG4gICAgICAvLyBPbmx5IHVwZGF0ZSBwYWNrYWdlLmpzb24gaWYgcmVxdWVzdGVkIHZpYSBDTEkgZmxhZ1xuICAgICAgaWYgKCh0aGlzLmNvbmZpZyBhcyBhbnkpLnVwZGF0ZVBhY2thZ2VTY3JpcHQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYWNrYWdlSnNvblRlc3RTY3JpcHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBEcnkgcnVuOiBTa2lwcGluZyBKZXN0IGNvbmZpZyBhbmQgcnVubmVyIGdlbmVyYXRpb24nKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk50gR2VuZXJhdGVkICR7dGhpcy5zY2FubmVkLmxlbmd0aH0gVHlwZVNjcmlwdCB0ZXN0IGZpbGVzOmApO1xuICAgIHRoaXMuc2Nhbm5lZC5mb3JFYWNoKHRlc3QgPT4ge1xuICAgICAgY29uc29sZS5sb2coYCAgICR7dGVzdC50eXBlfTogJHt0ZXN0LmZpbGV9YCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNjYW4gcmVzdWx0c1xuICAgKi9cbiAgZ2V0UmVzdWx0cygpOiBTY2FubmVkVGVzdFtdIHtcbiAgICByZXR1cm4gdGhpcy5zY2FubmVkO1xuICB9XG59XG5cbi8vIEV4cG9ydCB0aGUgVGVzdEdlbmVyYXRvciBjbGFzcyB1c2luZyBFUyBtb2R1bGUgc3ludGF4XG5leHBvcnQgeyBUZXN0R2VuZXJhdG9yIH07XG5leHBvcnQgZGVmYXVsdCBUZXN0R2VuZXJhdG9yO1xuIl0sInZlcnNpb24iOjN9