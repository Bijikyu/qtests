60462825c70763821207b14a6e3918b0
/**
 * Assertion Helper Utilities for Common Testing Patterns - TypeScript Implementation
 *
 * This class focuses solely on assertion logic and testing validation concerns.
 * It centralizes repetitive assertion logic with descriptive helpers.
 */
import { logStart, logReturn } from '../../lib/logUtils.js';
/**
 * Assertion Helper Utilities for Common Testing Patterns
 *
 * This class centralizes repetitive assertion logic with descriptive helpers
 * that reduce code duplication across test files while providing clear,
 * readable test assertions.
 */
class AssertionHelper {
    /**
     * Asserts that an object has standard database entity properties
     */
    static assertDatabaseEntity(entity, expectedProperties = {}) {
        logStart('AssertionHelper.assertDatabaseEntity', entity, expectedProperties);
        try {
            if (!entity) {
                throw new Error('Entity cannot be null or undefined');
            }
            // Check for database-specific properties
            if (entity._id !== undefined) {
                if (!entity._id) {
                    throw new Error('Entity _id must be defined and truthy');
                }
            }
            if (entity.id !== undefined) {
                if (!entity.id) {
                    throw new Error('Entity id must be defined and truthy');
                }
            }
            if (entity.createdAt !== undefined) {
                if (!(entity.createdAt instanceof Date)) {
                    throw new Error('Entity createdAt must be a Date instance');
                }
            }
            // Check expected properties
            Object.entries(expectedProperties).forEach(([key, value]) => {
                if (entity[key] !== value) {
                    throw new Error(`Expected entity.${key} to be ${value}, but got ${entity[key]}`);
                }
            });
            logReturn('AssertionHelper.assertDatabaseEntity', 'passed');
        }
        catch (error) {
            logReturn('AssertionHelper.assertDatabaseEntity', `failed: ${error.message}`);
            throw error;
        }
    }
    /**
     * Asserts API response structure and status
     */
    static assertApiResponse(response, expectedStatus, hasData = true) {
        logStart('AssertionHelper.assertApiResponse', response, expectedStatus, hasData);
        try {
            if (!response) {
                throw new Error('Response cannot be null or undefined');
            }
            if (response.status !== expectedStatus) {
                throw new Error(`Expected status ${expectedStatus}, but got ${response.status}`);
            }
            if (hasData) {
                if (!response.body && !response.data) {
                    throw new Error('Response should have body or data property');
                }
            }
            if (expectedStatus >= 400) {
                const errorData = response.body || response.data || {};
                if (!errorData.error && !errorData.message) {
                    throw new Error('Error responses should have error or message property');
                }
            }
            logReturn('AssertionHelper.assertApiResponse', 'passed');
        }
        catch (error) {
            logReturn('AssertionHelper.assertApiResponse', `failed: ${error.message}`);
            throw error;
        }
    }
    /**
     * Asserts email sending behavior
     */
    static assertEmailSent(expectedEmail = {}, options = {}) {
        logStart('AssertionHelper.assertEmailSent', expectedEmail, options);
        try {
            // This would need to be implemented with actual email history tracking
            // For now, provide a placeholder implementation
            const emailHistory = [];
            const { count = 1, index = emailHistory.length - 1 } = options;
            if (emailHistory.length < count) {
                throw new Error(`Expected at least ${count} emails, but found ${emailHistory.length}`);
            }
            if (index >= emailHistory.length || index < 0) {
                throw new Error(`Email index ${index} is out of range (0-${emailHistory.length - 1})`);
            }
            const email = emailHistory[index];
            // Check expected email properties
            Object.entries(expectedEmail).forEach(([key, value]) => {
                if (email[key] !== value) {
                    throw new Error(`Expected email.${key} to be ${value}, but got ${email[key]}`);
                }
            });
            logReturn('AssertionHelper.assertEmailSent', 'passed');
        }
        catch (error) {
            logReturn('AssertionHelper.assertEmailSent', `failed: ${error.message}`);
            throw error;
        }
    }
    /**
     * Asserts array properties and content
     */
    static assertArray(array, expectedLength, itemValidator) {
        logStart('AssertionHelper.assertArray', array, expectedLength);
        try {
            if (!Array.isArray(array)) {
                throw new Error('Expected an array but got ' + typeof array);
            }
            if (expectedLength !== undefined && array.length !== expectedLength) {
                throw new Error(`Expected array length ${expectedLength}, but got ${array.length}`);
            }
            if (itemValidator) {
                array.forEach((item, index) => {
                    try {
                        itemValidator(item);
                    }
                    catch (error) {
                        throw new Error(`Array item at index ${index} failed validation: ${error.message}`);
                    }
                });
            }
            logReturn('AssertionHelper.assertArray', 'passed');
        }
        catch (error) {
            logReturn('AssertionHelper.assertArray', `failed: ${error.message}`);
            throw error;
        }
    }
    /**
     * Asserts object has required properties
     */
    static assertObjectStructure(obj, requiredProps, optionalProps = []) {
        logStart('AssertionHelper.assertObjectStructure', obj, requiredProps, optionalProps);
        try {
            if (!obj || typeof obj !== 'object') {
                throw new Error('Expected an object but got ' + typeof obj);
            }
            // Check required properties
            for (const prop of requiredProps) {
                if (!(prop in obj)) {
                    throw new Error(`Required property '${prop}' is missing`);
                }
            }
            // Check for unexpected properties
            const allowedProps = new Set([...requiredProps, ...optionalProps]);
            for (const prop of Object.keys(obj)) {
                if (!allowedProps.has(prop)) {
                    throw new Error(`Unexpected property '${prop}' found`);
                }
            }
            logReturn('AssertionHelper.assertObjectStructure', 'passed');
        }
        catch (error) {
            logReturn('AssertionHelper.assertObjectStructure', `failed: ${error.message}`);
            throw error;
        }
    }
    /**
     * Asserts timing constraints
     */
    static assertTimingConstraint(actualDuration, maxDuration, operation = 'operation') {
        logStart('AssertionHelper.assertTimingConstraint', actualDuration, maxDuration, operation);
        try {
            if (actualDuration > maxDuration) {
                throw new Error(`${operation} took ${actualDuration.toFixed(2)}ms, exceeding limit of ${maxDuration}ms`);
            }
            logReturn('AssertionHelper.assertTimingConstraint', `passed in ${actualDuration.toFixed(2)}ms`);
        }
        catch (error) {
            logReturn('AssertionHelper.assertTimingConstraint', `failed: ${error.message}`);
            throw error;
        }
    }
}
// Export AssertionHelper using ES module syntax
export { AssertionHelper };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS91dGlscy90ZXN0aW5nL2Fzc2VydGlvbkhlbHBlci50cyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7R0FLRztBQUVILE9BQU8sRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUE4QjVEOzs7Ozs7R0FNRztBQUNILE1BQU0sZUFBZTtJQUNuQjs7T0FFRztJQUNILE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFzQixFQUFFLHFCQUEwQyxFQUFFO1FBQzlGLFFBQVEsQ0FBQyxzQ0FBc0MsRUFBRSxNQUFNLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUU3RSxJQUFJLENBQUM7WUFDSCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1lBQ3hELENBQUM7WUFFRCx5Q0FBeUM7WUFDekMsSUFBSSxNQUFNLENBQUMsR0FBRyxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUM3QixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7Z0JBQzNELENBQUM7WUFDSCxDQUFDO1lBRUQsSUFBSSxNQUFNLENBQUMsRUFBRSxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDO29CQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztnQkFDMUQsQ0FBQztZQUNILENBQUM7WUFFRCxJQUFJLE1BQU0sQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFLENBQUM7Z0JBQ25DLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLFlBQVksSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDeEMsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO2dCQUM5RCxDQUFDO1lBQ0gsQ0FBQztZQUVELDRCQUE0QjtZQUM1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YyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsMEJBQTBCLFdBQVcsSUFBSSxDQUN4RixDQUFDO1lBQ0osQ0FBQztZQUVELFNBQVMsQ0FBQyx3Q0FBd0MsRUFBRSxhQUFhLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xHLENBQUM7UUFBQyxPQUFPLEtBQVUsRUFBRSxDQUFDO1lBQ3BCLFNBQVMsQ0FBQyx3Q0FBd0MsRUFBRSxXQUFXLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ2hGLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVELGdEQUFnRDtBQUNoRCxPQUFPLEVBQUUsZUFBZSxFQUFFLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS91dGlscy90ZXN0aW5nL2Fzc2VydGlvbkhlbHBlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzc2VydGlvbiBIZWxwZXIgVXRpbGl0aWVzIGZvciBDb21tb24gVGVzdGluZyBQYXR0ZXJucyAtIFR5cGVTY3JpcHQgSW1wbGVtZW50YXRpb25cbiAqIFxuICogVGhpcyBjbGFzcyBmb2N1c2VzIHNvbGVseSBvbiBhc3NlcnRpb24gbG9naWMgYW5kIHRlc3RpbmcgdmFsaWRhdGlvbiBjb25jZXJucy5cbiAqIEl0IGNlbnRyYWxpemVzIHJlcGV0aXRpdmUgYXNzZXJ0aW9uIGxvZ2ljIHdpdGggZGVzY3JpcHRpdmUgaGVscGVycy5cbiAqL1xuXG5pbXBvcnQgeyBsb2dTdGFydCwgbG9nUmV0dXJuIH0gZnJvbSAnLi4vLi4vbGliL2xvZ1V0aWxzLmpzJztcblxuLy8gVHlwZSBkZWZpbml0aW9uc1xuaW50ZXJmYWNlIERhdGFiYXNlRW50aXR5IHtcbiAgX2lkPzogYW55O1xuICBpZD86IGFueTtcbiAgY3JlYXRlZEF0PzogRGF0ZTtcbiAgdXBkYXRlZEF0PzogRGF0ZTtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5pbnRlcmZhY2UgQXBpUmVzcG9uc2Uge1xuICBzdGF0dXM6IG51bWJlcjtcbiAgYm9keT86IGFueTtcbiAgZGF0YT86IGFueTtcbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbmludGVyZmFjZSBFbWFpbEV4cGVjdGF0aW9uIHtcbiAgdG8/OiBzdHJpbmc7XG4gIHN1YmplY3Q/OiBzdHJpbmc7XG4gIGJvZHk/OiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuaW50ZXJmYWNlIEFzc2VydGlvbk9wdGlvbnMge1xuICBjb3VudD86IG51bWJlcjtcbiAgaW5kZXg/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQXNzZXJ0aW9uIEhlbHBlciBVdGlsaXRpZXMgZm9yIENvbW1vbiBUZXN0aW5nIFBhdHRlcm5zXG4gKiBcbiAqIFRoaXMgY2xhc3MgY2VudHJhbGl6ZXMgcmVwZXRpdGl2ZSBhc3NlcnRpb24gbG9naWMgd2l0aCBkZXNjcmlwdGl2ZSBoZWxwZXJzXG4gKiB0aGF0IHJlZHVjZSBjb2RlIGR1cGxpY2F0aW9uIGFjcm9zcyB0ZXN0IGZpbGVzIHdoaWxlIHByb3ZpZGluZyBjbGVhcixcbiAqIHJlYWRhYmxlIHRlc3QgYXNzZXJ0aW9ucy5cbiAqL1xuY2xhc3MgQXNzZXJ0aW9uSGVscGVyIHtcbiAgLyoqXG4gICAqIEFzc2VydHMgdGhhdCBhbiBvYmplY3QgaGFzIHN0YW5kYXJkIGRhdGFiYXNlIGVudGl0eSBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0RGF0YWJhc2VFbnRpdHkoZW50aXR5OiBEYXRhYmFzZUVudGl0eSwgZXhwZWN0ZWRQcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiB2b2lkIHtcbiAgICBsb2dTdGFydCgnQXNzZXJ0aW9uSGVscGVyLmFzc2VydERhdGFiYXNlRW50aXR5JywgZW50aXR5LCBleHBlY3RlZFByb3BlcnRpZXMpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGl0eSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGRhdGFiYXNlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAgIGlmIChlbnRpdHkuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFlbnRpdHkuX2lkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnRpdHkgX2lkIG11c3QgYmUgZGVmaW5lZCBhbmQgdHJ1dGh5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVudGl0eS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghZW50aXR5LmlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnRpdHkgaWQgbXVzdCBiZSBkZWZpbmVkIGFuZCB0cnV0aHknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZW50aXR5LmNyZWF0ZWRBdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghKGVudGl0eS5jcmVhdGVkQXQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW50aXR5IGNyZWF0ZWRBdCBtdXN0IGJlIGEgRGF0ZSBpbnN0YW5jZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGV4cGVjdGVkIHByb3BlcnRpZXNcbiAgICAgIE9iamVjdC5lbnRyaWVzKGV4cGVjdGVkUHJvcGVydGllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChlbnRpdHlba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGVudGl0eS4ke2tleX0gdG8gYmUgJHt2YWx1ZX0sIGJ1dCBnb3QgJHtlbnRpdHlba2V5XX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGxvZ1JldHVybignQXNzZXJ0aW9uSGVscGVyLmFzc2VydERhdGFiYXNlRW50aXR5JywgJ3Bhc3NlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxvZ1JldHVybignQXNzZXJ0aW9uSGVscGVyLmFzc2VydERhdGFiYXNlRW50aXR5JywgYGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydHMgQVBJIHJlc3BvbnNlIHN0cnVjdHVyZSBhbmQgc3RhdHVzXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0QXBpUmVzcG9uc2UocmVzcG9uc2U6IEFwaVJlc3BvbnNlLCBleHBlY3RlZFN0YXR1czogbnVtYmVyLCBoYXNEYXRhOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIGxvZ1N0YXJ0KCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0QXBpUmVzcG9uc2UnLCByZXNwb25zZSwgZXhwZWN0ZWRTdGF0dXMsIGhhc0RhdGEpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IGV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3RhdHVzICR7ZXhwZWN0ZWRTdGF0dXN9LCBidXQgZ290ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkgJiYgIXJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIHNob3VsZCBoYXZlIGJvZHkgb3IgZGF0YSBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChleHBlY3RlZFN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gcmVzcG9uc2UuYm9keSB8fCByZXNwb25zZS5kYXRhIHx8IHt9O1xuICAgICAgICBpZiAoIWVycm9yRGF0YS5lcnJvciAmJiAhZXJyb3JEYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHJlc3BvbnNlcyBzaG91bGQgaGF2ZSBlcnJvciBvciBtZXNzYWdlIHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0QXBpUmVzcG9uc2UnLCAncGFzc2VkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0QXBpUmVzcG9uc2UnLCBgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0cyBlbWFpbCBzZW5kaW5nIGJlaGF2aW9yXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0RW1haWxTZW50KGV4cGVjdGVkRW1haWw6IEVtYWlsRXhwZWN0YXRpb24gPSB7fSwgb3B0aW9uczogQXNzZXJ0aW9uT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgbG9nU3RhcnQoJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRFbWFpbFNlbnQnLCBleHBlY3RlZEVtYWlsLCBvcHRpb25zKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVGhpcyB3b3VsZCBuZWVkIHRvIGJlIGltcGxlbWVudGVkIHdpdGggYWN0dWFsIGVtYWlsIGhpc3RvcnkgdHJhY2tpbmdcbiAgICAgIC8vIEZvciBub3csIHByb3ZpZGUgYSBwbGFjZWhvbGRlciBpbXBsZW1lbnRhdGlvblxuICAgICAgY29uc3QgZW1haWxIaXN0b3J5OiBhbnlbXSA9IFtdO1xuICAgICAgXG4gICAgICBjb25zdCB7IGNvdW50ID0gMSwgaW5kZXggPSBlbWFpbEhpc3RvcnkubGVuZ3RoIC0gMSB9ID0gb3B0aW9ucztcbiAgICAgIFxuICAgICAgaWYgKGVtYWlsSGlzdG9yeS5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0ICR7Y291bnR9IGVtYWlscywgYnV0IGZvdW5kICR7ZW1haWxIaXN0b3J5Lmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGluZGV4ID49IGVtYWlsSGlzdG9yeS5sZW5ndGggfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW1haWwgaW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIHJhbmdlICgwLSR7ZW1haWxIaXN0b3J5Lmxlbmd0aCAtIDF9KWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbWFpbCA9IGVtYWlsSGlzdG9yeVtpbmRleF07XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGV4cGVjdGVkIGVtYWlsIHByb3BlcnRpZXNcbiAgICAgIE9iamVjdC5lbnRyaWVzKGV4cGVjdGVkRW1haWwpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAoZW1haWxba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGVtYWlsLiR7a2V5fSB0byBiZSAke3ZhbHVlfSwgYnV0IGdvdCAke2VtYWlsW2tleV19YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBsb2dSZXR1cm4oJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRFbWFpbFNlbnQnLCAncGFzc2VkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0RW1haWxTZW50JywgYGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydHMgYXJyYXkgcHJvcGVydGllcyBhbmQgY29udGVudFxuICAgKi9cbiAgc3RhdGljIGFzc2VydEFycmF5KGFycmF5OiBhbnlbXSwgZXhwZWN0ZWRMZW5ndGg/OiBudW1iZXIsIGl0ZW1WYWxpZGF0b3I/OiAoaXRlbTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgbG9nU3RhcnQoJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRBcnJheScsIGFycmF5LCBleHBlY3RlZExlbmd0aCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSBidXQgZ290ICcgKyB0eXBlb2YgYXJyYXkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZXhwZWN0ZWRMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBhcnJheS5sZW5ndGggIT09IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXJyYXkgbGVuZ3RoICR7ZXhwZWN0ZWRMZW5ndGh9LCBidXQgZ290ICR7YXJyYXkubGVuZ3RofWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoaXRlbVZhbGlkYXRvcikge1xuICAgICAgICBhcnJheS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpdGVtVmFsaWRhdG9yKGl0ZW0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyYXkgaXRlbSBhdCBpbmRleCAke2luZGV4fSBmYWlsZWQgdmFsaWRhdGlvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGxvZ1JldHVybignQXNzZXJ0aW9uSGVscGVyLmFzc2VydEFycmF5JywgJ3Bhc3NlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxvZ1JldHVybignQXNzZXJ0aW9uSGVscGVyLmFzc2VydEFycmF5JywgYGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydHMgb2JqZWN0IGhhcyByZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0T2JqZWN0U3RydWN0dXJlKG9iajogYW55LCByZXF1aXJlZFByb3BzOiBzdHJpbmdbXSwgb3B0aW9uYWxQcm9wczogc3RyaW5nW10gPSBbXSk6IHZvaWQge1xuICAgIGxvZ1N0YXJ0KCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0T2JqZWN0U3RydWN0dXJlJywgb2JqLCByZXF1aXJlZFByb3BzLCBvcHRpb25hbFByb3BzKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBvYmplY3QgYnV0IGdvdCAnICsgdHlwZW9mIG9iaik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHJlcXVpcmVkIHByb3BlcnRpZXNcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiByZXF1aXJlZFByb3BzKSB7XG4gICAgICAgIGlmICghKHByb3AgaW4gb2JqKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgcHJvcGVydHkgJyR7cHJvcH0nIGlzIG1pc3NpbmdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgdW5leHBlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICBjb25zdCBhbGxvd2VkUHJvcHMgPSBuZXcgU2V0KFsuLi5yZXF1aXJlZFByb3BzLCAuLi5vcHRpb25hbFByb3BzXSk7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICBpZiAoIWFsbG93ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcHJvcGVydHkgJyR7cHJvcH0nIGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0T2JqZWN0U3RydWN0dXJlJywgJ3Bhc3NlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxvZ1JldHVybignQXNzZXJ0aW9uSGVscGVyLmFzc2VydE9iamVjdFN0cnVjdHVyZScsIGBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnRzIHRpbWluZyBjb25zdHJhaW50c1xuICAgKi9cbiAgc3RhdGljIGFzc2VydFRpbWluZ0NvbnN0cmFpbnQoYWN0dWFsRHVyYXRpb246IG51bWJlciwgbWF4RHVyYXRpb246IG51bWJlciwgb3BlcmF0aW9uOiBzdHJpbmcgPSAnb3BlcmF0aW9uJyk6IHZvaWQge1xuICAgIGxvZ1N0YXJ0KCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0VGltaW5nQ29uc3RyYWludCcsIGFjdHVhbER1cmF0aW9uLCBtYXhEdXJhdGlvbiwgb3BlcmF0aW9uKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgaWYgKGFjdHVhbER1cmF0aW9uID4gbWF4RHVyYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke29wZXJhdGlvbn0gdG9vayAke2FjdHVhbER1cmF0aW9uLnRvRml4ZWQoMil9bXMsIGV4Y2VlZGluZyBsaW1pdCBvZiAke21heER1cmF0aW9ufW1zYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsb2dSZXR1cm4oJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRUaW1pbmdDb25zdHJhaW50JywgYHBhc3NlZCBpbiAke2FjdHVhbER1cmF0aW9uLnRvRml4ZWQoMil9bXNgKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBsb2dSZXR1cm4oJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRUaW1pbmdDb25zdHJhaW50JywgYGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBBc3NlcnRpb25IZWxwZXIgdXNpbmcgRVMgbW9kdWxlIHN5bnRheFxuZXhwb3J0IHsgQXNzZXJ0aW9uSGVscGVyIH07Il0sInZlcnNpb24iOjN9