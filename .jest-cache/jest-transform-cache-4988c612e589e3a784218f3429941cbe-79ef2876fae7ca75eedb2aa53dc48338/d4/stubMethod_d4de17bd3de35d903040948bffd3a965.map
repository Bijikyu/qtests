{"file":"/home/runner/workspace/utils/stubMethod.ts","mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AAEH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,SAAS,UAAU,CAAC,GAAQ,EAAE,UAAkB,EAAE,MAAgB;IAChE,OAAO,CAAC,GAAG,CAAC,8BAA8B,GAAG,KAAK,UAAU,KAAK,MAAM,EAAE,CAAC,CAAC,CAAC,0CAA0C;IAEtH,IAAI,CAAC;QACH,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,EAAE,CAAC,CAAC,kDAAkD;YAC/F,MAAM,IAAI,KAAK,CAAC,2CAA2C,GAAG,EAAE,CAAC,CAAC,CAAC,oCAAoC;QACzG,CAAC;QACD,IAAI,CAAC,CAAC,UAAU,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,2CAA2C;YACrE,MAAM,IAAI,KAAK,CAAC,6BAA6B,UAAU,qBAAqB,CAAC,CAAC,CAAC,4BAA4B;QAC7G,CAAC;QACD,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE,CAAC,CAAC,4BAA4B;YAC9D,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC,CAAC,4BAA4B;QACvF,CAAC;QACD,qDAAqD;QACrD,iGAAiG;QACjG,gGAAgG;QAChG,MAAM,cAAc,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,6BAA6B;QACrE,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC,CAAC,4CAA4C;QAElH,6DAA6D;QAC7D,8FAA8F;QAC9F,4EAA4E;QAC5E,GAAG,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC;QAEzB,oDAAoD;QACpD,2EAA2E;QAC3E,iFAAiF;QACjF,6EAA6E;QAC7E,MAAM,eAAe,GAAG,SAAS,OAAO;YACtC,sFAAsF;YACtF,IAAI,MAAM,EAAE,CAAC,CAAC,iDAAiD;gBAC7D,GAAG,CAAC,UAAU,CAAC,GAAG,cAAc,CAAC,CAAC,gCAAgC;YACpE,CAAC;iBAAM,CAAC;gBACN,OAAO,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,mDAAmD;YAC7E,CAAC;QACH,CAAC,CAAC;QAEF,OAAO,CAAC,GAAG,CAAC,2BAA2B,eAAe,EAAE,CAAC,CAAC,CAAC,wCAAwC;QACnG,OAAO,eAAe,CAAC;IACzB,CAAC;IAAC,OAAO,KAAU,EAAE,CAAC;QACpB,yDAAyD;QACzD,6FAA6F;QAC7F,wFAAwF;QACxF,OAAO,CAAC,GAAG,CAAC,qBAAqB,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QAClD,MAAM,KAAK,CAAC;IACd,CAAC;AACH,CAAC;AAED,oDAAoD;AACpD,eAAe,UAAU,CAAC;AAC1B,OAAO,EAAE,UAAU,EAAE,CAAC","names":[],"sources":["/home/runner/workspace/utils/stubMethod.ts"],"sourcesContent":["/**\n * Method Stubbing Utility - TypeScript Implementation\n * \n * This module provides the fundamental method replacement functionality\n * that enables isolated unit testing by replacing method implementations\n * with controlled test doubles.\n * \n * Core concept:\n * Stubbing temporarily replaces a method on an object with a test implementation,\n * allowing tests to control the behavior of dependencies and verify interactions\n * without executing the real method code.\n * \n * Design philosophy:\n * - Simple, predictable API that follows common stubbing patterns\n * - Automatic restoration to prevent test pollution\n * - Flexible replacement function support\n * - Framework-agnostic implementation\n * \n * Why manual stubbing vs mocking libraries:\n * 1. Zero dependencies - works in any Node.js environment\n * 2. Simple implementation is easy to understand and debug\n * 3. Predictable behavior without complex library-specific semantics\n * 4. Minimal API surface reduces learning curve\n * 5. Complete control over restoration behavior\n */\n\n/**\n * Replace a method on an object with a test implementation\n * \n * This function temporarily replaces a method with a stub implementation,\n * providing a restoration function to return the object to its original state.\n * \n * Implementation strategy:\n * 1. Store original method reference before replacement\n * 2. Replace method with provided stub function  \n * 3. Return restoration function that reinstates original method\n * 4. Use closure to maintain access to original method and object\n * \n * Why this approach:\n * - Closure pattern ensures original method is preserved correctly\n * - Restoration function provides clear, explicit cleanup\n * - No global state management required\n * - Works with any object and method combination\n * - Simple implementation is easy to debug when tests fail\n * \n * Alternative approaches considered:\n * - Automatic restoration via setTimeout: Rejected due to unpredictable timing\n * - Stack-based restoration: Rejected due to complexity for minimal benefit\n * - Property descriptor manipulation: Current approach is simpler and sufficient\n * \n * @param obj - The object containing the method to replace\n * @param methodName - Name of the method to replace\n * @param stubFn - Function to use as replacement implementation\n * @returns Restoration function that reinstates the original method\n * \n * @example\n * const restore = stubMethod(fs, 'readFileSync', () => 'mock data');\n * // fs.readFileSync now returns 'mock data'\n * restore();\n * // fs.readFileSync restored to original implementation\n */\nfunction stubMethod(obj: any, methodName: string, stubFn: Function): () => void {\n  console.log(`stubMethod is running with ${obj}, ${methodName}, ${stubFn}`); // logging function start per requirements\n\n  try {\n    if (typeof obj !== 'object' || obj === null) { // ensure obj is valid before accessing properties\n      throw new Error(`stubMethod expected object but received ${obj}`); // informative error for invalid obj\n    }\n    if (!(methodName in obj)) { // confirm property exists on target object\n      throw new Error(`stubMethod could not find ${methodName} on provided object`); // error when method missing\n    }\n    if (typeof stubFn !== 'function') { // verify stubFn is callable\n      throw new Error('stubMethod stubFn must be a function'); // error when stubFn invalid\n    }\n    // Store original method reference before replacement\n    // This is critical for restoration - without this reference, the original method is lost forever\n    // We must capture this before any modification to ensure we can restore exact original behavior\n    const originalMethod = obj[methodName]; // capture original reference\n    const hadOwn = Object.prototype.hasOwnProperty.call(obj, methodName); // track if property was own before stubbing\n    \n    // Replace method directly on the object for immediate effect\n    // Direct property assignment chosen over Object.defineProperty for simplicity and performance\n    // This approach works for 99% of use cases and avoids descriptor complexity\n    obj[methodName] = stubFn;\n    \n    // Create restoration function using closure pattern\n    // Closure captures originalMethod and obj references for later restoration\n    // Named function 'restore' provides clear intent and better debugging experience\n    // Returned function pattern allows caller to control when restoration occurs\n    const restoreFunction = function restore(): void {\n      // Reinstate original method only if it existed as own property, otherwise remove stub\n      if (hadOwn) { // property was originally own so simply reassign\n        obj[methodName] = originalMethod; // restore exact original method\n      } else {\n        delete obj[methodName]; // remove stub so prototype chain resolves original\n      }\n    };\n    \n    console.log(`stubMethod is returning ${restoreFunction}`); // logging return value per requirements\n    return restoreFunction;\n  } catch (error: any) {\n    // Log error with context for debugging test setup issues\n    // Error logging helps developers identify problems with object access or property assignment\n    // We re-throw to maintain error handling contract while providing debugging information\n    console.log(`stubMethod error: ${error.message}`);\n    throw error;\n  }\n}\n\n// Export stubMethod function using ES module syntax\nexport default stubMethod;\nexport { stubMethod };"],"version":3}