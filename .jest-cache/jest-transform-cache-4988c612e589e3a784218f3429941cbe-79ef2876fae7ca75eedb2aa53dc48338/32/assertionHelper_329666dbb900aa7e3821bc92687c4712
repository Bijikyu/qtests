49134059c5ab5dde60e2ac11c753486e
/**
 * Assertion Helper Utilities for Common Testing Patterns
 * 
 * This class focuses solely on assertion logic and testing validation concerns.
 * It centralizes repetitive assertion logic with descriptive helpers.
 */

const {
  logStart,
  logReturn
} = require('../../lib/logUtils');

/**
 * Assertion Helper Utilities for Common Testing Patterns
 * 
 * This class centralizes repetitive assertion logic with descriptive helpers
 * that reduce code duplication across test files while providing clear,
 * readable test assertions.
 */
class AssertionHelper {
  /**
   * Asserts that an object has standard database entity properties
   * 
   * @param {Object} entity - Entity object to validate
   * @param {Object} expectedProperties - Expected property values
   */
  static assertDatabaseEntity(entity, expectedProperties = {}) {
    logStart('AssertionHelper.assertDatabaseEntity', entity, expectedProperties);
    try {
      if (!entity) {
        throw new Error('Entity cannot be null or undefined');
      }

      // Check for database-specific properties
      if (entity._id !== undefined) {
        if (!entity._id) {
          throw new Error('Entity _id must be defined and truthy');
        }
      }
      if (entity.id !== undefined) {
        if (!entity.id) {
          throw new Error('Entity id must be defined and truthy');
        }
      }
      if (entity.createdAt !== undefined) {
        if (!(entity.createdAt instanceof Date)) {
          throw new Error('Entity createdAt must be a Date instance');
        }
      }

      // Check expected properties
      Object.entries(expectedProperties).forEach(([key, value]) => {
        if (entity[key] !== value) {
          throw new Error(`Expected entity.${key} to be ${value}, but got ${entity[key]}`);
        }
      });
      logReturn('AssertionHelper.assertDatabaseEntity', 'passed');
    } catch (error) {
      logReturn('AssertionHelper.assertDatabaseEntity', `failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Asserts API response structure and status
   * 
   * @param {Object} response - API response object
   * @param {number} expectedStatus - Expected HTTP status code
   * @param {boolean} hasData - Whether response should have data
   */
  static assertApiResponse(response, expectedStatus, hasData = true) {
    logStart('AssertionHelper.assertApiResponse', response, expectedStatus, hasData);
    try {
      if (!response) {
        throw new Error('Response cannot be null or undefined');
      }
      if (response.status !== expectedStatus) {
        throw new Error(`Expected status ${expectedStatus}, but got ${response.status}`);
      }
      if (hasData) {
        if (!response.body && !response.data) {
          throw new Error('Response should have body or data property');
        }
      }
      if (expectedStatus >= 400) {
        const errorData = response.body || response.data || {};
        if (!errorData.error && !errorData.message) {
          throw new Error('Error responses should have error or message property');
        }
      }
      logReturn('AssertionHelper.assertApiResponse', 'passed');
    } catch (error) {
      logReturn('AssertionHelper.assertApiResponse', `failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Asserts email sending behavior using qtests sendEmail utility
   * 
   * @param {Object} expectedEmail - Expected email properties
   * @param {Object} options - Assertion options
   */
  static assertEmailSent(expectedEmail = {}, options = {}) {
    logStart('AssertionHelper.assertEmailSent', expectedEmail, options);
    try {
      const {
        sendEmail
      } = require('../../lib/envUtils');
      const emailHistory = sendEmail.getEmailHistory();
      const {
        count = 1,
        index = emailHistory.length - 1
      } = options;
      if (emailHistory.length < count) {
        throw new Error(`Expected at least ${count} emails, but found ${emailHistory.length}`);
      }
      if (index >= emailHistory.length || index < 0) {
        throw new Error(`Email index ${index} is out of range (0-${emailHistory.length - 1})`);
      }
      const email = emailHistory[index];
      if (!email.success) {
        throw new Error(`Email at index ${index} was not successful: ${email.message}`);
      }

      // Check expected email properties
      Object.entries(expectedEmail).forEach(([key, value]) => {
        const emailData = email.emailData || {};
        if (emailData[key] !== value) {
          throw new Error(`Expected email.${key} to be ${value}, but got ${emailData[key]}`);
        }
      });
      logReturn('AssertionHelper.assertEmailSent', 'passed');
    } catch (error) {
      logReturn('AssertionHelper.assertEmailSent', `failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Asserts mock function call behavior
   * 
   * @param {Function} mockFunction - Mock function to assert
   * @param {Object} expectations - Call expectations
   */
  static assertMockCalled(mockFunction, expectations = {}) {
    logStart('AssertionHelper.assertMockCalled', mockFunction.name, expectations);
    try {
      if (!mockFunction) {
        throw new Error('Mock function cannot be null or undefined');
      }
      const {
        times = 1,
        calledWith = null,
        returnedWith = null
      } = expectations;

      // Check if mock has call tracking
      if (mockFunction.mock && mockFunction.mock.calls) {
        const callCount = mockFunction.mock.calls.length;
        if (callCount !== times) {
          throw new Error(`Expected ${times} calls, but got ${callCount}`);
        }
        if (calledWith !== null && callCount > 0) {
          const lastCall = mockFunction.mock.calls[callCount - 1];
          if (JSON.stringify(lastCall) !== JSON.stringify(calledWith)) {
            throw new Error(`Expected last call with ${JSON.stringify(calledWith)}, but got ${JSON.stringify(lastCall)}`);
          }
        }
        if (returnedWith !== null && mockFunction.mock.results) {
          const lastResult = mockFunction.mock.results[mockFunction.mock.results.length - 1];
          if (lastResult && lastResult.value !== returnedWith) {
            throw new Error(`Expected return value ${returnedWith}, but got ${lastResult.value}`);
          }
        }
      } else {
        console.log('Warning: Mock function does not support call tracking');
      }
      logReturn('AssertionHelper.assertMockCalled', 'passed');
    } catch (error) {
      logReturn('AssertionHelper.assertMockCalled', `failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Asserts that an array contains expected elements
   * 
   * @param {Array} array - Array to check
   * @param {Array} expectedElements - Elements that should be present
   * @param {boolean} exactMatch - Whether array should contain only these elements
   */
  static assertArrayContains(array, expectedElements, exactMatch = false) {
    logStart('AssertionHelper.assertArrayContains', array, expectedElements, exactMatch);
    try {
      if (!Array.isArray(array)) {
        throw new Error('First argument must be an array');
      }
      if (!Array.isArray(expectedElements)) {
        throw new Error('Expected elements must be an array');
      }

      // Check if all expected elements are present
      for (const element of expectedElements) {
        if (!array.includes(element)) {
          throw new Error(`Array does not contain expected element: ${element}`);
        }
      }

      // Check exact match if required
      if (exactMatch) {
        if (array.length !== expectedElements.length) {
          throw new Error(`Expected array length ${expectedElements.length}, but got ${array.length}`);
        }
        for (const element of array) {
          if (!expectedElements.includes(element)) {
            throw new Error(`Array contains unexpected element: ${element}`);
          }
        }
      }
      logReturn('AssertionHelper.assertArrayContains', 'passed');
    } catch (error) {
      logReturn('AssertionHelper.assertArrayContains', `failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Assert database entity has expected properties
   * 
   * @param {Object} entity - Database entity to check
   * @param {Object} expectedProps - Expected properties and values
   */
  static assertDatabaseEntity(entity, expectedProps) {
    logStart('AssertionHelper.assertDatabaseEntity', expectedProps);
    try {
      if (!entity) {
        throw new Error('Entity is null or undefined');
      }
      Object.keys(expectedProps).forEach(prop => {
        if (entity[prop] !== expectedProps[prop]) {
          throw new Error(`Expected ${prop} to be '${expectedProps[prop]}', but got '${entity[prop]}'`);
        }
      });
      logReturn('AssertionHelper.assertDatabaseEntity', 'assertion passed');
    } catch (error) {
      logReturn('AssertionHelper.assertDatabaseEntity', `error: ${error.message}`);
      throw error;
    }
  }

  // Instance methods for compatibility with fluent API
  assertDatabaseEntity(entity, expectedProps) {
    return AssertionHelper.assertDatabaseEntity(entity, expectedProps);
  }
  assertArrayContains(array, expectedElements, exactMatch = false) {
    return AssertionHelper.assertArrayContains(array, expectedElements, exactMatch);
  }
}
module.exports = {
  AssertionHelper
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJsb2dTdGFydCIsImxvZ1JldHVybiIsInJlcXVpcmUiLCJBc3NlcnRpb25IZWxwZXIiLCJhc3NlcnREYXRhYmFzZUVudGl0eSIsImVudGl0eSIsImV4cGVjdGVkUHJvcGVydGllcyIsIkVycm9yIiwiX2lkIiwidW5kZWZpbmVkIiwiaWQiLCJjcmVhdGVkQXQiLCJEYXRlIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsImVycm9yIiwibWVzc2FnZSIsImFzc2VydEFwaVJlc3BvbnNlIiwicmVzcG9uc2UiLCJleHBlY3RlZFN0YXR1cyIsImhhc0RhdGEiLCJzdGF0dXMiLCJib2R5IiwiZGF0YSIsImVycm9yRGF0YSIsImFzc2VydEVtYWlsU2VudCIsImV4cGVjdGVkRW1haWwiLCJvcHRpb25zIiwic2VuZEVtYWlsIiwiZW1haWxIaXN0b3J5IiwiZ2V0RW1haWxIaXN0b3J5IiwiY291bnQiLCJpbmRleCIsImxlbmd0aCIsImVtYWlsIiwic3VjY2VzcyIsImVtYWlsRGF0YSIsImFzc2VydE1vY2tDYWxsZWQiLCJtb2NrRnVuY3Rpb24iLCJleHBlY3RhdGlvbnMiLCJuYW1lIiwidGltZXMiLCJjYWxsZWRXaXRoIiwicmV0dXJuZWRXaXRoIiwibW9jayIsImNhbGxzIiwiY2FsbENvdW50IiwibGFzdENhbGwiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzdWx0cyIsImxhc3RSZXN1bHQiLCJjb25zb2xlIiwibG9nIiwiYXNzZXJ0QXJyYXlDb250YWlucyIsImFycmF5IiwiZXhwZWN0ZWRFbGVtZW50cyIsImV4YWN0TWF0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJlbGVtZW50IiwiaW5jbHVkZXMiLCJleHBlY3RlZFByb3BzIiwia2V5cyIsInByb3AiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiYXNzZXJ0aW9uSGVscGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXNzZXJ0aW9uIEhlbHBlciBVdGlsaXRpZXMgZm9yIENvbW1vbiBUZXN0aW5nIFBhdHRlcm5zXG4gKiBcbiAqIFRoaXMgY2xhc3MgZm9jdXNlcyBzb2xlbHkgb24gYXNzZXJ0aW9uIGxvZ2ljIGFuZCB0ZXN0aW5nIHZhbGlkYXRpb24gY29uY2VybnMuXG4gKiBJdCBjZW50cmFsaXplcyByZXBldGl0aXZlIGFzc2VydGlvbiBsb2dpYyB3aXRoIGRlc2NyaXB0aXZlIGhlbHBlcnMuXG4gKi9cblxuY29uc3QgeyBsb2dTdGFydCwgbG9nUmV0dXJuIH0gPSByZXF1aXJlKCcuLi8uLi9saWIvbG9nVXRpbHMnKTtcblxuLyoqXG4gKiBBc3NlcnRpb24gSGVscGVyIFV0aWxpdGllcyBmb3IgQ29tbW9uIFRlc3RpbmcgUGF0dGVybnNcbiAqIFxuICogVGhpcyBjbGFzcyBjZW50cmFsaXplcyByZXBldGl0aXZlIGFzc2VydGlvbiBsb2dpYyB3aXRoIGRlc2NyaXB0aXZlIGhlbHBlcnNcbiAqIHRoYXQgcmVkdWNlIGNvZGUgZHVwbGljYXRpb24gYWNyb3NzIHRlc3QgZmlsZXMgd2hpbGUgcHJvdmlkaW5nIGNsZWFyLFxuICogcmVhZGFibGUgdGVzdCBhc3NlcnRpb25zLlxuICovXG5jbGFzcyBBc3NlcnRpb25IZWxwZXIge1xuICAvKipcbiAgICogQXNzZXJ0cyB0aGF0IGFuIG9iamVjdCBoYXMgc3RhbmRhcmQgZGF0YWJhc2UgZW50aXR5IHByb3BlcnRpZXNcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHkgLSBFbnRpdHkgb2JqZWN0IHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZFByb3BlcnRpZXMgLSBFeHBlY3RlZCBwcm9wZXJ0eSB2YWx1ZXNcbiAgICovXG4gIHN0YXRpYyBhc3NlcnREYXRhYmFzZUVudGl0eShlbnRpdHksIGV4cGVjdGVkUHJvcGVydGllcyA9IHt9KSB7XG4gICAgbG9nU3RhcnQoJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnREYXRhYmFzZUVudGl0eScsIGVudGl0eSwgZXhwZWN0ZWRQcm9wZXJ0aWVzKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnRpdHkgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBkYXRhYmFzZS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgICBpZiAoZW50aXR5Ll9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghZW50aXR5Ll9pZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW50aXR5IF9pZCBtdXN0IGJlIGRlZmluZWQgYW5kIHRydXRoeScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChlbnRpdHkuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWVudGl0eS5pZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW50aXR5IGlkIG11c3QgYmUgZGVmaW5lZCBhbmQgdHJ1dGh5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVudGl0eS5jcmVhdGVkQXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIShlbnRpdHkuY3JlYXRlZEF0IGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGl0eSBjcmVhdGVkQXQgbXVzdCBiZSBhIERhdGUgaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBleHBlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICBPYmplY3QuZW50cmllcyhleHBlY3RlZFByb3BlcnRpZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAoZW50aXR5W2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBlbnRpdHkuJHtrZXl9IHRvIGJlICR7dmFsdWV9LCBidXQgZ290ICR7ZW50aXR5W2tleV19YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBsb2dSZXR1cm4oJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnREYXRhYmFzZUVudGl0eScsICdwYXNzZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0RGF0YWJhc2VFbnRpdHknLCBgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0cyBBUEkgcmVzcG9uc2Ugc3RydWN0dXJlIGFuZCBzdGF0dXNcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSAtIEFQSSByZXNwb25zZSBvYmplY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkU3RhdHVzIC0gRXhwZWN0ZWQgSFRUUCBzdGF0dXMgY29kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc0RhdGEgLSBXaGV0aGVyIHJlc3BvbnNlIHNob3VsZCBoYXZlIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3NlcnRBcGlSZXNwb25zZShyZXNwb25zZSwgZXhwZWN0ZWRTdGF0dXMsIGhhc0RhdGEgPSB0cnVlKSB7XG4gICAgbG9nU3RhcnQoJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRBcGlSZXNwb25zZScsIHJlc3BvbnNlLCBleHBlY3RlZFN0YXR1cywgaGFzRGF0YSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBzdGF0dXMgJHtleHBlY3RlZFN0YXR1c30sIGJ1dCBnb3QgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChoYXNEYXRhKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2UuYm9keSAmJiAhcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2Ugc2hvdWxkIGhhdmUgYm9keSBvciBkYXRhIHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGV4cGVjdGVkU3RhdHVzID49IDQwMCkge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSByZXNwb25zZS5ib2R5IHx8IHJlc3BvbnNlLmRhdGEgfHwge307XG4gICAgICAgIGlmICghZXJyb3JEYXRhLmVycm9yICYmICFlcnJvckRhdGEubWVzc2FnZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgcmVzcG9uc2VzIHNob3VsZCBoYXZlIGVycm9yIG9yIG1lc3NhZ2UgcHJvcGVydHknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBsb2dSZXR1cm4oJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRBcGlSZXNwb25zZScsICdwYXNzZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0QXBpUmVzcG9uc2UnLCBgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0cyBlbWFpbCBzZW5kaW5nIGJlaGF2aW9yIHVzaW5nIHF0ZXN0cyBzZW5kRW1haWwgdXRpbGl0eVxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkRW1haWwgLSBFeHBlY3RlZCBlbWFpbCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQXNzZXJ0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBhc3NlcnRFbWFpbFNlbnQoZXhwZWN0ZWRFbWFpbCA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICBsb2dTdGFydCgnQXNzZXJ0aW9uSGVscGVyLmFzc2VydEVtYWlsU2VudCcsIGV4cGVjdGVkRW1haWwsIG9wdGlvbnMpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHNlbmRFbWFpbCB9ID0gcmVxdWlyZSgnLi4vLi4vbGliL2VudlV0aWxzJyk7XG4gICAgICBjb25zdCBlbWFpbEhpc3RvcnkgPSBzZW5kRW1haWwuZ2V0RW1haWxIaXN0b3J5KCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgY291bnQgPSAxLCBpbmRleCA9IGVtYWlsSGlzdG9yeS5sZW5ndGggLSAxIH0gPSBvcHRpb25zO1xuICAgICAgXG4gICAgICBpZiAoZW1haWxIaXN0b3J5Lmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgJHtjb3VudH0gZW1haWxzLCBidXQgZm91bmQgJHtlbWFpbEhpc3RvcnkubGVuZ3RofWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoaW5kZXggPj0gZW1haWxIaXN0b3J5Lmxlbmd0aCB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbWFpbCBpbmRleCAke2luZGV4fSBpcyBvdXQgb2YgcmFuZ2UgKDAtJHtlbWFpbEhpc3RvcnkubGVuZ3RoIC0gMX0pYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVtYWlsID0gZW1haWxIaXN0b3J5W2luZGV4XTtcbiAgICAgIFxuICAgICAgaWYgKCFlbWFpbC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW1haWwgYXQgaW5kZXggJHtpbmRleH0gd2FzIG5vdCBzdWNjZXNzZnVsOiAke2VtYWlsLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGV4cGVjdGVkIGVtYWlsIHByb3BlcnRpZXNcbiAgICAgIE9iamVjdC5lbnRyaWVzKGV4cGVjdGVkRW1haWwpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBlbWFpbERhdGEgPSBlbWFpbC5lbWFpbERhdGEgfHwge307XG4gICAgICAgIGlmIChlbWFpbERhdGFba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGVtYWlsLiR7a2V5fSB0byBiZSAke3ZhbHVlfSwgYnV0IGdvdCAke2VtYWlsRGF0YVtrZXldfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0RW1haWxTZW50JywgJ3Bhc3NlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dSZXR1cm4oJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRFbWFpbFNlbnQnLCBgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0cyBtb2NrIGZ1bmN0aW9uIGNhbGwgYmVoYXZpb3JcbiAgICogXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vY2tGdW5jdGlvbiAtIE1vY2sgZnVuY3Rpb24gdG8gYXNzZXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RhdGlvbnMgLSBDYWxsIGV4cGVjdGF0aW9uc1xuICAgKi9cbiAgc3RhdGljIGFzc2VydE1vY2tDYWxsZWQobW9ja0Z1bmN0aW9uLCBleHBlY3RhdGlvbnMgPSB7fSkge1xuICAgIGxvZ1N0YXJ0KCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0TW9ja0NhbGxlZCcsIG1vY2tGdW5jdGlvbi5uYW1lLCBleHBlY3RhdGlvbnMpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoIW1vY2tGdW5jdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vY2sgZnVuY3Rpb24gY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGltZXMgPSAxLFxuICAgICAgICBjYWxsZWRXaXRoID0gbnVsbCxcbiAgICAgICAgcmV0dXJuZWRXaXRoID0gbnVsbFxuICAgICAgfSA9IGV4cGVjdGF0aW9ucztcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgbW9jayBoYXMgY2FsbCB0cmFja2luZ1xuICAgICAgaWYgKG1vY2tGdW5jdGlvbi5tb2NrICYmIG1vY2tGdW5jdGlvbi5tb2NrLmNhbGxzKSB7XG4gICAgICAgIGNvbnN0IGNhbGxDb3VudCA9IG1vY2tGdW5jdGlvbi5tb2NrLmNhbGxzLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIGlmIChjYWxsQ291bnQgIT09IHRpbWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke3RpbWVzfSBjYWxscywgYnV0IGdvdCAke2NhbGxDb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGNhbGxlZFdpdGggIT09IG51bGwgJiYgY2FsbENvdW50ID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RDYWxsID0gbW9ja0Z1bmN0aW9uLm1vY2suY2FsbHNbY2FsbENvdW50IC0gMV07XG4gICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGxhc3RDYWxsKSAhPT0gSlNPTi5zdHJpbmdpZnkoY2FsbGVkV2l0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbGFzdCBjYWxsIHdpdGggJHtKU09OLnN0cmluZ2lmeShjYWxsZWRXaXRoKX0sIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShsYXN0Q2FsbCl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocmV0dXJuZWRXaXRoICE9PSBudWxsICYmIG1vY2tGdW5jdGlvbi5tb2NrLnJlc3VsdHMpIHtcbiAgICAgICAgICBjb25zdCBsYXN0UmVzdWx0ID0gbW9ja0Z1bmN0aW9uLm1vY2sucmVzdWx0c1ttb2NrRnVuY3Rpb24ubW9jay5yZXN1bHRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0UmVzdWx0ICYmIGxhc3RSZXN1bHQudmFsdWUgIT09IHJldHVybmVkV2l0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCByZXR1cm4gdmFsdWUgJHtyZXR1cm5lZFdpdGh9LCBidXQgZ290ICR7bGFzdFJlc3VsdC52YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnV2FybmluZzogTW9jayBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGNhbGwgdHJhY2tpbmcnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0TW9ja0NhbGxlZCcsICdwYXNzZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0TW9ja0NhbGxlZCcsIGBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnRzIHRoYXQgYW4gYXJyYXkgY29udGFpbnMgZXhwZWN0ZWQgZWxlbWVudHNcbiAgICogXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQXJyYXkgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtBcnJheX0gZXhwZWN0ZWRFbGVtZW50cyAtIEVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIHByZXNlbnRcbiAgICogQHBhcmFtIHtib29sZWFufSBleGFjdE1hdGNoIC0gV2hldGhlciBhcnJheSBzaG91bGQgY29udGFpbiBvbmx5IHRoZXNlIGVsZW1lbnRzXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0QXJyYXlDb250YWlucyhhcnJheSwgZXhwZWN0ZWRFbGVtZW50cywgZXhhY3RNYXRjaCA9IGZhbHNlKSB7XG4gICAgbG9nU3RhcnQoJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnRBcnJheUNvbnRhaW5zJywgYXJyYXksIGV4cGVjdGVkRWxlbWVudHMsIGV4YWN0TWF0Y2gpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRFbGVtZW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbGVtZW50cyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGFsbCBleHBlY3RlZCBlbGVtZW50cyBhcmUgcHJlc2VudFxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGV4cGVjdGVkRWxlbWVudHMpIHtcbiAgICAgICAgaWYgKCFhcnJheS5pbmNsdWRlcyhlbGVtZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyYXkgZG9lcyBub3QgY29udGFpbiBleHBlY3RlZCBlbGVtZW50OiAke2VsZW1lbnR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZXhhY3QgbWF0Y2ggaWYgcmVxdWlyZWRcbiAgICAgIGlmIChleGFjdE1hdGNoKSB7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IGV4cGVjdGVkRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhcnJheSBsZW5ndGggJHtleHBlY3RlZEVsZW1lbnRzLmxlbmd0aH0sIGJ1dCBnb3QgJHthcnJheS5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnJheSkge1xuICAgICAgICAgIGlmICghZXhwZWN0ZWRFbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcnJheSBjb250YWlucyB1bmV4cGVjdGVkIGVsZW1lbnQ6ICR7ZWxlbWVudH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0QXJyYXlDb250YWlucycsICdwYXNzZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0QXJyYXlDb250YWlucycsIGBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgZGF0YWJhc2UgZW50aXR5IGhhcyBleHBlY3RlZCBwcm9wZXJ0aWVzXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5IC0gRGF0YWJhc2UgZW50aXR5IHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZFByb3BzIC0gRXhwZWN0ZWQgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0RGF0YWJhc2VFbnRpdHkoZW50aXR5LCBleHBlY3RlZFByb3BzKSB7XG4gICAgbG9nU3RhcnQoJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnREYXRhYmFzZUVudGl0eScsIGV4cGVjdGVkUHJvcHMpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGl0eSBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBPYmplY3Qua2V5cyhleHBlY3RlZFByb3BzKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBpZiAoZW50aXR5W3Byb3BdICE9PSBleHBlY3RlZFByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke3Byb3B9IHRvIGJlICcke2V4cGVjdGVkUHJvcHNbcHJvcF19JywgYnV0IGdvdCAnJHtlbnRpdHlbcHJvcF19J2ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbG9nUmV0dXJuKCdBc3NlcnRpb25IZWxwZXIuYXNzZXJ0RGF0YWJhc2VFbnRpdHknLCAnYXNzZXJ0aW9uIHBhc3NlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dSZXR1cm4oJ0Fzc2VydGlvbkhlbHBlci5hc3NlcnREYXRhYmFzZUVudGl0eScsIGBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5zdGFuY2UgbWV0aG9kcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGZsdWVudCBBUElcbiAgYXNzZXJ0RGF0YWJhc2VFbnRpdHkoZW50aXR5LCBleHBlY3RlZFByb3BzKSB7XG4gICAgcmV0dXJuIEFzc2VydGlvbkhlbHBlci5hc3NlcnREYXRhYmFzZUVudGl0eShlbnRpdHksIGV4cGVjdGVkUHJvcHMpO1xuICB9XG5cbiAgYXNzZXJ0QXJyYXlDb250YWlucyhhcnJheSwgZXhwZWN0ZWRFbGVtZW50cywgZXhhY3RNYXRjaCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIEFzc2VydGlvbkhlbHBlci5hc3NlcnRBcnJheUNvbnRhaW5zKGFycmF5LCBleHBlY3RlZEVsZW1lbnRzLCBleGFjdE1hdGNoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQXNzZXJ0aW9uSGVscGVyXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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