9f9a744c03fa2dbecade8a32e4962968
"use strict";
/**
 * Core Test Runner Engine
 *
 * This module orchestrates the execution of test suites, handling timeouts,
 * retries, filtering, and result collection. It's the heart of the qtests
 * runner system that ties together all the other components.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = run;
const context_js_1 = require("./context.js");
const hooks_js_1 = require("./hooks.js");
/**
 * Main test runner function - executes all registered tests
 * Returns comprehensive results including timing and statistics
 */
async function run(opts = {}) {
    const startTime = Date.now();
    // Apply test filtering based on only/skip modes before execution
    const filteredSuite = applyTestFiltering(context_js_1.rootSuite);
    try {
        const result = await runSuite(filteredSuite, opts);
        const durationMs = Date.now() - startTime;
        const counts = countResults(result);
        return {
            root: result,
            durationMs,
            ...counts,
            bailedEarly: false
        };
    }
    catch (error) {
        // If we hit a bail condition or other fatal error
        const durationMs = Date.now() - startTime;
        const counts = { passed: 0, failed: 1, skipped: 0, todo: 0 };
        return {
            root: {
                name: 'root',
                results: [{
                        name: 'Runner Error',
                        status: 'failed',
                        error: error,
                        durationMs: 0
                    }],
                suites: [],
                durationMs
            },
            durationMs,
            ...counts,
            bailedEarly: true
        };
    }
}
/**
 * Execute a single test suite with all its tests and nested suites
 */
async function runSuite(suite, opts, parentSuites = []) {
    const suiteStartTime = Date.now();
    const result = {
        name: suite.name,
        results: [],
        suites: []
    };
    try {
        // Run beforeAll hooks for this suite and all parent suites
        await (0, hooks_js_1.runSuiteHooks)(suite, 'beforeAll', parentSuites);
        // Execute all tests in this suite
        for (const test of suite.tests) {
            const testResult = await runTest(test, suite, opts, parentSuites);
            result.results.push(testResult);
            // Bail early if requested and we hit a failure
            if (opts.bail && testResult.status === 'failed') {
                throw new Error('Bailing due to test failure');
            }
        }
        // Execute all nested suites
        const currentPath = [...parentSuites, suite];
        for (const nestedSuite of suite.suites) {
            const nestedResult = await runSuite(nestedSuite, opts, currentPath);
            result.suites.push(nestedResult);
            // Check for bail condition in nested suites
            if (opts.bail && hasFailures(nestedResult)) {
                throw new Error('Bailing due to nested suite failure');
            }
        }
        // Run afterAll hooks for this suite and all parent suites
        await (0, hooks_js_1.runSuiteHooks)(suite, 'afterAll', parentSuites);
    }
    catch (error) {
        // If suite-level error (hooks, bail, etc.), add it as a test failure
        result.results.push({
            name: `Suite: ${suite.name}`,
            status: 'failed',
            error: error,
            durationMs: 0
        });
        // Re-throw if this is a bail condition
        if (error.message.includes('Bailing')) {
            throw error;
        }
    }
    result.durationMs = Date.now() - suiteStartTime;
    return result;
}
/**
 * Execute a single test with timeout, retries, and hook execution
 */
async function runTest(test, suite, opts, parentSuites = []) {
    // Handle special test modes
    if (test.mode === 'skip') {
        return { name: test.name, status: 'skipped' };
    }
    if (test.mode === 'todo') {
        return { name: test.name, status: 'todo' };
    }
    const startTime = Date.now();
    let lastError;
    const maxRetries = opts.retries || 0;
    // Try the test with retries
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            // Run beforeEach hooks from all parent suites
            await (0, hooks_js_1.runBeforeEachHooks)(suite, parentSuites);
            // Execute the actual test with timeout
            const timeout = test.timeoutMs || opts.timeoutMs || 5000;
            await runWithTimeout(test.fn, timeout);
            // Run afterEach hooks from all parent suites
            await (0, hooks_js_1.runAfterEachHooks)(suite, parentSuites);
            // Test passed - return success result
            return {
                name: test.name,
                status: 'passed',
                durationMs: Date.now() - startTime,
                retries: attempt > 0 ? attempt : undefined
            };
        }
        catch (error) {
            lastError = error;
            // Always run afterEach hooks even if test failed
            try {
                await (0, hooks_js_1.runAfterEachHooks)(suite, parentSuites);
            }
            catch (hookError) {
                // If afterEach hooks fail, combine the errors
                lastError = new Error(`Test failed: ${error.message}\nAfterEach hook also failed: ${hookError.message}`);
            }
            // If this wasn't the last retry, continue to next attempt
            if (attempt < maxRetries) {
                continue;
            }
        }
    }
    // All attempts failed
    return {
        name: test.name,
        status: 'failed',
        error: lastError,
        durationMs: Date.now() - startTime,
        retries: maxRetries > 0 ? maxRetries : undefined
    };
}
/**
 * Execute a test function with timeout protection
 * Handles both sync/async functions and optional done callback
 */
function runWithTimeout(fn, timeoutMs) {
    return new Promise((resolve, reject) => {
        let isSettled = false;
        let timeoutHandle;
        // Done callback for tests that use callback-style async
        const done = (error) => {
            if (isSettled)
                return; // Prevent multiple calls
            isSettled = true;
            clearTimeout(timeoutHandle);
            if (error) {
                reject(error instanceof Error ? error : new Error(String(error)));
            }
            else {
                resolve();
            }
        };
        // Set up timeout
        timeoutHandle = setTimeout(() => {
            if (!isSettled) {
                isSettled = true;
                reject(new Error(`Test timeout after ${timeoutMs}ms`));
            }
        }, timeoutMs);
        try {
            // Call the test function, providing done callback if it expects one
            const result = fn.length > 0 ? fn(done) : fn();
            // If test function doesn't use done callback, handle as promise
            if (fn.length === 0) {
                Promise.resolve(result)
                    .then(() => {
                    if (!isSettled) {
                        isSettled = true;
                        clearTimeout(timeoutHandle);
                        resolve();
                    }
                })
                    .catch((error) => {
                    if (!isSettled) {
                        isSettled = true;
                        clearTimeout(timeoutHandle);
                        reject(error);
                    }
                });
            }
        }
        catch (error) {
            // Synchronous test threw an error
            if (!isSettled) {
                isSettled = true;
                clearTimeout(timeoutHandle);
                reject(error);
            }
        }
    });
}
/**
 * Apply test filtering based on .only and .skip modifiers
 * Returns a filtered copy of the test suite
 */
function applyTestFiltering(suite) {
    // Check if any tests are marked as .only
    const hasOnlyTests = hasAnyOnlyTests(suite);
    return filterSuite(suite, hasOnlyTests);
}
/**
 * Recursively check if any tests in the suite tree are marked as .only
 */
function hasAnyOnlyTests(suite) {
    // Check direct tests
    if (suite.tests.some(test => test.mode === 'only')) {
        return true;
    }
    // Check nested suites
    return suite.suites.some(nestedSuite => hasAnyOnlyTests(nestedSuite));
}
/**
 * Filter a suite based on only/skip logic
 */
function filterSuite(suite, hasOnlyInTree) {
    const filteredSuite = {
        ...suite,
        tests: [...suite.tests],
        suites: suite.suites.map(s => filterSuite(s, hasOnlyInTree)),
        hooks: { ...suite.hooks }
    };
    if (hasOnlyInTree) {
        // If there are .only tests anywhere, filter out non-only tests
        filteredSuite.tests = filteredSuite.tests.filter(test => test.mode === 'only');
    }
    return filteredSuite;
}
/**
 * Check if a suite result contains any failures
 */
function hasFailures(result) {
    // Check direct test failures
    if (result.results.some(test => test.status === 'failed')) {
        return true;
    }
    // Check nested suite failures
    return result.suites.some(suite => hasFailures(suite));
}
/**
 * Count test results recursively through the suite hierarchy
 */
function countResults(result) {
    let passed = 0;
    let failed = 0;
    let skipped = 0;
    let todo = 0;
    // Recursive function to traverse the result tree
    function countInSuite(suite) {
        // Count results in current suite
        for (const test of suite.results) {
            switch (test.status) {
                case 'passed':
                    passed++;
                    break;
                case 'failed':
                    failed++;
                    break;
                case 'skipped':
                    skipped++;
                    break;
                case 'todo':
                    todo++;
                    break;
            }
        }
        // Recursively count in nested suites
        for (const nestedSuite of suite.suites) {
            countInSuite(nestedSuite);
        }
    }
    countInSuite(result);
    return { passed, failed, skipped, todo };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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akMsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDakMsUUFBUSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3BCLEtBQUssUUFBUTtvQkFBRSxNQUFNLEVBQUUsQ0FBQztvQkFBQyxNQUFNO2dCQUMvQixLQUFLLFFBQVE7b0JBQUUsTUFBTSxFQUFFLENBQUM7b0JBQUMsTUFBTTtnQkFDL0IsS0FBSyxTQUFTO29CQUFFLE9BQU8sRUFBRSxDQUFDO29CQUFDLE1BQU07Z0JBQ2pDLEtBQUssTUFBTTtvQkFBRSxJQUFJLEVBQUUsQ0FBQztvQkFBQyxNQUFNO1lBQzdCLENBQUM7UUFDSCxDQUFDO1FBRUQscUNBQXFDO1FBQ3JDLEtBQUssTUFBTSxXQUFXLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM1QixDQUFDO0lBQ0gsQ0FBQztJQUVELFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNyQixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDM0MsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL2xpYi9ydW5uZXIvcnVubmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29yZSBUZXN0IFJ1bm5lciBFbmdpbmVcbiAqIFxuICogVGhpcyBtb2R1bGUgb3JjaGVzdHJhdGVzIHRoZSBleGVjdXRpb24gb2YgdGVzdCBzdWl0ZXMsIGhhbmRsaW5nIHRpbWVvdXRzLFxuICogcmV0cmllcywgZmlsdGVyaW5nLCBhbmQgcmVzdWx0IGNvbGxlY3Rpb24uIEl0J3MgdGhlIGhlYXJ0IG9mIHRoZSBxdGVzdHNcbiAqIHJ1bm5lciBzeXN0ZW0gdGhhdCB0aWVzIHRvZ2V0aGVyIGFsbCB0aGUgb3RoZXIgY29tcG9uZW50cy5cbiAqL1xuXG5pbXBvcnQge1xuICByb290U3VpdGUsXG4gIHR5cGUgUnVuT3B0aW9ucyxcbiAgdHlwZSBSdW5SZXN1bHQsXG4gIHR5cGUgU3VpdGVSZXN1bHQsXG4gIHR5cGUgVGVzdFJlc3VsdCxcbiAgdHlwZSBTdWl0ZSxcbiAgdHlwZSBUZXN0Q2FzZVxufSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0IHtcbiAgcnVuQmVmb3JlRWFjaEhvb2tzLFxuICBydW5BZnRlckVhY2hIb29rcyxcbiAgcnVuU3VpdGVIb29rc1xufSBmcm9tICcuL2hvb2tzLmpzJztcblxuLyoqXG4gKiBNYWluIHRlc3QgcnVubmVyIGZ1bmN0aW9uIC0gZXhlY3V0ZXMgYWxsIHJlZ2lzdGVyZWQgdGVzdHNcbiAqIFJldHVybnMgY29tcHJlaGVuc2l2ZSByZXN1bHRzIGluY2x1ZGluZyB0aW1pbmcgYW5kIHN0YXRpc3RpY3NcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bihvcHRzOiBSdW5PcHRpb25zID0ge30pOiBQcm9taXNlPFJ1blJlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBcbiAgLy8gQXBwbHkgdGVzdCBmaWx0ZXJpbmcgYmFzZWQgb24gb25seS9za2lwIG1vZGVzIGJlZm9yZSBleGVjdXRpb25cbiAgY29uc3QgZmlsdGVyZWRTdWl0ZSA9IGFwcGx5VGVzdEZpbHRlcmluZyhyb290U3VpdGUpO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5TdWl0ZShmaWx0ZXJlZFN1aXRlLCBvcHRzKTtcbiAgICBjb25zdCBkdXJhdGlvbk1zID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCBjb3VudHMgPSBjb3VudFJlc3VsdHMocmVzdWx0KTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDogcmVzdWx0LFxuICAgICAgZHVyYXRpb25NcyxcbiAgICAgIC4uLmNvdW50cyxcbiAgICAgIGJhaWxlZEVhcmx5OiBmYWxzZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBJZiB3ZSBoaXQgYSBiYWlsIGNvbmRpdGlvbiBvciBvdGhlciBmYXRhbCBlcnJvclxuICAgIGNvbnN0IGR1cmF0aW9uTXMgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnN0IGNvdW50cyA9IHsgcGFzc2VkOiAwLCBmYWlsZWQ6IDEsIHNraXBwZWQ6IDAsIHRvZG86IDAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICBuYW1lOiAncm9vdCcsXG4gICAgICAgIHJlc3VsdHM6IFt7XG4gICAgICAgICAgbmFtZTogJ1J1bm5lciBFcnJvcicsXG4gICAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgZHVyYXRpb25NczogMFxuICAgICAgICB9XSxcbiAgICAgICAgc3VpdGVzOiBbXSxcbiAgICAgICAgZHVyYXRpb25Nc1xuICAgICAgfSxcbiAgICAgIGR1cmF0aW9uTXMsXG4gICAgICAuLi5jb3VudHMsXG4gICAgICBiYWlsZWRFYXJseTogdHJ1ZVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgc2luZ2xlIHRlc3Qgc3VpdGUgd2l0aCBhbGwgaXRzIHRlc3RzIGFuZCBuZXN0ZWQgc3VpdGVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1blN1aXRlKFxuICBzdWl0ZTogU3VpdGUsIFxuICBvcHRzOiBSdW5PcHRpb25zLCBcbiAgcGFyZW50U3VpdGVzOiBTdWl0ZVtdID0gW11cbik6IFByb21pc2U8U3VpdGVSZXN1bHQ+IHtcbiAgY29uc3Qgc3VpdGVTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBjb25zdCByZXN1bHQ6IFN1aXRlUmVzdWx0ID0ge1xuICAgIG5hbWU6IHN1aXRlLm5hbWUsXG4gICAgcmVzdWx0czogW10sXG4gICAgc3VpdGVzOiBbXVxuICB9O1xuICBcbiAgdHJ5IHtcbiAgICAvLyBSdW4gYmVmb3JlQWxsIGhvb2tzIGZvciB0aGlzIHN1aXRlIGFuZCBhbGwgcGFyZW50IHN1aXRlc1xuICAgIGF3YWl0IHJ1blN1aXRlSG9va3Moc3VpdGUsICdiZWZvcmVBbGwnLCBwYXJlbnRTdWl0ZXMpO1xuICAgIFxuICAgIC8vIEV4ZWN1dGUgYWxsIHRlc3RzIGluIHRoaXMgc3VpdGVcbiAgICBmb3IgKGNvbnN0IHRlc3Qgb2Ygc3VpdGUudGVzdHMpIHtcbiAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBhd2FpdCBydW5UZXN0KHRlc3QsIHN1aXRlLCBvcHRzLCBwYXJlbnRTdWl0ZXMpO1xuICAgICAgcmVzdWx0LnJlc3VsdHMucHVzaCh0ZXN0UmVzdWx0KTtcbiAgICAgIFxuICAgICAgLy8gQmFpbCBlYXJseSBpZiByZXF1ZXN0ZWQgYW5kIHdlIGhpdCBhIGZhaWx1cmVcbiAgICAgIGlmIChvcHRzLmJhaWwgJiYgdGVzdFJlc3VsdC5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFpbGluZyBkdWUgdG8gdGVzdCBmYWlsdXJlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEV4ZWN1dGUgYWxsIG5lc3RlZCBzdWl0ZXNcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IFsuLi5wYXJlbnRTdWl0ZXMsIHN1aXRlXTtcbiAgICBmb3IgKGNvbnN0IG5lc3RlZFN1aXRlIG9mIHN1aXRlLnN1aXRlcykge1xuICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gYXdhaXQgcnVuU3VpdGUobmVzdGVkU3VpdGUsIG9wdHMsIGN1cnJlbnRQYXRoKTtcbiAgICAgIHJlc3VsdC5zdWl0ZXMucHVzaChuZXN0ZWRSZXN1bHQpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgYmFpbCBjb25kaXRpb24gaW4gbmVzdGVkIHN1aXRlc1xuICAgICAgaWYgKG9wdHMuYmFpbCAmJiBoYXNGYWlsdXJlcyhuZXN0ZWRSZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFpbGluZyBkdWUgdG8gbmVzdGVkIHN1aXRlIGZhaWx1cmUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUnVuIGFmdGVyQWxsIGhvb2tzIGZvciB0aGlzIHN1aXRlIGFuZCBhbGwgcGFyZW50IHN1aXRlc1xuICAgIGF3YWl0IHJ1blN1aXRlSG9va3Moc3VpdGUsICdhZnRlckFsbCcsIHBhcmVudFN1aXRlcyk7XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBJZiBzdWl0ZS1sZXZlbCBlcnJvciAoaG9va3MsIGJhaWwsIGV0Yy4pLCBhZGQgaXQgYXMgYSB0ZXN0IGZhaWx1cmVcbiAgICByZXN1bHQucmVzdWx0cy5wdXNoKHtcbiAgICAgIG5hbWU6IGBTdWl0ZTogJHtzdWl0ZS5uYW1lfWAsXG4gICAgICBzdGF0dXM6ICdmYWlsZWQnLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgZHVyYXRpb25NczogMFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFJlLXRocm93IGlmIHRoaXMgaXMgYSBiYWlsIGNvbmRpdGlvblxuICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdCYWlsaW5nJykpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgcmVzdWx0LmR1cmF0aW9uTXMgPSBEYXRlLm5vdygpIC0gc3VpdGVTdGFydFRpbWU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXhlY3V0ZSBhIHNpbmdsZSB0ZXN0IHdpdGggdGltZW91dCwgcmV0cmllcywgYW5kIGhvb2sgZXhlY3V0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1blRlc3QoXG4gIHRlc3Q6IFRlc3RDYXNlLFxuICBzdWl0ZTogU3VpdGUsXG4gIG9wdHM6IFJ1bk9wdGlvbnMsXG4gIHBhcmVudFN1aXRlczogU3VpdGVbXSA9IFtdXG4pOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgLy8gSGFuZGxlIHNwZWNpYWwgdGVzdCBtb2Rlc1xuICBpZiAodGVzdC5tb2RlID09PSAnc2tpcCcpIHtcbiAgICByZXR1cm4geyBuYW1lOiB0ZXN0Lm5hbWUsIHN0YXR1czogJ3NraXBwZWQnIH07XG4gIH1cbiAgXG4gIGlmICh0ZXN0Lm1vZGUgPT09ICd0b2RvJykge1xuICAgIHJldHVybiB7IG5hbWU6IHRlc3QubmFtZSwgc3RhdHVzOiAndG9kbycgfTtcbiAgfVxuICBcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IG1heFJldHJpZXMgPSBvcHRzLnJldHJpZXMgfHwgMDtcbiAgXG4gIC8vIFRyeSB0aGUgdGVzdCB3aXRoIHJldHJpZXNcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFJ1biBiZWZvcmVFYWNoIGhvb2tzIGZyb20gYWxsIHBhcmVudCBzdWl0ZXNcbiAgICAgIGF3YWl0IHJ1bkJlZm9yZUVhY2hIb29rcyhzdWl0ZSwgcGFyZW50U3VpdGVzKTtcbiAgICAgIFxuICAgICAgLy8gRXhlY3V0ZSB0aGUgYWN0dWFsIHRlc3Qgd2l0aCB0aW1lb3V0XG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGVzdC50aW1lb3V0TXMgfHwgb3B0cy50aW1lb3V0TXMgfHwgNTAwMDtcbiAgICAgIGF3YWl0IHJ1bldpdGhUaW1lb3V0KHRlc3QuZm4sIHRpbWVvdXQpO1xuICAgICAgXG4gICAgICAvLyBSdW4gYWZ0ZXJFYWNoIGhvb2tzIGZyb20gYWxsIHBhcmVudCBzdWl0ZXNcbiAgICAgIGF3YWl0IHJ1bkFmdGVyRWFjaEhvb2tzKHN1aXRlLCBwYXJlbnRTdWl0ZXMpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHBhc3NlZCAtIHJldHVybiBzdWNjZXNzIHJlc3VsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdGVzdC5uYW1lLFxuICAgICAgICBzdGF0dXM6ICdwYXNzZWQnLFxuICAgICAgICBkdXJhdGlvbk1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICByZXRyaWVzOiBhdHRlbXB0ID4gMCA/IGF0dGVtcHQgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgIFxuICAgICAgLy8gQWx3YXlzIHJ1biBhZnRlckVhY2ggaG9va3MgZXZlbiBpZiB0ZXN0IGZhaWxlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcnVuQWZ0ZXJFYWNoSG9va3Moc3VpdGUsIHBhcmVudFN1aXRlcyk7XG4gICAgICB9IGNhdGNoIChob29rRXJyb3I6IGFueSkge1xuICAgICAgICAvLyBJZiBhZnRlckVhY2ggaG9va3MgZmFpbCwgY29tYmluZSB0aGUgZXJyb3JzXG4gICAgICAgIGxhc3RFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgVGVzdCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1cXG5BZnRlckVhY2ggaG9vayBhbHNvIGZhaWxlZDogJHtob29rRXJyb3IubWVzc2FnZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHRoaXMgd2Fzbid0IHRoZSBsYXN0IHJldHJ5LCBjb250aW51ZSB0byBuZXh0IGF0dGVtcHRcbiAgICAgIGlmIChhdHRlbXB0IDwgbWF4UmV0cmllcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFsbCBhdHRlbXB0cyBmYWlsZWRcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB0ZXN0Lm5hbWUsXG4gICAgc3RhdHVzOiAnZmFpbGVkJyxcbiAgICBlcnJvcjogbGFzdEVycm9yLFxuICAgIGR1cmF0aW9uTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgcmV0cmllczogbWF4UmV0cmllcyA+IDAgPyBtYXhSZXRyaWVzIDogdW5kZWZpbmVkXG4gIH07XG59XG5cbi8qKlxuICogRXhlY3V0ZSBhIHRlc3QgZnVuY3Rpb24gd2l0aCB0aW1lb3V0IHByb3RlY3Rpb25cbiAqIEhhbmRsZXMgYm90aCBzeW5jL2FzeW5jIGZ1bmN0aW9ucyBhbmQgb3B0aW9uYWwgZG9uZSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBydW5XaXRoVGltZW91dChmbjogVGVzdENhc2VbJ2ZuJ10sIHRpbWVvdXRNczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGlzU2V0dGxlZCA9IGZhbHNlO1xuICAgIGxldCB0aW1lb3V0SGFuZGxlOiBOb2RlSlMuVGltZW91dDtcbiAgICBcbiAgICAvLyBEb25lIGNhbGxiYWNrIGZvciB0ZXN0cyB0aGF0IHVzZSBjYWxsYmFjay1zdHlsZSBhc3luY1xuICAgIGNvbnN0IGRvbmUgPSAoZXJyb3I/OiBhbnkpID0+IHtcbiAgICAgIGlmIChpc1NldHRsZWQpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgICAgaXNTZXR0bGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gU2V0IHVwIHRpbWVvdXRcbiAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWlzU2V0dGxlZCkge1xuICAgICAgICBpc1NldHRsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBUZXN0IHRpbWVvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dE1zKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ2FsbCB0aGUgdGVzdCBmdW5jdGlvbiwgcHJvdmlkaW5nIGRvbmUgY2FsbGJhY2sgaWYgaXQgZXhwZWN0cyBvbmVcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZuLmxlbmd0aCA+IDAgPyBmbihkb25lKSA6IGZuKCk7XG4gICAgICBcbiAgICAgIC8vIElmIHRlc3QgZnVuY3Rpb24gZG9lc24ndCB1c2UgZG9uZSBjYWxsYmFjaywgaGFuZGxlIGFzIHByb21pc2VcbiAgICAgIGlmIChmbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzU2V0dGxlZCkge1xuICAgICAgICAgICAgICBpc1NldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNTZXR0bGVkKSB7XG4gICAgICAgICAgICAgIGlzU2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU3luY2hyb25vdXMgdGVzdCB0aHJldyBhbiBlcnJvclxuICAgICAgaWYgKCFpc1NldHRsZWQpIHtcbiAgICAgICAgaXNTZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgdGVzdCBmaWx0ZXJpbmcgYmFzZWQgb24gLm9ubHkgYW5kIC5za2lwIG1vZGlmaWVyc1xuICogUmV0dXJucyBhIGZpbHRlcmVkIGNvcHkgb2YgdGhlIHRlc3Qgc3VpdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlUZXN0RmlsdGVyaW5nKHN1aXRlOiBTdWl0ZSk6IFN1aXRlIHtcbiAgLy8gQ2hlY2sgaWYgYW55IHRlc3RzIGFyZSBtYXJrZWQgYXMgLm9ubHlcbiAgY29uc3QgaGFzT25seVRlc3RzID0gaGFzQW55T25seVRlc3RzKHN1aXRlKTtcbiAgXG4gIHJldHVybiBmaWx0ZXJTdWl0ZShzdWl0ZSwgaGFzT25seVRlc3RzKTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjaGVjayBpZiBhbnkgdGVzdHMgaW4gdGhlIHN1aXRlIHRyZWUgYXJlIG1hcmtlZCBhcyAub25seVxuICovXG5mdW5jdGlvbiBoYXNBbnlPbmx5VGVzdHMoc3VpdGU6IFN1aXRlKTogYm9vbGVhbiB7XG4gIC8vIENoZWNrIGRpcmVjdCB0ZXN0c1xuICBpZiAoc3VpdGUudGVzdHMuc29tZSh0ZXN0ID0+IHRlc3QubW9kZSA9PT0gJ29ubHknKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICAvLyBDaGVjayBuZXN0ZWQgc3VpdGVzXG4gIHJldHVybiBzdWl0ZS5zdWl0ZXMuc29tZShuZXN0ZWRTdWl0ZSA9PiBoYXNBbnlPbmx5VGVzdHMobmVzdGVkU3VpdGUpKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgYSBzdWl0ZSBiYXNlZCBvbiBvbmx5L3NraXAgbG9naWNcbiAqL1xuZnVuY3Rpb24gZmlsdGVyU3VpdGUoc3VpdGU6IFN1aXRlLCBoYXNPbmx5SW5UcmVlOiBib29sZWFuKTogU3VpdGUge1xuICBjb25zdCBmaWx0ZXJlZFN1aXRlOiBTdWl0ZSA9IHtcbiAgICAuLi5zdWl0ZSxcbiAgICB0ZXN0czogWy4uLnN1aXRlLnRlc3RzXSxcbiAgICBzdWl0ZXM6IHN1aXRlLnN1aXRlcy5tYXAocyA9PiBmaWx0ZXJTdWl0ZShzLCBoYXNPbmx5SW5UcmVlKSksXG4gICAgaG9va3M6IHsgLi4uc3VpdGUuaG9va3MgfVxuICB9O1xuICBcbiAgaWYgKGhhc09ubHlJblRyZWUpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgLm9ubHkgdGVzdHMgYW55d2hlcmUsIGZpbHRlciBvdXQgbm9uLW9ubHkgdGVzdHNcbiAgICBmaWx0ZXJlZFN1aXRlLnRlc3RzID0gZmlsdGVyZWRTdWl0ZS50ZXN0cy5maWx0ZXIoXG4gICAgICB0ZXN0ID0+IHRlc3QubW9kZSA9PT0gJ29ubHknXG4gICAgKTtcbiAgfVxuICBcbiAgcmV0dXJuIGZpbHRlcmVkU3VpdGU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdWl0ZSByZXN1bHQgY29udGFpbnMgYW55IGZhaWx1cmVzXG4gKi9cbmZ1bmN0aW9uIGhhc0ZhaWx1cmVzKHJlc3VsdDogU3VpdGVSZXN1bHQpOiBib29sZWFuIHtcbiAgLy8gQ2hlY2sgZGlyZWN0IHRlc3QgZmFpbHVyZXNcbiAgaWYgKHJlc3VsdC5yZXN1bHRzLnNvbWUodGVzdCA9PiB0ZXN0LnN0YXR1cyA9PT0gJ2ZhaWxlZCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIC8vIENoZWNrIG5lc3RlZCBzdWl0ZSBmYWlsdXJlc1xuICByZXR1cm4gcmVzdWx0LnN1aXRlcy5zb21lKHN1aXRlID0+IGhhc0ZhaWx1cmVzKHN1aXRlKSk7XG59XG5cbi8qKlxuICogQ291bnQgdGVzdCByZXN1bHRzIHJlY3Vyc2l2ZWx5IHRocm91Z2ggdGhlIHN1aXRlIGhpZXJhcmNoeVxuICovXG5mdW5jdGlvbiBjb3VudFJlc3VsdHMocmVzdWx0OiBTdWl0ZVJlc3VsdCk6IHtcbiAgcGFzc2VkOiBudW1iZXI7XG4gIGZhaWxlZDogbnVtYmVyO1xuICBza2lwcGVkOiBudW1iZXI7XG4gIHRvZG86IG51bWJlcjtcbn0ge1xuICBsZXQgcGFzc2VkID0gMDtcbiAgbGV0IGZhaWxlZCA9IDA7XG4gIGxldCBza2lwcGVkID0gMDtcbiAgbGV0IHRvZG8gPSAwO1xuICBcbiAgLy8gUmVjdXJzaXZlIGZ1bmN0aW9uIHRvIHRyYXZlcnNlIHRoZSByZXN1bHQgdHJlZVxuICBmdW5jdGlvbiBjb3VudEluU3VpdGUoc3VpdGU6IFN1aXRlUmVzdWx0KTogdm9pZCB7XG4gICAgLy8gQ291bnQgcmVzdWx0cyBpbiBjdXJyZW50IHN1aXRlXG4gICAgZm9yIChjb25zdCB0ZXN0IG9mIHN1aXRlLnJlc3VsdHMpIHtcbiAgICAgIHN3aXRjaCAodGVzdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAncGFzc2VkJzogcGFzc2VkKys7IGJyZWFrO1xuICAgICAgICBjYXNlICdmYWlsZWQnOiBmYWlsZWQrKzsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NraXBwZWQnOiBza2lwcGVkKys7IGJyZWFrO1xuICAgICAgICBjYXNlICd0b2RvJzogdG9kbysrOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmVjdXJzaXZlbHkgY291bnQgaW4gbmVzdGVkIHN1aXRlc1xuICAgIGZvciAoY29uc3QgbmVzdGVkU3VpdGUgb2Ygc3VpdGUuc3VpdGVzKSB7XG4gICAgICBjb3VudEluU3VpdGUobmVzdGVkU3VpdGUpO1xuICAgIH1cbiAgfVxuICBcbiAgY291bnRJblN1aXRlKHJlc3VsdCk7XG4gIHJldHVybiB7IHBhc3NlZCwgZmFpbGVkLCBza2lwcGVkLCB0b2RvIH07XG59Il0sInZlcnNpb24iOjN9