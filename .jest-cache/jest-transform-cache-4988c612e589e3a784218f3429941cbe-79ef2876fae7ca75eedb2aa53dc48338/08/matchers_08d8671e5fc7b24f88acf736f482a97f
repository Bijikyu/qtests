5c44797d022b775ba809d052605f16cc
"use strict";
/**
 * Core Matchers - Standard Assertion Implementations
 *
 * This module provides the standard set of matchers that developers expect
 * from modern test frameworks. Each matcher handles both positive and negative
 * assertions with helpful error messages.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("./index.js");
const diff_js_1 = require("./diff.js");
// Register all core matchers when this module is imported
(0, index_js_1.extendMatchers)({
    /**
     * toBe - Strict equality using Object.is()
     * Use for primitive values and reference equality
     */
    toBe(received, expected) {
        const pass = Object.is(received, expected);
        const message = () => {
            if (this.isNot) {
                return `Expected value not to be:\n  ${(0, diff_js_1.formatValue)(expected)}\nReceived:\n  ${(0, diff_js_1.formatValue)(received)}`;
            }
            else {
                return `Expected value to be:\n  ${(0, diff_js_1.formatValue)(expected)}\nReceived:\n  ${(0, diff_js_1.formatValue)(received)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toEqual - Deep equality comparison
     * Use for objects, arrays, and complex data structures
     */
    toEqual(received, expected) {
        const pass = (0, diff_js_1.deepEqual)(received, expected);
        const message = () => {
            if (this.isNot) {
                return `Expected values not to be deeply equal:\n${(0, diff_js_1.formatValue)(expected)}`;
            }
            else {
                return `Expected values to be deeply equal:\n${(0, diff_js_1.generateDiff)(expected, received)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeTruthy - Checks if value is truthy
     */
    toBeTruthy(received) {
        const pass = Boolean(received);
        const message = () => {
            if (this.isNot) {
                return `Expected value not to be truthy, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
            else {
                return `Expected value to be truthy, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeFalsy - Checks if value is falsy
     */
    toBeFalsy(received) {
        const pass = !Boolean(received);
        const message = () => {
            if (this.isNot) {
                return `Expected value not to be falsy, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
            else {
                return `Expected value to be falsy, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeNull - Checks if value is null
     */
    toBeNull(received) {
        const pass = received === null;
        const message = () => {
            if (this.isNot) {
                return `Expected value not to be null, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
            else {
                return `Expected value to be null, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeUndefined - Checks if value is undefined
     */
    toBeUndefined(received) {
        const pass = received === undefined;
        const message = () => {
            if (this.isNot) {
                return `Expected value not to be undefined, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
            else {
                return `Expected value to be undefined, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeDefined - Checks if value is not undefined
     */
    toBeDefined(received) {
        const pass = received !== undefined;
        const message = () => {
            if (this.isNot) {
                return `Expected value to be undefined, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
            else {
                return `Expected value to be defined, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeGreaterThan - Numeric comparison >
     */
    toBeGreaterThan(received, expected) {
        const pass = received > expected;
        const message = () => {
            if (this.isNot) {
                return `Expected ${(0, diff_js_1.formatValue)(received)} not to be greater than ${(0, diff_js_1.formatValue)(expected)}`;
            }
            else {
                return `Expected ${(0, diff_js_1.formatValue)(received)} to be greater than ${(0, diff_js_1.formatValue)(expected)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeGreaterThanOrEqual - Numeric comparison >=
     */
    toBeGreaterThanOrEqual(received, expected) {
        const pass = received >= expected;
        const message = () => {
            if (this.isNot) {
                return `Expected ${(0, diff_js_1.formatValue)(received)} not to be greater than or equal to ${(0, diff_js_1.formatValue)(expected)}`;
            }
            else {
                return `Expected ${(0, diff_js_1.formatValue)(received)} to be greater than or equal to ${(0, diff_js_1.formatValue)(expected)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeLessThan - Numeric comparison <
     */
    toBeLessThan(received, expected) {
        const pass = received < expected;
        const message = () => {
            if (this.isNot) {
                return `Expected ${(0, diff_js_1.formatValue)(received)} not to be less than ${(0, diff_js_1.formatValue)(expected)}`;
            }
            else {
                return `Expected ${(0, diff_js_1.formatValue)(received)} to be less than ${(0, diff_js_1.formatValue)(expected)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeLessThanOrEqual - Numeric comparison <=
     */
    toBeLessThanOrEqual(received, expected) {
        const pass = received <= expected;
        const message = () => {
            if (this.isNot) {
                return `Expected ${(0, diff_js_1.formatValue)(received)} not to be less than or equal to ${(0, diff_js_1.formatValue)(expected)}`;
            }
            else {
                return `Expected ${(0, diff_js_1.formatValue)(received)} to be less than or equal to ${(0, diff_js_1.formatValue)(expected)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toBeCloseTo - Numeric comparison with precision tolerance
     */
    toBeCloseTo(received, expected, precision = 2) {
        const pow = Math.pow(10, -precision);
        const delta = Math.abs(expected - received);
        const pass = delta < pow;
        const message = () => {
            if (this.isNot) {
                return `Expected ${(0, diff_js_1.formatValue)(received)} not to be close to ${(0, diff_js_1.formatValue)(expected)} (precision: ${precision})`;
            }
            else {
                return `Expected ${(0, diff_js_1.formatValue)(received)} to be close to ${(0, diff_js_1.formatValue)(expected)} (precision: ${precision}), difference: ${delta}`;
            }
        };
        return { pass, message };
    },
    /**
     * toMatch - String/RegExp pattern matching
     */
    toMatch(received, expected) {
        const receivedString = String(received);
        const regex = expected instanceof RegExp ? expected : new RegExp(expected);
        const pass = regex.test(receivedString);
        const message = () => {
            if (this.isNot) {
                return `Expected string not to match pattern:\n  Pattern: ${(0, diff_js_1.formatValue)(expected)}\n  Received: ${(0, diff_js_1.formatValue)(receivedString)}`;
            }
            else {
                return `Expected string to match pattern:\n  Pattern: ${(0, diff_js_1.formatValue)(expected)}\n  Received: ${(0, diff_js_1.formatValue)(receivedString)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toContain - Array/String containment check
     */
    toContain(received, expected) {
        let pass = false;
        if (typeof received === 'string') {
            pass = received.includes(String(expected));
        }
        else if (Array.isArray(received)) {
            pass = received.includes(expected);
        }
        else if (received && typeof received[Symbol.iterator] === 'function') {
            // Handle other iterables
            pass = Array.from(received).includes(expected);
        }
        const message = () => {
            if (this.isNot) {
                return `Expected ${(0, diff_js_1.formatValue)(received)} not to contain ${(0, diff_js_1.formatValue)(expected)}`;
            }
            else {
                return `Expected ${(0, diff_js_1.formatValue)(received)} to contain ${(0, diff_js_1.formatValue)(expected)}`;
            }
        };
        return { pass, message };
    },
    /**
     * toHaveLength - Length property check
     */
    toHaveLength(received, expected) {
        const hasLength = received && typeof received.length === 'number';
        const pass = hasLength && received.length === expected;
        const message = () => {
            if (!hasLength) {
                return `Expected value to have a length property, received: ${(0, diff_js_1.formatValue)(received)}`;
            }
            if (this.isNot) {
                return `Expected length not to be ${expected}, received: ${received.length}`;
            }
            else {
                return `Expected length to be ${expected}, received: ${received.length}`;
            }
        };
        return { pass, message };
    },
    /**
     * toHaveProperty - Object property existence and optionally value check
     */
    toHaveProperty(received, keyPath, expectedValue) {
        const hasProperty = received && typeof received === 'object' && keyPath in received;
        let pass = hasProperty;
        if (pass && arguments.length === 3) {
            pass = (0, diff_js_1.deepEqual)(received[keyPath], expectedValue);
        }
        const message = () => {
            if (!hasProperty) {
                if (this.isNot) {
                    return `Expected object not to have property "${keyPath}"`;
                }
                else {
                    return `Expected object to have property "${keyPath}"\nReceived: ${(0, diff_js_1.formatValue)(received)}`;
                }
            }
            else if (arguments.length === 3) {
                if (this.isNot) {
                    return `Expected property "${keyPath}" not to have value:\n  ${(0, diff_js_1.formatValue)(expectedValue)}\nReceived:\n  ${(0, diff_js_1.formatValue)(received[keyPath])}`;
                }
                else {
                    return `Expected property "${keyPath}" to have value:\n  ${(0, diff_js_1.formatValue)(expectedValue)}\nReceived:\n  ${(0, diff_js_1.formatValue)(received[keyPath])}`;
                }
            }
            else {
                return `Expected object not to have property "${keyPath}"`;
            }
        };
        return { pass, message };
    },
    /**
     * toMatchSnapshot - Snapshot testing
     */
    toMatchSnapshot(received, snapshotName) {
        // Note: This is async but the current matcher API is sync
        // We'll need to handle this at the test runner level
        const testName = this.currentTestName || 'Unknown Test';
        // Store snapshot data for async processing
        this.__snapshotData = {
            testName,
            value: received,
            snapshotName
        };
        // Return a placeholder - actual matching happens in test runner
        return {
            pass: true,
            message: () => 'Snapshot matching deferred to test runner'
        };
    },
    /**
     * toThrow - Function execution error check
     */
    toThrow(received, expectedError) {
        if (typeof received !== 'function') {
            throw new Error('toThrow matcher must be called on a function');
        }
        let thrownError;
        let didThrow = false;
        try {
            received();
        }
        catch (error) {
            didThrow = true;
            thrownError = error;
        }
        let pass = didThrow;
        // If specific error expectation is provided, check it
        if (pass && expectedError !== undefined) {
            if (typeof expectedError === 'string') {
                pass = thrownError && thrownError.message.includes(expectedError);
            }
            else if (expectedError instanceof RegExp) {
                pass = thrownError && expectedError.test(thrownError.message);
            }
            else if (typeof expectedError === 'function') {
                pass = thrownError instanceof expectedError;
            }
            else if (expectedError instanceof Error) {
                pass = thrownError && thrownError.message === expectedError.message;
            }
        }
        const message = () => {
            if (this.isNot) {
                if (expectedError) {
                    return `Expected function not to throw ${(0, diff_js_1.formatValue)(expectedError)}, but it threw: ${thrownError?.message || thrownError}`;
                }
                else {
                    return `Expected function not to throw, but it threw: ${thrownError?.message || thrownError}`;
                }
            }
            else {
                if (!didThrow) {
                    return `Expected function to throw${expectedError ? ` ${(0, diff_js_1.formatValue)(expectedError)}` : ''}, but it didn't throw`;
                }
                else if (expectedError) {
                    return `Expected function to throw ${(0, diff_js_1.formatValue)(expectedError)}, but it threw: ${thrownError?.message || thrownError}`;
                }
                else {
                    return 'Expected function to throw, but it didn\'t throw';
                }
            }
        };
        return { pass, message };
    }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS91dGlscy90ZXN0aW5nL2V4cGVjdC9tYXRjaGVycy50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HOztBQUVILHlDQUE0QztBQUM1Qyx1Q0FBaUU7QUFHakUsMERBQTBEO0FBQzFELElBQUEseUJBQWMsRUFBQztJQUNiOzs7T0FHRztJQUNILElBQUksQ0FBQyxRQUFhLEVBQUUsUUFBYTtRQUMvQixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMzQyxNQUFNLE9BQU8sR0FBRyxHQUFHLEVBQUU7WUFDbkIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ2YsT0FBTyxnQ0FBZ0MsSUFBQSxxQkFBVyxFQUFDLFFBQVEsQ0FBQyxrQkFBa0IsSUFBQSxxQkFBVyxFQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDeEcsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLE9BQU8sNEJBQTRCLElBQUEscUJBQVcsRUFBQyxRQUFRLENBQUMsa0JBQWtCLElBQUEscUJBQVcsRUFBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1lBQ3BHLENBQUM7UUFDSCxDQUFDLENBQUM7UUFDRixPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPLENBQUMsUUFBYSxFQUFFLFFBQWE7UUFDbEMsTUFBTSxJQUFJLEdBQUcsSUFBQSxtQkFBUyxFQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMzQyxNQUFNLE9BQU8sR0FBRyxHQUFHLEVBQUU7WUFDbkIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ2YsT0FBTyw0Q0FBNEMsSUFBQSxxQkFBVyxFQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDN0UsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLE9BQU8sd0NBQXdDLElBQUEsc0JBQVksRUFBQyxRQUFRLEVBQUUsUUFBUSxD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L3Rlc3RpbmcvZXhwZWN0L21hdGNoZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29yZSBNYXRjaGVycyAtIFN0YW5kYXJkIEFzc2VydGlvbiBJbXBsZW1lbnRhdGlvbnNcbiAqIFxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdGhlIHN0YW5kYXJkIHNldCBvZiBtYXRjaGVycyB0aGF0IGRldmVsb3BlcnMgZXhwZWN0XG4gKiBmcm9tIG1vZGVybiB0ZXN0IGZyYW1ld29ya3MuIEVhY2ggbWF0Y2hlciBoYW5kbGVzIGJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlXG4gKiBhc3NlcnRpb25zIHdpdGggaGVscGZ1bCBlcnJvciBtZXNzYWdlcy5cbiAqL1xuXG5pbXBvcnQgeyBleHRlbmRNYXRjaGVycyB9IGZyb20gJy4vaW5kZXguanMnO1xuaW1wb3J0IHsgZGVlcEVxdWFsLCBmb3JtYXRWYWx1ZSwgZ2VuZXJhdGVEaWZmIH0gZnJvbSAnLi9kaWZmLmpzJztcbmltcG9ydCB7IG1hdGNoU25hcHNob3QgfSBmcm9tICcuLi8uLi8uLi9saWIvc25hcHNob3RzL3NuYXBzaG90TWFuYWdlci5qcyc7XG5cbi8vIFJlZ2lzdGVyIGFsbCBjb3JlIG1hdGNoZXJzIHdoZW4gdGhpcyBtb2R1bGUgaXMgaW1wb3J0ZWRcbmV4dGVuZE1hdGNoZXJzKHtcbiAgLyoqXG4gICAqIHRvQmUgLSBTdHJpY3QgZXF1YWxpdHkgdXNpbmcgT2JqZWN0LmlzKClcbiAgICogVXNlIGZvciBwcmltaXRpdmUgdmFsdWVzIGFuZCByZWZlcmVuY2UgZXF1YWxpdHlcbiAgICovXG4gIHRvQmUocmVjZWl2ZWQ6IGFueSwgZXhwZWN0ZWQ6IGFueSkge1xuICAgIGNvbnN0IHBhc3MgPSBPYmplY3QuaXMocmVjZWl2ZWQsIGV4cGVjdGVkKTtcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCB2YWx1ZSBub3QgdG8gYmU6XFxuICAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX1cXG5SZWNlaXZlZDpcXG4gICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHZhbHVlIHRvIGJlOlxcbiAgJHtmb3JtYXRWYWx1ZShleHBlY3RlZCl9XFxuUmVjZWl2ZWQ6XFxuICAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX1gO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcGFzcywgbWVzc2FnZSB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiB0b0VxdWFsIC0gRGVlcCBlcXVhbGl0eSBjb21wYXJpc29uXG4gICAqIFVzZSBmb3Igb2JqZWN0cywgYXJyYXlzLCBhbmQgY29tcGxleCBkYXRhIHN0cnVjdHVyZXNcbiAgICovXG4gIHRvRXF1YWwocmVjZWl2ZWQ6IGFueSwgZXhwZWN0ZWQ6IGFueSkge1xuICAgIGNvbnN0IHBhc3MgPSBkZWVwRXF1YWwocmVjZWl2ZWQsIGV4cGVjdGVkKTtcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCB2YWx1ZXMgbm90IHRvIGJlIGRlZXBseSBlcXVhbDpcXG4ke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgZGVlcGx5IGVxdWFsOlxcbiR7Z2VuZXJhdGVEaWZmKGV4cGVjdGVkLCByZWNlaXZlZCl9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHBhc3MsIG1lc3NhZ2UgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9CZVRydXRoeSAtIENoZWNrcyBpZiB2YWx1ZSBpcyB0cnV0aHlcbiAgICovXG4gIHRvQmVUcnV0aHkocmVjZWl2ZWQ6IGFueSkge1xuICAgIGNvbnN0IHBhc3MgPSBCb29sZWFuKHJlY2VpdmVkKTtcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCB2YWx1ZSBub3QgdG8gYmUgdHJ1dGh5LCByZWNlaXZlZDogJHtmb3JtYXRWYWx1ZShyZWNlaXZlZCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgdHJ1dGh5LCByZWNlaXZlZDogJHtmb3JtYXRWYWx1ZShyZWNlaXZlZCl9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHBhc3MsIG1lc3NhZ2UgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9CZUZhbHN5IC0gQ2hlY2tzIGlmIHZhbHVlIGlzIGZhbHN5XG4gICAqL1xuICB0b0JlRmFsc3kocmVjZWl2ZWQ6IGFueSkge1xuICAgIGNvbnN0IHBhc3MgPSAhQm9vbGVhbihyZWNlaXZlZCk7XG4gICAgY29uc3QgbWVzc2FnZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzTm90KSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgdmFsdWUgbm90IHRvIGJlIGZhbHN5LCByZWNlaXZlZDogJHtmb3JtYXRWYWx1ZShyZWNlaXZlZCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgZmFsc3ksIHJlY2VpdmVkOiAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX1gO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcGFzcywgbWVzc2FnZSB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiB0b0JlTnVsbCAtIENoZWNrcyBpZiB2YWx1ZSBpcyBudWxsXG4gICAqL1xuICB0b0JlTnVsbChyZWNlaXZlZDogYW55KSB7XG4gICAgY29uc3QgcGFzcyA9IHJlY2VpdmVkID09PSBudWxsO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHZhbHVlIG5vdCB0byBiZSBudWxsLCByZWNlaXZlZDogJHtmb3JtYXRWYWx1ZShyZWNlaXZlZCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgbnVsbCwgcmVjZWl2ZWQ6ICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfWA7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBwYXNzLCBtZXNzYWdlIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRvQmVVbmRlZmluZWQgLSBDaGVja3MgaWYgdmFsdWUgaXMgdW5kZWZpbmVkXG4gICAqL1xuICB0b0JlVW5kZWZpbmVkKHJlY2VpdmVkOiBhbnkpIHtcbiAgICBjb25zdCBwYXNzID0gcmVjZWl2ZWQgPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCB2YWx1ZSBub3QgdG8gYmUgdW5kZWZpbmVkLCByZWNlaXZlZDogJHtmb3JtYXRWYWx1ZShyZWNlaXZlZCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgdW5kZWZpbmVkLCByZWNlaXZlZDogJHtmb3JtYXRWYWx1ZShyZWNlaXZlZCl9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHBhc3MsIG1lc3NhZ2UgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9CZURlZmluZWQgLSBDaGVja3MgaWYgdmFsdWUgaXMgbm90IHVuZGVmaW5lZFxuICAgKi9cbiAgdG9CZURlZmluZWQocmVjZWl2ZWQ6IGFueSkge1xuICAgIGNvbnN0IHBhc3MgPSByZWNlaXZlZCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHZhbHVlIHRvIGJlIHVuZGVmaW5lZCwgcmVjZWl2ZWQ6ICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHZhbHVlIHRvIGJlIGRlZmluZWQsIHJlY2VpdmVkOiAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX1gO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcGFzcywgbWVzc2FnZSB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiB0b0JlR3JlYXRlclRoYW4gLSBOdW1lcmljIGNvbXBhcmlzb24gPlxuICAgKi9cbiAgdG9CZUdyZWF0ZXJUaGFuKHJlY2VpdmVkOiBhbnksIGV4cGVjdGVkOiBudW1iZXIpIHtcbiAgICBjb25zdCBwYXNzID0gcmVjZWl2ZWQgPiBleHBlY3RlZDtcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX0gbm90IHRvIGJlIGdyZWF0ZXIgdGhhbiAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX0gdG8gYmUgZ3JlYXRlciB0aGFuICR7Zm9ybWF0VmFsdWUoZXhwZWN0ZWQpfWA7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBwYXNzLCBtZXNzYWdlIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRvQmVHcmVhdGVyVGhhbk9yRXF1YWwgLSBOdW1lcmljIGNvbXBhcmlzb24gPj1cbiAgICovXG4gIHRvQmVHcmVhdGVyVGhhbk9yRXF1YWwocmVjZWl2ZWQ6IGFueSwgZXhwZWN0ZWQ6IG51bWJlcikge1xuICAgIGNvbnN0IHBhc3MgPSByZWNlaXZlZCA+PSBleHBlY3RlZDtcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX0gbm90IHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX0gdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7Zm9ybWF0VmFsdWUoZXhwZWN0ZWQpfWA7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBwYXNzLCBtZXNzYWdlIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRvQmVMZXNzVGhhbiAtIE51bWVyaWMgY29tcGFyaXNvbiA8XG4gICAqL1xuICB0b0JlTGVzc1RoYW4ocmVjZWl2ZWQ6IGFueSwgZXhwZWN0ZWQ6IG51bWJlcikge1xuICAgIGNvbnN0IHBhc3MgPSByZWNlaXZlZCA8IGV4cGVjdGVkO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfSBub3QgdG8gYmUgbGVzcyB0aGFuICR7Zm9ybWF0VmFsdWUoZXhwZWN0ZWQpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfSB0byBiZSBsZXNzIHRoYW4gJHtmb3JtYXRWYWx1ZShleHBlY3RlZCl9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHBhc3MsIG1lc3NhZ2UgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9CZUxlc3NUaGFuT3JFcXVhbCAtIE51bWVyaWMgY29tcGFyaXNvbiA8PVxuICAgKi9cbiAgdG9CZUxlc3NUaGFuT3JFcXVhbChyZWNlaXZlZDogYW55LCBleHBlY3RlZDogbnVtYmVyKSB7XG4gICAgY29uc3QgcGFzcyA9IHJlY2VpdmVkIDw9IGV4cGVjdGVkO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfSBub3QgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7Zm9ybWF0VmFsdWUoZXhwZWN0ZWQpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfSB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHtmb3JtYXRWYWx1ZShleHBlY3RlZCl9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHBhc3MsIG1lc3NhZ2UgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9CZUNsb3NlVG8gLSBOdW1lcmljIGNvbXBhcmlzb24gd2l0aCBwcmVjaXNpb24gdG9sZXJhbmNlXG4gICAqL1xuICB0b0JlQ2xvc2VUbyhyZWNlaXZlZDogYW55LCBleHBlY3RlZDogbnVtYmVyLCBwcmVjaXNpb246IG51bWJlciA9IDIpIHtcbiAgICBjb25zdCBwb3cgPSBNYXRoLnBvdygxMCwgLXByZWNpc2lvbik7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhleHBlY3RlZCAtIHJlY2VpdmVkKTtcbiAgICBjb25zdCBwYXNzID0gZGVsdGEgPCBwb3c7XG4gICAgXG4gICAgY29uc3QgbWVzc2FnZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzTm90KSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgJHtmb3JtYXRWYWx1ZShyZWNlaXZlZCl9IG5vdCB0byBiZSBjbG9zZSB0byAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX0gKHByZWNpc2lvbjogJHtwcmVjaXNpb259KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfSB0byBiZSBjbG9zZSB0byAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX0gKHByZWNpc2lvbjogJHtwcmVjaXNpb259KSwgZGlmZmVyZW5jZTogJHtkZWx0YX1gO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcGFzcywgbWVzc2FnZSB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiB0b01hdGNoIC0gU3RyaW5nL1JlZ0V4cCBwYXR0ZXJuIG1hdGNoaW5nXG4gICAqL1xuICB0b01hdGNoKHJlY2VpdmVkOiBhbnksIGV4cGVjdGVkOiBzdHJpbmcgfCBSZWdFeHApIHtcbiAgICBjb25zdCByZWNlaXZlZFN0cmluZyA9IFN0cmluZyhyZWNlaXZlZCk7XG4gICAgY29uc3QgcmVnZXggPSBleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCA/IGV4cGVjdGVkIDogbmV3IFJlZ0V4cChleHBlY3RlZCk7XG4gICAgY29uc3QgcGFzcyA9IHJlZ2V4LnRlc3QocmVjZWl2ZWRTdHJpbmcpO1xuICAgIFxuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHN0cmluZyBub3QgdG8gbWF0Y2ggcGF0dGVybjpcXG4gIFBhdHRlcm46ICR7Zm9ybWF0VmFsdWUoZXhwZWN0ZWQpfVxcbiAgUmVjZWl2ZWQ6ICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWRTdHJpbmcpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHN0cmluZyB0byBtYXRjaCBwYXR0ZXJuOlxcbiAgUGF0dGVybjogJHtmb3JtYXRWYWx1ZShleHBlY3RlZCl9XFxuICBSZWNlaXZlZDogJHtmb3JtYXRWYWx1ZShyZWNlaXZlZFN0cmluZyl9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHBhc3MsIG1lc3NhZ2UgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9Db250YWluIC0gQXJyYXkvU3RyaW5nIGNvbnRhaW5tZW50IGNoZWNrXG4gICAqL1xuICB0b0NvbnRhaW4ocmVjZWl2ZWQ6IGFueSwgZXhwZWN0ZWQ6IGFueSkge1xuICAgIGxldCBwYXNzID0gZmFsc2U7XG4gICAgXG4gICAgaWYgKHR5cGVvZiByZWNlaXZlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhc3MgPSByZWNlaXZlZC5pbmNsdWRlcyhTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVjZWl2ZWQpKSB7XG4gICAgICBwYXNzID0gcmVjZWl2ZWQuaW5jbHVkZXMoZXhwZWN0ZWQpO1xuICAgIH0gZWxzZSBpZiAocmVjZWl2ZWQgJiYgdHlwZW9mIHJlY2VpdmVkW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEhhbmRsZSBvdGhlciBpdGVyYWJsZXNcbiAgICAgIHBhc3MgPSBBcnJheS5mcm9tKHJlY2VpdmVkKS5pbmNsdWRlcyhleHBlY3RlZCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfSBub3QgdG8gY29udGFpbiAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX0gdG8gY29udGFpbiAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkKX1gO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcGFzcywgbWVzc2FnZSB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiB0b0hhdmVMZW5ndGggLSBMZW5ndGggcHJvcGVydHkgY2hlY2tcbiAgICovXG4gIHRvSGF2ZUxlbmd0aChyZWNlaXZlZDogYW55LCBleHBlY3RlZDogbnVtYmVyKSB7XG4gICAgY29uc3QgaGFzTGVuZ3RoID0gcmVjZWl2ZWQgJiYgdHlwZW9mIHJlY2VpdmVkLmxlbmd0aCA9PT0gJ251bWJlcic7XG4gICAgY29uc3QgcGFzcyA9IGhhc0xlbmd0aCAmJiByZWNlaXZlZC5sZW5ndGggPT09IGV4cGVjdGVkO1xuICAgIFxuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoIWhhc0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHZhbHVlIHRvIGhhdmUgYSBsZW5ndGggcHJvcGVydHksIHJlY2VpdmVkOiAke2Zvcm1hdFZhbHVlKHJlY2VpdmVkKX1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBsZW5ndGggbm90IHRvIGJlICR7ZXhwZWN0ZWR9LCByZWNlaXZlZDogJHtyZWNlaXZlZC5sZW5ndGh9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgbGVuZ3RoIHRvIGJlICR7ZXhwZWN0ZWR9LCByZWNlaXZlZDogJHtyZWNlaXZlZC5sZW5ndGh9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IHBhc3MsIG1lc3NhZ2UgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9IYXZlUHJvcGVydHkgLSBPYmplY3QgcHJvcGVydHkgZXhpc3RlbmNlIGFuZCBvcHRpb25hbGx5IHZhbHVlIGNoZWNrXG4gICAqL1xuICB0b0hhdmVQcm9wZXJ0eShyZWNlaXZlZDogYW55LCBrZXlQYXRoOiBzdHJpbmcsIGV4cGVjdGVkVmFsdWU/OiBhbnkpIHtcbiAgICBjb25zdCBoYXNQcm9wZXJ0eSA9IHJlY2VpdmVkICYmIHR5cGVvZiByZWNlaXZlZCA9PT0gJ29iamVjdCcgJiYga2V5UGF0aCBpbiByZWNlaXZlZDtcbiAgICBsZXQgcGFzcyA9IGhhc1Byb3BlcnR5O1xuICAgIFxuICAgIGlmIChwYXNzICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHBhc3MgPSBkZWVwRXF1YWwocmVjZWl2ZWRba2V5UGF0aF0sIGV4cGVjdGVkVmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNQcm9wZXJ0eSkge1xuICAgICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICAgIHJldHVybiBgRXhwZWN0ZWQgb2JqZWN0IG5vdCB0byBoYXZlIHByb3BlcnR5IFwiJHtrZXlQYXRofVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYEV4cGVjdGVkIG9iamVjdCB0byBoYXZlIHByb3BlcnR5IFwiJHtrZXlQYXRofVwiXFxuUmVjZWl2ZWQ6ICR7Zm9ybWF0VmFsdWUocmVjZWl2ZWQpfWA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICAgIHJldHVybiBgRXhwZWN0ZWQgcHJvcGVydHkgXCIke2tleVBhdGh9XCIgbm90IHRvIGhhdmUgdmFsdWU6XFxuICAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkVmFsdWUpfVxcblJlY2VpdmVkOlxcbiAgJHtmb3JtYXRWYWx1ZShyZWNlaXZlZFtrZXlQYXRoXSl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYEV4cGVjdGVkIHByb3BlcnR5IFwiJHtrZXlQYXRofVwiIHRvIGhhdmUgdmFsdWU6XFxuICAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkVmFsdWUpfVxcblJlY2VpdmVkOlxcbiAgJHtmb3JtYXRWYWx1ZShyZWNlaXZlZFtrZXlQYXRoXSl9YDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBvYmplY3Qgbm90IHRvIGhhdmUgcHJvcGVydHkgXCIke2tleVBhdGh9XCJgO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcGFzcywgbWVzc2FnZSB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiB0b01hdGNoU25hcHNob3QgLSBTbmFwc2hvdCB0ZXN0aW5nXG4gICAqL1xuICB0b01hdGNoU25hcHNob3QocmVjZWl2ZWQ6IGFueSwgc25hcHNob3ROYW1lPzogc3RyaW5nKSB7XG4gICAgLy8gTm90ZTogVGhpcyBpcyBhc3luYyBidXQgdGhlIGN1cnJlbnQgbWF0Y2hlciBBUEkgaXMgc3luY1xuICAgIC8vIFdlJ2xsIG5lZWQgdG8gaGFuZGxlIHRoaXMgYXQgdGhlIHRlc3QgcnVubmVyIGxldmVsXG4gICAgY29uc3QgdGVzdE5hbWUgPSB0aGlzLmN1cnJlbnRUZXN0TmFtZSB8fCAnVW5rbm93biBUZXN0JztcbiAgICBcbiAgICAvLyBTdG9yZSBzbmFwc2hvdCBkYXRhIGZvciBhc3luYyBwcm9jZXNzaW5nXG4gICAgKHRoaXMgYXMgYW55KS5fX3NuYXBzaG90RGF0YSA9IHtcbiAgICAgIHRlc3ROYW1lLFxuICAgICAgdmFsdWU6IHJlY2VpdmVkLFxuICAgICAgc25hcHNob3ROYW1lXG4gICAgfTtcbiAgICBcbiAgICAvLyBSZXR1cm4gYSBwbGFjZWhvbGRlciAtIGFjdHVhbCBtYXRjaGluZyBoYXBwZW5zIGluIHRlc3QgcnVubmVyXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiAoKSA9PiAnU25hcHNob3QgbWF0Y2hpbmcgZGVmZXJyZWQgdG8gdGVzdCBydW5uZXInXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogdG9UaHJvdyAtIEZ1bmN0aW9uIGV4ZWN1dGlvbiBlcnJvciBjaGVja1xuICAgKi9cbiAgdG9UaHJvdyhyZWNlaXZlZDogYW55LCBleHBlY3RlZEVycm9yPzogc3RyaW5nIHwgUmVnRXhwIHwgRXJyb3IgfCBGdW5jdGlvbikge1xuICAgIGlmICh0eXBlb2YgcmVjZWl2ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9UaHJvdyBtYXRjaGVyIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgXG4gICAgbGV0IHRocm93bkVycm9yOiBhbnk7XG4gICAgbGV0IGRpZFRocm93ID0gZmFsc2U7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJlY2VpdmVkKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRpZFRocm93ID0gdHJ1ZTtcbiAgICAgIHRocm93bkVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIFxuICAgIGxldCBwYXNzID0gZGlkVGhyb3c7XG4gICAgXG4gICAgLy8gSWYgc3BlY2lmaWMgZXJyb3IgZXhwZWN0YXRpb24gaXMgcHJvdmlkZWQsIGNoZWNrIGl0XG4gICAgaWYgKHBhc3MgJiYgZXhwZWN0ZWRFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGV4cGVjdGVkRXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhc3MgPSB0aHJvd25FcnJvciAmJiB0aHJvd25FcnJvci5tZXNzYWdlLmluY2x1ZGVzKGV4cGVjdGVkRXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChleHBlY3RlZEVycm9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHBhc3MgPSB0aHJvd25FcnJvciAmJiBleHBlY3RlZEVycm9yLnRlc3QodGhyb3duRXJyb3IubWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBlY3RlZEVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBhc3MgPSB0aHJvd25FcnJvciBpbnN0YW5jZW9mIGV4cGVjdGVkRXJyb3I7XG4gICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBwYXNzID0gdGhyb3duRXJyb3IgJiYgdGhyb3duRXJyb3IubWVzc2FnZSA9PT0gZXhwZWN0ZWRFcnJvci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBtZXNzYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gYEV4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkRXJyb3IpfSwgYnV0IGl0IHRocmV3OiAke3Rocm93bkVycm9yPy5tZXNzYWdlIHx8IHRocm93bkVycm9yfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3csIGJ1dCBpdCB0aHJldzogJHt0aHJvd25FcnJvcj8ubWVzc2FnZSB8fCB0aHJvd25FcnJvcn1gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWRpZFRocm93KSB7XG4gICAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyR7ZXhwZWN0ZWRFcnJvciA/IGAgJHtmb3JtYXRWYWx1ZShleHBlY3RlZEVycm9yKX1gIDogJyd9LCBidXQgaXQgZGlkbid0IHRocm93YDtcbiAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyAke2Zvcm1hdFZhbHVlKGV4cGVjdGVkRXJyb3IpfSwgYnV0IGl0IHRocmV3OiAke3Rocm93bkVycm9yPy5tZXNzYWdlIHx8IHRocm93bkVycm9yfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdywgYnV0IGl0IGRpZG5cXCd0IHRocm93JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHsgcGFzcywgbWVzc2FnZSB9O1xuICB9XG59KTtcblxuLy8gRXhwb3J0IGZvciBwb3RlbnRpYWwgZGlyZWN0IHVzYWdlXG5leHBvcnQge307ICAvLyBUaGlzIG1ha2VzIGl0IGEgbW9kdWxlIl0sInZlcnNpb24iOjN9