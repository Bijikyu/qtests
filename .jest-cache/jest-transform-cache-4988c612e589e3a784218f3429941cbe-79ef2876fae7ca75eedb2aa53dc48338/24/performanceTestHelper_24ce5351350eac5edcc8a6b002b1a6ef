ac4aad573f5b3faeb35c68af9c5a29e0
/**
 * Performance Testing Helper for Load and Timing Tests
 * 
 * This class focuses solely on performance measurement and testing concerns.
 * It provides standardized performance measurement across test suites.
 */

const {
  logStart,
  logReturn
} = require('../../lib/logUtils');

/**
 * Performance Testing Helper for Load and Timing Tests
 * 
 * This class provides standardized performance measurement across test suites
 * with timing assertions and concurrency testing capabilities.
 */
class PerformanceTestHelper {
  /**
   * Measures execution time of async operations with high precision
   * 
   * @param {Function} operation - Async operation to measure
   * @returns {Promise<Object>} Result object with operation result and timing
   */
  static async measureTime(operation) {
    logStart('PerformanceTestHelper.measureTime', operation.name || 'anonymous');
    try {
      const start = process.hrtime.bigint();
      const result = await operation();
      const end = process.hrtime.bigint();
      const durationNs = Number(end - start);
      const durationMs = durationNs / 1000000; // Convert nanoseconds to milliseconds

      const measurement = {
        result,
        duration: durationMs,
        durationNs,
        timestamp: new Date()
      };
      logReturn('PerformanceTestHelper.measureTime', `${durationMs.toFixed(2)}ms`);
      return measurement;
    } catch (error) {
      logReturn('PerformanceTestHelper.measureTime', `error: ${error.message}`);
      throw error;
    }
  }

  /**
   * Asserts operation completes within time limit
   * 
   * @param {Function} operation - Operation to test
   * @param {number} maxDuration - Maximum allowed duration in milliseconds
   * @returns {Promise<any>} Operation result if within time limit
   */
  static async assertTimingConstraint(operation, maxDuration) {
    logStart('PerformanceTestHelper.assertTimingConstraint', `${operation.name || 'anonymous'}, ${maxDuration}ms`);
    try {
      const {
        result,
        duration
      } = await this.measureTime(operation);
      if (duration > maxDuration) {
        throw new Error(`Operation took ${duration.toFixed(2)}ms, exceeding limit of ${maxDuration}ms`);
      }
      logReturn('PerformanceTestHelper.assertTimingConstraint', `passed in ${duration.toFixed(2)}ms`);
      return result;
    } catch (error) {
      logReturn('PerformanceTestHelper.assertTimingConstraint', `failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Tests concurrent operations for race conditions and performance
   * 
   * @param {Array<Function>} operations - Array of async operations to run concurrently
   * @returns {Promise<Object>} Results with timing and concurrency analysis
   */
  static async testConcurrency(operations) {
    logStart('PerformanceTestHelper.testConcurrency', `${operations.length} operations`);
    try {
      const start = process.hrtime.bigint();

      // Run all operations concurrently
      const promises = operations.map(async (operation, index) => {
        try {
          const opStart = process.hrtime.bigint();
          const result = await operation();
          const opEnd = process.hrtime.bigint();
          return {
            index,
            result,
            duration: Number(opEnd - opStart) / 1000000,
            success: true
          };
        } catch (error) {
          return {
            index,
            error: error.message,
            duration: 0,
            success: false
          };
        }
      });
      const results = await Promise.all(promises);
      const end = process.hrtime.bigint();
      const totalDuration = Number(end - start) / 1000000;
      const successful = results.filter(r => r.success).length;
      const failed = results.length - successful;
      const analysis = {
        totalDuration,
        successful,
        failed,
        results,
        averageDuration: results.reduce((sum, r) => sum + r.duration, 0) / results.length,
        maxDuration: Math.max(...results.map(r => r.duration)),
        minDuration: Math.min(...results.map(r => r.duration))
      };
      logReturn('PerformanceTestHelper.testConcurrency', `${successful}/${results.length} succeeded in ${totalDuration.toFixed(2)}ms`);
      return analysis;
    } catch (error) {
      logReturn('PerformanceTestHelper.testConcurrency', `error: ${error.message}`);
      throw error;
    }
  }

  // Instance method wrappers for compatibility with TestSuiteBuilder
  async measureTime(operation) {
    return PerformanceTestHelper.measureTime(operation);
  }
  async assertTimingConstraint(operation, maxDuration) {
    return PerformanceTestHelper.assertTimingConstraint(operation, maxDuration);
  }
  async testConcurrency(operations) {
    return PerformanceTestHelper.testConcurrency(operations);
  }
}
module.exports = {
  PerformanceTestHelper
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJsb2dTdGFydCIsImxvZ1JldHVybiIsInJlcXVpcmUiLCJQZXJmb3JtYW5jZVRlc3RIZWxwZXIiLCJtZWFzdXJlVGltZSIsIm9wZXJhdGlvbiIsIm5hbWUiLCJzdGFydCIsInByb2Nlc3MiLCJocnRpbWUiLCJiaWdpbnQiLCJyZXN1bHQiLCJlbmQiLCJkdXJhdGlvbk5zIiwiTnVtYmVyIiwiZHVyYXRpb25NcyIsIm1lYXN1cmVtZW50IiwiZHVyYXRpb24iLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9GaXhlZCIsImVycm9yIiwibWVzc2FnZSIsImFzc2VydFRpbWluZ0NvbnN0cmFpbnQiLCJtYXhEdXJhdGlvbiIsIkVycm9yIiwidGVzdENvbmN1cnJlbmN5Iiwib3BlcmF0aW9ucyIsImxlbmd0aCIsInByb21pc2VzIiwibWFwIiwiaW5kZXgiLCJvcFN0YXJ0Iiwib3BFbmQiLCJzdWNjZXNzIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJ0b3RhbER1cmF0aW9uIiwic3VjY2Vzc2Z1bCIsImZpbHRlciIsInIiLCJmYWlsZWQiLCJhbmFseXNpcyIsImF2ZXJhZ2VEdXJhdGlvbiIsInJlZHVjZSIsInN1bSIsIk1hdGgiLCJtYXgiLCJtaW5EdXJhdGlvbiIsIm1pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJwZXJmb3JtYW5jZVRlc3RIZWxwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBUZXN0aW5nIEhlbHBlciBmb3IgTG9hZCBhbmQgVGltaW5nIFRlc3RzXG4gKiBcbiAqIFRoaXMgY2xhc3MgZm9jdXNlcyBzb2xlbHkgb24gcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgYW5kIHRlc3RpbmcgY29uY2VybnMuXG4gKiBJdCBwcm92aWRlcyBzdGFuZGFyZGl6ZWQgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgYWNyb3NzIHRlc3Qgc3VpdGVzLlxuICovXG5cbmNvbnN0IHsgbG9nU3RhcnQsIGxvZ1JldHVybiB9ID0gcmVxdWlyZSgnLi4vLi4vbGliL2xvZ1V0aWxzJyk7XG5cbi8qKlxuICogUGVyZm9ybWFuY2UgVGVzdGluZyBIZWxwZXIgZm9yIExvYWQgYW5kIFRpbWluZyBUZXN0c1xuICogXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHN0YW5kYXJkaXplZCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBhY3Jvc3MgdGVzdCBzdWl0ZXNcbiAqIHdpdGggdGltaW5nIGFzc2VydGlvbnMgYW5kIGNvbmN1cnJlbmN5IHRlc3RpbmcgY2FwYWJpbGl0aWVzLlxuICovXG5jbGFzcyBQZXJmb3JtYW5jZVRlc3RIZWxwZXIge1xuICAvKipcbiAgICogTWVhc3VyZXMgZXhlY3V0aW9uIHRpbWUgb2YgYXN5bmMgb3BlcmF0aW9ucyB3aXRoIGhpZ2ggcHJlY2lzaW9uXG4gICAqIFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRpb24gLSBBc3luYyBvcGVyYXRpb24gdG8gbWVhc3VyZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2JqZWN0IHdpdGggb3BlcmF0aW9uIHJlc3VsdCBhbmQgdGltaW5nXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbWVhc3VyZVRpbWUob3BlcmF0aW9uKSB7XG4gICAgbG9nU3RhcnQoJ1BlcmZvcm1hbmNlVGVzdEhlbHBlci5tZWFzdXJlVGltZScsIG9wZXJhdGlvbi5uYW1lIHx8ICdhbm9ueW1vdXMnKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wZXJhdGlvbigpO1xuICAgICAgY29uc3QgZW5kID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGR1cmF0aW9uTnMgPSBOdW1iZXIoZW5kIC0gc3RhcnQpO1xuICAgICAgY29uc3QgZHVyYXRpb25NcyA9IGR1cmF0aW9uTnMgLyAxMDAwMDAwOyAvLyBDb252ZXJ0IG5hbm9zZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICAgICAgXG4gICAgICBjb25zdCBtZWFzdXJlbWVudCA9IHtcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb25NcyxcbiAgICAgICAgZHVyYXRpb25OcyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dSZXR1cm4oJ1BlcmZvcm1hbmNlVGVzdEhlbHBlci5tZWFzdXJlVGltZScsIGAke2R1cmF0aW9uTXMudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgcmV0dXJuIG1lYXN1cmVtZW50O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dSZXR1cm4oJ1BlcmZvcm1hbmNlVGVzdEhlbHBlci5tZWFzdXJlVGltZScsIGBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydHMgb3BlcmF0aW9uIGNvbXBsZXRlcyB3aXRoaW4gdGltZSBsaW1pdFxuICAgKiBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0aW9uIC0gT3BlcmF0aW9uIHRvIHRlc3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heER1cmF0aW9uIC0gTWF4aW11bSBhbGxvd2VkIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBPcGVyYXRpb24gcmVzdWx0IGlmIHdpdGhpbiB0aW1lIGxpbWl0XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgYXNzZXJ0VGltaW5nQ29uc3RyYWludChvcGVyYXRpb24sIG1heER1cmF0aW9uKSB7XG4gICAgbG9nU3RhcnQoJ1BlcmZvcm1hbmNlVGVzdEhlbHBlci5hc3NlcnRUaW1pbmdDb25zdHJhaW50JywgYCR7b3BlcmF0aW9uLm5hbWUgfHwgJ2Fub255bW91cyd9LCAke21heER1cmF0aW9ufW1zYCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCBkdXJhdGlvbiB9ID0gYXdhaXQgdGhpcy5tZWFzdXJlVGltZShvcGVyYXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZHVyYXRpb24gPiBtYXhEdXJhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE9wZXJhdGlvbiB0b29rICR7ZHVyYXRpb24udG9GaXhlZCgyKX1tcywgZXhjZWVkaW5nIGxpbWl0IG9mICR7bWF4RHVyYXRpb259bXNgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGxvZ1JldHVybignUGVyZm9ybWFuY2VUZXN0SGVscGVyLmFzc2VydFRpbWluZ0NvbnN0cmFpbnQnLCBgcGFzc2VkIGluICR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2ApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nUmV0dXJuKCdQZXJmb3JtYW5jZVRlc3RIZWxwZXIuYXNzZXJ0VGltaW5nQ29uc3RyYWludCcsIGBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyBjb25jdXJyZW50IG9wZXJhdGlvbnMgZm9yIHJhY2UgY29uZGl0aW9ucyBhbmQgcGVyZm9ybWFuY2VcbiAgICogXG4gICAqIEBwYXJhbSB7QXJyYXk8RnVuY3Rpb24+fSBvcGVyYXRpb25zIC0gQXJyYXkgb2YgYXN5bmMgb3BlcmF0aW9ucyB0byBydW4gY29uY3VycmVudGx5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJlc3VsdHMgd2l0aCB0aW1pbmcgYW5kIGNvbmN1cnJlbmN5IGFuYWx5c2lzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdGVzdENvbmN1cnJlbmN5KG9wZXJhdGlvbnMpIHtcbiAgICBsb2dTdGFydCgnUGVyZm9ybWFuY2VUZXN0SGVscGVyLnRlc3RDb25jdXJyZW5jeScsIGAke29wZXJhdGlvbnMubGVuZ3RofSBvcGVyYXRpb25zYCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG4gICAgICBcbiAgICAgIC8vIFJ1biBhbGwgb3BlcmF0aW9ucyBjb25jdXJyZW50bHlcbiAgICAgIGNvbnN0IHByb21pc2VzID0gb3BlcmF0aW9ucy5tYXAoYXN5bmMgKG9wZXJhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvcFN0YXJ0ID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgICAgICAgY29uc3Qgb3BFbmQgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBkdXJhdGlvbjogTnVtYmVyKG9wRW5kIC0gb3BTdGFydCkgLyAxMDAwMDAwLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBjb25zdCBlbmQgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IE51bWJlcihlbmQgLSBzdGFydCkgLyAxMDAwMDAwO1xuICAgICAgY29uc3Qgc3VjY2Vzc2Z1bCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKS5sZW5ndGg7XG4gICAgICBjb25zdCBmYWlsZWQgPSByZXN1bHRzLmxlbmd0aCAtIHN1Y2Nlc3NmdWw7XG4gICAgICBcbiAgICAgIGNvbnN0IGFuYWx5c2lzID0ge1xuICAgICAgICB0b3RhbER1cmF0aW9uLFxuICAgICAgICBzdWNjZXNzZnVsLFxuICAgICAgICBmYWlsZWQsXG4gICAgICAgIHJlc3VsdHMsXG4gICAgICAgIGF2ZXJhZ2VEdXJhdGlvbjogcmVzdWx0cy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5kdXJhdGlvbiwgMCkgLyByZXN1bHRzLmxlbmd0aCxcbiAgICAgICAgbWF4RHVyYXRpb246IE1hdGgubWF4KC4uLnJlc3VsdHMubWFwKHIgPT4gci5kdXJhdGlvbikpLFxuICAgICAgICBtaW5EdXJhdGlvbjogTWF0aC5taW4oLi4ucmVzdWx0cy5tYXAociA9PiByLmR1cmF0aW9uKSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ1JldHVybignUGVyZm9ybWFuY2VUZXN0SGVscGVyLnRlc3RDb25jdXJyZW5jeScsIGAke3N1Y2Nlc3NmdWx9LyR7cmVzdWx0cy5sZW5ndGh9IHN1Y2NlZWRlZCBpbiAke3RvdGFsRHVyYXRpb24udG9GaXhlZCgyKX1tc2ApO1xuICAgICAgcmV0dXJuIGFuYWx5c2lzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dSZXR1cm4oJ1BlcmZvcm1hbmNlVGVzdEhlbHBlci50ZXN0Q29uY3VycmVuY3knLCBgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluc3RhbmNlIG1ldGhvZCB3cmFwcGVycyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFRlc3RTdWl0ZUJ1aWxkZXJcbiAgYXN5bmMgbWVhc3VyZVRpbWUob3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIFBlcmZvcm1hbmNlVGVzdEhlbHBlci5tZWFzdXJlVGltZShvcGVyYXRpb24pO1xuICB9XG5cbiAgYXN5bmMgYXNzZXJ0VGltaW5nQ29uc3RyYWludChvcGVyYXRpb24sIG1heER1cmF0aW9uKSB7XG4gICAgcmV0dXJuIFBlcmZvcm1hbmNlVGVzdEhlbHBlci5hc3NlcnRUaW1pbmdDb25zdHJhaW50KG9wZXJhdGlvbiwgbWF4RHVyYXRpb24pO1xuICB9XG5cbiAgYXN5bmMgdGVzdENvbmN1cnJlbmN5KG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gUGVyZm9ybWFuY2VUZXN0SGVscGVyLnRlc3RDb25jdXJyZW5jeShvcGVyYXRpb25zKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUGVyZm9ybWFuY2VUZXN0SGVscGVyXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07RUFBRUEsUUFBUTtFQUFFQztBQUFVLENBQUMsR0FBR0MsT0FBTyxDQUFDLG9CQUFvQixDQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxxQkFBcUIsQ0FBQztFQUMxQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxhQUFhQyxXQUFXQSxDQUFDQyxTQUFTLEVBQUU7SUFDbENMLFFBQVEsQ0FBQyxtQ0FBbUMsRUFBRUssU0FBUyxDQUFDQyxJQUFJLElBQUksV0FBVyxDQUFDO0lBRTVFLElBQUk7TUFDRixNQUFNQyxLQUFLLEdBQUdDLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNLENBQUMsQ0FBQztNQUNyQyxNQUFNQyxNQUFNLEdBQUcsTUFBTU4sU0FBUyxDQUFDLENBQUM7TUFDaEMsTUFBTU8sR0FBRyxHQUFHSixPQUFPLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLENBQUM7TUFFbkMsTUFBTUcsVUFBVSxHQUFHQyxNQUFNLENBQUNGLEdBQUcsR0FBR0wsS0FBSyxDQUFDO01BQ3RDLE1BQU1R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