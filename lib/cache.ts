/** Cache Implementation using node-cache and ioredis */
import NodeCache from 'node-cache';
import IORedis,{Redis as RedisClient}from 'ioredis';
import{redisUrl,redisCloudUrl}from'../config/localVars.js';
import qerrors from'qerrors';
import{parse as secureParse}from'secure-json-parse';

export interface CacheOptions{maxSize?:number;defaultTTL?:number;enableDistributed?:boolean;keyPrefix?:string;compressionEnabled?:boolean;metricsEnabled?:boolean;checkperiod?:number;}
export interface CacheStats{local:{totalItems:number;hitRate:number;missRate:number;evictions:number;totalHits:number;totalMisses:number;memoryUsage:number;};distributed:{hitRate:number;missRate:number;errors:number;totalHits:number;totalMisses:number;avgResponseTime:number;connected:boolean;};}

export const createLocalCache=(options:CacheOptions={}):NodeCache=>new NodeCache({stdTTL:options.defaultTTL||600,checkperiod:options.checkperiod||120,useClones:false,deleteOnExpire:true,enableLegacyCallbacks:false,maxKeys:options.maxSize||1000});

export const createDistributedCache=async(options:CacheOptions={}):Promise<{redis:RedisClient|null;localCache:NodeCache;isConnected:boolean;}>=>{const localCache=createLocalCache({maxSize:100,defaultTTL:60,checkperiod:30});let redis:RedisClient|null=null,isConnected=false;if(!options.enableDistributed)return console.log('Distributed caching disabled, using local cache only'),{redis:null,localCache,isConnected:false};try{const redisUrlToUse=redisUrl||redisCloudUrl;if(!redisUrlToUse)return console.warn('Redis not configured for distributed caching, using local cache only'),{redis:null,localCache,isConnected:false};redis=new IORedis(redisUrlToUse,{maxRetriesPerRequest:3,lazyConnect:true,keepAlive:30000,connectTimeout:10000,commandTimeout:5000});redis.on('connect',()=>{isConnected=true;console.log('Distributed cache connected to Redis');});redis.on('error',(error:Error)=>{isConnected=false;qerrors(error,'DistributedCache: Redis error',{operation:'connection'});});redis.on('close',()=>{isConnected=false;console.log('Distributed cache disconnected from Redis');});await redis.connect();}catch(error){qerrors(error as Error,'DistributedCache: initialization failed',{redisUrl:redisUrl||redisCloudUrl});return{redis:null,localCache,isConnected:false};}return{redis,localCache,isConnected};};

export const getFromCache=async<T>(key:string,distributedCache:{redis:RedisClient|null;localCache:NodeCache;isConnected:boolean;},options:CacheOptions={}):Promise<T|null>=>{try{if(distributedCache.isConnected&&distributedCache.redis){const fullKey=(options.keyPrefix||'cache:')+key,value=await distributedCache.redis.get(fullKey);if(value!==null){const parsed=secureParse(value,undefined,{protoAction:'remove',constructorAction:'remove'})as T;distributedCache.localCache.set(key,parsed,60);return parsed;}}const localValue=distributedCache.localCache.get<T>(key);return localValue!==undefined?localValue:null;}catch(error){qerrors(error as Error,'getFromCache: operation failed',{key});return null;}};

export const setInCache=async<T>(key:string,value:T,ttl:number|undefined,distributedCache:{redis:RedisClient|null;localCache:NodeCache;isConnected:boolean;},options:CacheOptions={}):Promise<boolean>=>{try{const effectiveTTL=ttl||options.defaultTTL||600,serialized=JSON.stringify(value),fullKey=(options.keyPrefix||'cache:')+key;if(distributedCache.isConnected&&distributedCache.redis)await distributedCache.redis.setex(fullKey,effectiveTTL,serialized);distributedCache.localCache.set(key,value,Math.min(effectiveTTL,300));return true;}catch(error){qerrors(error as Error,'setInCache: operation failed',{key,ttl});return false;}};

export const deleteFromCache=async(key:string,distributedCache:{redis:RedisClient|null;localCache:NodeCache;isConnected:boolean;},options:CacheOptions={}):Promise<boolean>=>{try{const fullKey=(options.keyPrefix||'cache:')+key,deleted=distributedCache.isConnected&&distributedCache.redis?(await distributedCache.redis.del(fullKey))>0:false;const localDeleted=distributedCache.localCache.del(key)>0;return deleted||localDeleted;}catch(error){qerrors(error as Error,'deleteFromCache: operation failed',{key});return false;}};

export const clearCache=async(distributedCache:{redis:RedisClient|null;localCache:NodeCache;isConnected:boolean;},options:CacheOptions={}):Promise<void>=>{try{if(distributedCache.isConnected&&distributedCache.redis){const pattern=(options.keyPrefix||'cache:')+'*',keys=await distributedCache.redis.keys(pattern);keys.length>0&&await distributedCache.redis.del(...keys);}distributedCache.localCache.keys().forEach(key=>distributedCache.localCache.del(key));}catch(error){qerrors(error as Error,'clearCache: operation failed');}};

export const getCacheStats=(distributedCache:{redis:RedisClient|null;localCache:NodeCache;isConnected:boolean;},stats:{hits:number;misses:number;errors:number;responseTimes:number[];}):CacheStats=>{const keys=distributedCache.localCache.keys(),totalItems=keys.length,totalOperations=stats.hits+stats.misses,hitRate=totalOperations>0?(stats.hits/totalOperations)*100:0,missRate=totalOperations>0?(stats.misses/totalOperations)*100:0,avgResponseTime=stats.responseTimes.length>0?stats.responseTimes.reduce((a,b)=>a+b,0)/stats.responseTimes.length:0;return{local:{totalItems,hitRate,missRate,evictions:0,totalHits:stats.hits,totalMisses:stats.misses,memoryUsage:0},distributed:{hitRate,missRate,errors:stats.errors,totalHits:stats.hits,totalMisses:stats.misses,avgResponseTime,connected:distributedCache.isConnected}};};

export class CacheManager{private distributedCache!:{redis:RedisClient|null;localCache:NodeCache;isConnected:boolean;};private options:CacheOptions;private stats={hits:0,misses:0,errors:0,responseTimes:[]as number[]};constructor(options:CacheOptions={}){this.options={defaultTTL:600,enableDistributed:true,keyPrefix:'cache:',...options};this.initializeCache();}private async initializeCache():Promise<void>{this.distributedCache=await createDistributedCache(this.options);}async get<T>(key:string):Promise<T|null>{try{const result=await getFromCache<T>(key,this.distributedCache,this.options);result!==null?this.stats.hits++:this.stats.misses++;return result;}catch(error){this.stats.errors++;this.stats.misses++;return null;}}async set<T>(key:string,value:T,ttl?:number):Promise<boolean>{try{return await setInCache(key,value,ttl,this.distributedCache,this.options);}catch(error){this.stats.errors++;return false;}}async delete(key:string):Promise<boolean>{try{return await deleteFromCache(key,this.distributedCache,this.options);}catch(error){this.stats.errors++;return false;}}async clear():Promise<void>{try{await clearCache(this.distributedCache,this.options);}catch(error){this.stats.errors++;}}getStats():CacheStats{return getCacheStats(this.distributedCache,this.stats);}async shutdown():Promise<void>{this.distributedCache.redis&&await this.distributedCache.redis.quit();}}

export const LocalCache=NodeCache,DistributedCache=CacheManager;export default{createLocalCache,createDistributedCache,getFromCache,setInCache,deleteFromCache,clearCache,getCacheStats,CacheManager,LocalCache,DistributedCache};