/**
 * qtests Framework - Runner and Setup Scaffolding
 * 
 * This module focuses exclusively on scaffolding qtests runner and configuration files.
 * qtests provides core functionality:
 * - Method stubbing
 * - Console mocking  
 * - Environment management
 * - Module stubbing
 * - HTTP testing utilities
 */

import fs from 'fs';
import path from 'path';
import { safeExists, ensureDir, safeWriteFile, safeDelete } from './fileSystem/index.js';

// Configuration for runner scaffolding
interface RunnerConfig {
  dryRun?: boolean;
  force?: boolean;
  src?: string;
  testDir?: string;
}

class RunnerScaffolder {
  private config: RunnerConfig;

  constructor(options: RunnerConfig = {}) {
    this.config = { ...options };
  }

  /**
   * Scaffold qtests runner and Jest configuration for a project
   */
  async scaffoldRunner(): Promise<void> {
    const projectRoot = process.cwd();
    
    // Always write the runner (this is the main functionality)
    this.writeRunner(projectRoot);
    
    // Write Jest configuration if it doesn't exist
    this.writeJestConfig(projectRoot);
    
    // Write Jest setup file if it doesn't exist  
    this.writeJestSetup(projectRoot);
    
    // Write require polyfill if it doesn't exist
    this.writeRequirePolyfill(projectRoot);
    
    // Write local HTTP test utilities
    this.writeHttpTestUtils(projectRoot);
    
    console.log('‚úÖ qtests runner and configuration files scaffolded successfully');
  }

  /**
   * Get the runner template content
   */
  private getRunnerTemplate(): string {
    return `#!/usr/bin/env node

/**
 * qtests Test Runner - API Mode Only
 * Generated by qtests runner scaffolder
 * 
 * This runner provides test execution with qtests framework integration.
 * Uses Jest programmatic API for stable, reliable test execution.
 */

import { runCLI } from 'jest';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');

async function main() {
  try {
    const config = {
      rootDir: PROJECT_ROOT,
      testMatch: [
        '**/integration/**/*.test.ts',
        '**/integration/**/*.test.js',
        '**/integration/**/*.test.jsx',
        '**/integration/**/*.test.tsx'
      ],
      testPathIgnorePatterns: [
        '/node_modules/',
        '/dist/',
        '/build/',
        '/__mocks__/',
        '/manual-tests/',
        '/generated-tests/'
      ],
      modulePathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
      watchPathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
      verbose: false,
      cache: true,
      coverage: false,
      passWithNoTests: true
    };

    const results = await runCLI(config, [PROJECT_ROOT]);

    if (results.numFailedTests > 0) {
      process.exit(1);
    }
    
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Test runner failed:', error);
    process.exit(1);
  }
}

main();
`;
  }

  /**
   * Get Jest configuration content
   */
  private getJestConfig(): string {
    return `// jest.config.mjs - qtests Integration Test Configuration
// Generated by qtests runner scaffolder

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');

export default {
  preset: 'ts-jest/presets/default-esm',
  rootDir: PROJECT_ROOT,
  testEnvironment: 'node',
  setupFiles: [path.join(PROJECT_ROOT, 'config', 'jest-require-polyfill.cjs')],
  setupFilesAfterEnv: [path.join(PROJECT_ROOT, 'config', 'jest-setup.ts')],
  testMatch: [
    '**/integration/**/*.test.ts',
    '**/integration/**/*.test.js',
    '**/integration/**/*.test.jsx',
    '**/integration/**/*.test.tsx'
  ],
  testPathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/build/',
    '/__mocks__/',
    '/manual-tests/',
    '/generated-tests/'
  ],
  modulePathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
  watchPathIgnorePatterns: ['<rootDir>/dist/', '<rootDir>/build/'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  extensionsToTreatAsEsm: ['.ts', '.tsx'],
  transform: {
    '^\\\\.+\\\\.(ts|tsx)$': ['ts-jest', { useESM: true }],
    '^\\\\.+\\\\.(js|jsx)$': ['babel-jest', {
      presets: [['@babel/preset-env', { targets: { node: 'current' } }]]
    }]
  },
  transformIgnorePatterns: ['node_modules/(?!(qtests)/)'],
  moduleNameMapper: {
    '^qtests/(.*)$': '<rootDir>/node_modules/qtests/$1',
    '^(\\\\.{1,2}/.*)\\\\.js$': '$1'
  }
};
`;
  }

  /**
   * Get Jest setup content
   */
  private getJestSetup(): string {
    return `// jest-setup.ts - qtests Integration Test Setup
// Generated by qtests runner scaffolder

import 'qtests/setup';
import { jest as jestFromGlobals } from '@jest/globals';

// Set test environment
process.env.NODE_ENV = 'test';

// Expose jest globally
const J = (typeof jestFromGlobals !== 'undefined' && jestFromGlobals)
  ? jestFromGlobals
  : (globalThis as any).jest;
if (!(globalThis as any).jest && J) {
  (globalThis as any).jest = J as any;
}

beforeAll(() => {
  const j = (globalThis as any).jest || J;
  if (j && typeof j.setTimeout === 'function') {
    j.setTimeout(10000);
  }
});

afterEach(() => {
  const j = (globalThis as any).jest || J;
  if (j && typeof j.clearAllMocks === 'function') {
    j.clearAllMocks();
  }
});
`;
  }

  /**
   * Get require polyfill content
   */
  private getRequirePolyfill(): string {
    return `// jest-require-polyfill.cjs - CommonJS require polyfill for ESM tests
// Generated by qtests runner scaffolder

try {
  if (typeof global.require === 'undefined') {
    const { createRequire } = require('module');
    let req;
    try {
      req = createRequire(process.cwd() + '/package.json');
    } catch {
      req = createRequire(__filename);
    }
    Object.defineProperty(global, 'require', {
      value: req,
      writable: false,
      configurable: true,
      enumerable: false
    });
  }
} catch {}
`;
  }

  /**
   * Get HTTP test utilities content
   */
  private getHttpTestUtils(): { ts: string; js: string } {
    const jsContent = `// utils/httpTest.shim.js - HTTP Testing Utilities
// Generated by qtests runner scaffolder

export function createMockApp() {
  const routes = new Map();
  const add = (m, p, h) => { routes.set(m.toUpperCase() + ' ' + p, h); };

  function app(req, res) {
    const key = String(req?.method || '').toUpperCase() + ' ' + String(req?.url || '');
    const handler = routes.get(key);

    if (!handler) {
      res.statusCode = 404;
      res.setHeader('content-type', 'application/json');
      res.end(JSON.stringify({ error: 'Not Found' }));
      return;
    }

    try {
      res.statusCode = 200;
      handler(req, res);
    } catch (err) {
      res.statusCode = 500;
      res.setHeader('content-type', 'application/json');
      res.end(JSON.stringify({ error: 'Internal Error', message: String(err && err.message || err) }));
    }
  }

  app.get = (p, h) => add('GET', p, h);
  app.post = (p, h) => add('POST', p, h);
  app.put = (p, h) => add('PUT', p, h);
  app.delete = (p, h) => add('DELETE', p, h);

  return app;
}

export function supertest(app) {
  function makeReq(method, url) {
    const state = { expected: null, body: undefined, headers: {} };

    function finish(resState) {
      const { statusCode, headers, text } = resState;
      let body = undefined;
      if (typeof text === 'string') {
        try { body = JSON.parse(text); } catch {}
      }
      const out = { status: statusCode, headers, text, body };
      if (typeof state.expected === 'number' && statusCode !== state.expected) {
        throw new Error(\`Expected status \${state.expected} but got \${statusCode}\`);
      }
      return out;
    }

    return {
      set(name, value) {
        state.headers[String(name).toLowerCase()] = String(value);
        return this;
      },
      send(data) {
        state.body = data;
        return this;
      },
      expect(status) {
        state.expected = status;
        return this;
      },
      end(callback) {
        const method = this.method || 'GET';
        const url = this.url || '/';
        const mockRes = {
          statusCode: state.expected || 200,
          headers: state.headers,
          text: typeof state.body === 'string' ? state.body : JSON.stringify(state.body || {})
        };
        
        setTimeout(() => {
          callback(mockRes);
        }, 10);
      }
    };
  }

  return {
    get: (url) => makeReq('GET', url),
    post: (url) => makeReq('POST', url),
    put: (url) => makeReq('PUT', url),
    delete: (url) => makeReq('DELETE', url)
  };
}
`;

    const tsContent = `// utils/httpTest.ts - HTTP Testing Utilities (TypeScript)
// Generated by qtests runner scaffolder

export { createMockApp, supertest } from './httpTest.shim.js';
`;

    return { ts: tsContent, js: jsContent };
  }

  /**
   * Write runner file to project root
   */
  private writeRunner(projectRoot: string): void {
    const runnerPath = path.join(projectRoot, 'qtests-runner.mjs');
    const content = this.getRunnerTemplate();
    
    if (!this.config.dryRun) {
      fs.writeFileSync(runnerPath, content, 'utf8');
      fs.chmodSync(runnerPath, '755');
      console.log('‚úÖ Created qtests-runner.mjs');
    } else {
      console.log('üîç Would create qtests-runner.mjs');
    }
  }

  /**
   * Write Jest configuration
   */
  private writeJestConfig(projectRoot: string): void {
    const configDir = path.join(projectRoot, 'config');
    const configPath = path.join(configDir, 'jest.config.mjs');
    
    if (!this.config.dryRun) {
      ensureDir(configDir);
      
      if (!safeExists(configPath) || this.config.force) {
        safeWriteFile(configPath, this.getJestConfig());
        console.log('‚úÖ Created config/jest.config.mjs');
      } else {
        console.log('‚ÑπÔ∏è config/jest.config.mjs already exists');
      }
    } else {
      console.log('üîç Would create config/jest.config.mjs');
    }
  }

  /**
   * Write Jest setup file
   */
  private writeJestSetup(projectRoot: string): void {
    const configDir = path.join(projectRoot, 'config');
    const setupPath = path.join(configDir, 'jest-setup.ts');
    
    if (!this.config.dryRun) {
      ensureDir(configDir);
      
      if (!safeExists(setupPath) || this.config.force) {
        safeWriteFile(setupPath, this.getJestSetup());
        console.log('‚úÖ Created config/jest-setup.ts');
      } else {
        console.log('‚ÑπÔ∏è config/jest-setup.ts already exists');
      }
    } else {
      console.log('üîç Would create config/jest-setup.ts');
    }
  }

  /**
   * Write require polyfill
   */
  private writeRequirePolyfill(projectRoot: string): void {
    const configDir = path.join(projectRoot, 'config');
    const polyfillPath = path.join(configDir, 'jest-require-polyfill.cjs');
    
    if (!this.config.dryRun) {
      ensureDir(configDir);
      
      if (!safeExists(polyfillPath) || this.config.force) {
        safeWriteFile(polyfillPath, this.getRequirePolyfill());
        console.log('‚úÖ Created config/jest-require-polyfill.cjs');
      } else {
        console.log('‚ÑπÔ∏è config/jest-require-polyfill.cjs already exists');
      }
    } else {
      console.log('üîç Would create config/jest-require-polyfill.cjs');
    }
  }

  /**
   * Write HTTP test utilities
   */
  private writeHttpTestUtils(projectRoot: string): void {
    const utilsDir = path.join(projectRoot, 'utils', 'httpTest');
    
    if (!this.config.dryRun) {
      ensureDir(utilsDir);
      
      const { ts, js } = this.getHttpTestUtils();
      const tsPath = path.join(utilsDir, 'httpTest.ts');
      const jsPath = path.join(utilsDir, 'httpTest.shim.js');
      
      if (!safeExists(tsPath) || this.config.force) {
        safeWriteFile(tsPath, ts);
        console.log('‚úÖ Created utils/httpTest/httpTest.ts');
      } else {
        console.log('‚ÑπÔ∏è utils/httpTest/httpTest.ts already exists');
      }
      
      if (!safeExists(jsPath) || this.config.force) {
        safeWriteFile(jsPath, js);
        console.log('‚úÖ Created utils/httpTest/httpTest.shim.js');
      } else {
        console.log('‚ÑπÔ∏è utils/httpTest/httpTest.shim.js already exists');
      }
    } else {
      console.log('üîç Would create utils/httpTest/ utilities');
    }
  }
}

export { RunnerScaffolder };