// qtests Test Runner - Auto-generated by qtests
// This file discovers and runs all tests in your project
// Generated as: qtests-runner.js

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');
const os = require('os');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

/**
 * Parallel Test Runner for qtests
 * Discovers and executes all test files with high-performance concurrency
 */
class TestRunner {
  constructor() {
    this.testFiles = [];
    this.passedTests = 0;
    this.failedTests = 0;
    this.totalTests = 0;
    this.startTime = Date.now();
    this.results = [];
  }

  /**
   * Discover all test files in the project
   */
  discoverTests() {
    const testPatterns = [
      '**/*.test.js',
      '**/*.test.ts', 
      '**/*.test.jsx',
      '**/*.test.tsx',
      '**/test/**/*.js',
      '**/test/**/*.ts',
      '**/tests/**/*.js',
      '**/tests/**/*.ts',
      '**/__tests__/**/*.js',
      '**/__tests__/**/*.ts'
    ];

    const excludePatterns = [
      'node_modules',
      '.git',
      'coverage',
      'dist',
      'build',
      '.cache',
      '.jest-cache',
      'demo',        // Exclude demo directory to match Jest config
      'examples',    // Exclude examples directory to match Jest config
      'docs',        // Exclude docs directory to match Jest config
      'stubs'        // Exclude stubs directory to match Jest config
    ];

    const testFiles = new Set();

    const walkDir = (dir) => {
      if (!fs.existsSync(dir)) return;
      
      try {
        const items = fs.readdirSync(dir, { withFileTypes: true });
        
        for (const item of items) {
          if (item.name.startsWith('.')) continue;
          if (excludePatterns.includes(item.name)) continue;
          
          const fullPath = path.join(dir, item.name);
          const relativePath = path.relative('.', fullPath);
          
          // Skip paths that match exclude patterns (including subdirectories)
          if (excludePatterns.some(pattern => relativePath.includes(pattern))) continue;
          
          if (item.isDirectory()) {
            walkDir(fullPath);
          } else if (item.isFile()) {
            // Check if file matches test patterns
            if (this.isTestFile(relativePath)) {
              testFiles.add(relativePath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };

    walkDir('.');
    this.testFiles = Array.from(testFiles).sort();
    return this.testFiles;
  }

  /**
   * Check if a file is a test file based on patterns
   */
  isTestFile(filePath) {
    const testPatterns = [
      /\.test\.[jt]sx?$/,
      /\.spec\.[jt]sx?$/,
      /test\/.*\.[jt]sx?$/,
      /tests\/.*\.[jt]sx?$/,
      /__tests__\/.*\.[jt]sx?$/
    ];

    return testPatterns.some(pattern => pattern.test(filePath));
  }

  /**
   * Run a single test file
   */
  async runTestFile(testFile) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      let stdout = '';
      let stderr = '';

      // Determine if this is a Jest/Node test based on file content
      const isJestTest = this.shouldUseJest(testFile);
      
      const command = isJestTest ? 'npx' : 'node';
      const args = isJestTest ? ['jest', '--testPathPattern', testFile, '--verbose'] : [testFile];

      const child = spawn(command, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
        env: { ...process.env, NODE_ENV: 'test' }
      });

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (code) => {
        const duration = Date.now() - startTime;
        const success = code === 0;
        
        if (success) {
          this.passedTests++;
        } else {
          this.failedTests++;
        }

        resolve({
          file: testFile,
          success,
          duration,
          output: stdout,
          error: stderr,
          code
        });
      });

      child.on('error', (error) => {
        this.failedTests++;
        resolve({
          file: testFile,
          success: false,
          duration: Date.now() - startTime,
          output: '',
          error: error.message,
          code: 1
        });
      });
    });
  }

  /**
   * Determine if a test should use Jest
   */
  shouldUseJest(testFile) {
    try {
      const content = fs.readFileSync(testFile, 'utf8');
      // Look for Jest-specific patterns
      return /\b(describe|it|test|expect|jest|beforeEach|afterEach|beforeAll|afterAll)\b/.test(content);
    } catch {
      return false;
    }
  }

  /**
   * Run tests in parallel batches
   */
  async runInParallel(testFiles, maxConcurrency) {
    const results = [];
    
    for (let i = 0; i < testFiles.length; i += maxConcurrency) {
      const batch = testFiles.slice(i, i + maxConcurrency);
      const batchPromises = batch.map(file => this.runTestFile(file));
      
      try {
        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);
        
        // Show progress
        const completed = Math.min(i + maxConcurrency, testFiles.length);
        process.stdout.write(`\r${colors.dim}Progress: ${completed}/${testFiles.length} files completed${colors.reset}`);
      } catch (error) {
        console.error(`${colors.red}Batch error:${colors.reset}`, error);
      }
    }
    
    console.log(); // New line after progress
    return results;
  }

  /**
   * Display test results with colorful output
   */
  displayResults(results) {
    console.log(`\n${colors.bright}📊 Test Results Summary${colors.reset}`);
    console.log(`${colors.dim}${'='.repeat(50)}${colors.reset}`);

    const totalDuration = Date.now() - this.startTime;

    // Summary stats
    console.log(`${colors.green}✅ Passed: ${this.passedTests}${colors.reset}`);
    console.log(`${colors.red}❌ Failed: ${this.failedTests}${colors.reset}`);
    console.log(`${colors.blue}📁 Total Files: ${results.length}${colors.reset}`);
    console.log(`${colors.cyan}⏱️  Duration: ${totalDuration}ms${colors.reset}\n`);

    // Show failed tests with details
    const failedResults = results.filter(r => !r.success);
    if (failedResults.length > 0) {
      console.log(`${colors.red}${colors.bright}Failed Tests:${colors.reset}`);
      failedResults.forEach(result => {
        console.log(`\n${colors.red}❌ ${result.file}${colors.reset}`);
        if (result.error) {
          console.log(`${colors.dim}${result.error.split('\n').slice(0, 5).join('\n')}${colors.reset}`);
        }
      });

      // Generate debug file for failed tests
      this.generateDebugFile(failedResults);
    }

    // Performance summary
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    console.log(`\n${colors.dim}Average test duration: ${Math.round(avgDuration)}ms${colors.reset}`);
  }

  /**
   * Generate DEBUG_TESTS.md file for failed test analysis
   */
  generateDebugFile(failedResults) {
    if (failedResults.length === 0) return;
    
    let debugContent = '# Test Failure Analysis\n\n';
    debugContent += 'Analyze and address the following test failures:\n\n';
    
    failedResults.forEach((result, index) => {
      debugContent += `## Failed Test ${index + 1}: ${result.file}\n\n`;
      debugContent += '### Output:\n';
      debugContent += '```\n';
      debugContent += result.error || result.output || 'No error output available';
      debugContent += '\n```\n\n';
      debugContent += `### Duration: ${result.duration}ms\n\n`;
      debugContent += '---\n\n';
    });
    
    debugContent += '## Summary\n\n';
    debugContent += `- Total failed tests: ${failedResults.length}\n`;
    debugContent += `- Failed test files: ${failedResults.map(r => r.file).join(', ')}\n`;
    debugContent += `- Generated: ${new Date().toISOString()}\n`;
    
    try {
      fs.writeFileSync('DEBUG_TESTS.md', debugContent);
      console.log(`\n${colors.yellow}📋 Debug file created: DEBUG_TESTS.md${colors.reset}`);
    } catch (error) {
      console.log(`${colors.red}⚠️  Could not create DEBUG_TESTS.md: ${error.message}${colors.reset}`);
    }
  }

  /**
   * Main execution method
   */
  async run() {
    console.log(`${colors.bright}🧪 qtests Test Runner - Parallel Mode${colors.reset}`);
    console.log(`${colors.dim}Discovering and running all tests...${colors.reset}\n`);

    // Discover all test files
    const testFiles = this.discoverTests();
    
    if (testFiles.length === 0) {
      console.log(`${colors.yellow}⚠️  No test files found${colors.reset}`);
      console.log(`${colors.dim}Looking for files matching: *.test.js, *.spec.js, test/*, tests/*, __tests__/*${colors.reset}`);
      return;
    }

    console.log(`${colors.blue}Found ${testFiles.length} test file(s):${colors.reset}`);
    testFiles.forEach(file => console.log(`  ${colors.dim}•${colors.reset} ${file}`));
    console.log(`\n${colors.magenta}🚀 Running tests in parallel...${colors.reset}\n`);
    
    // Run tests in parallel with aggressive concurrency for speed
    const cpuCount = os.cpus().length;
    const maxConcurrency = Math.min(testFiles.length, Math.max(4, cpuCount * 2)); // Use 2x CPU cores for I/O-bound tests
    console.log(`${colors.dim}Max concurrency: ${maxConcurrency} workers (${cpuCount} CPU cores)${colors.reset}\n`);
    
    const results = await this.runInParallel(testFiles, maxConcurrency);
    this.results = results;
    
    // Display comprehensive results
    this.displayResults(results);
    
    // Exit with appropriate code
    process.exit(this.failedTests > 0 ? 1 : 0);
  }
}

// Run the test suite
if (require.main === module) {
  const runner = new TestRunner();
  runner.run().catch(error => {
    console.error(`${colors.red}Test runner error:${colors.reset}`, error);
    process.exit(1);
  });
}

module.exports = TestRunner;
