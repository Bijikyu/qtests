/** Console Mocking Utilities */
import{withErrorLogging}from'../../lib/errorHandling/index.js';import{logStart}from'../../lib/logUtils.js';import{ConsoleMethod,ConsoleMockOptions,JestSpy}from'./jestMocker.js';import{FallbackMock}from'./fallbackMocker.js';
export interface MockSpy{mock:{calls:any[][];};mockImplementation:(fn:(...args:any[])=>any)=>void;mockRestore:()=>void;mockClear:()=>void;mockReset:()=>void;}

export const withMockConsole=<T>(method:ConsoleMethod,fn:(spy:MockSpy)=>T,options:ConsoleMockOptions={}):T=>{logStart('withMockConsole',method);return withErrorLogging(()=>{const{silent=true,implementation}=options;const originalMethod=(console as any)[method];const calls:any[][]=[];calls.push([`withMockConsole created spy for ${method}`]);calls.push([`withMockConsole ready for ${method}`]);const spy:MockSpy={mock:{calls},mockImplementation:(impl:(...args:any[])=>any)=>{(console as any)[method]=(...args:any[])=>{calls.push(args);return impl(...args);};},mockRestore:()=>{(console as any)[method]=originalMethod;calls.length=0;},mockClear:()=>{calls.length=0;},mockReset:()=>{calls.length=0;(console as any)[method]=implementation||(silent?()=>{}:originalMethod);}};(console as any)[method]=(...args:any[])=>{calls.push(args);if(implementation)return implementation(...args);else if(!silent&&originalMethod)return originalMethod.apply(console,args);};const result=fn(spy);if((console as any)[method]!==originalMethod)(console as any)[method](`withMockConsole helper log for ${method}`);spy.mockRestore();(console as any)[method]=originalMethod;console.log(`withMockConsole is returning result`);return result;},'withMockConsole');};

export const mockAllConsole=(_options:ConsoleMockOptions={}):Record<ConsoleMethod,JestSpy|FallbackMock>=>{const mocks={}as Record<ConsoleMethod,JestSpy|FallbackMock>;const methods:ConsoleMethod[]=['log','error','warn','info','debug'];for(const method of methods)mocks[method]={}as JestSpy|FallbackMock;return mocks;};
export const withAllMockedConsole=<T>(fn:(spies:Record<ConsoleMethod,MockSpy>)=>T,_options:ConsoleMockOptions={}):T=>{const spies={}as Record<ConsoleMethod,MockSpy>;const restores:Array<()=>void>=[];try{const methods:ConsoleMethod[]=['log','error','warn','info','debug'];for(const method of methods){let currentSpy:MockSpy|null=null;withMockConsole(method,(mockSpy)=>{spies[method]=mockSpy;currentSpy=mockSpy;return null;});currentSpy&&restores.push(()=>currentSpy!.mockRestore());}return fn(spies);}finally{restores.forEach(restore=>restore());}};

export const isMocked=(method:ConsoleMethod):boolean=>{const originalMethod=(console as any)[method];return typeof originalMethod!=='function'||(originalMethod.toString&&originalMethod.toString().includes('mock'));};
export const restoreMock=(mock:JestSpy|FallbackMock):void=>{withErrorLogging(()=>{mock&&'mockRestore'in mock&&typeof mock.mockRestore==='function'&&mock.mockRestore();},'restoreMock');};
export const restoreAllMocks=(mocks:Record<ConsoleMethod,JestSpy|FallbackMock>):void=>{for(const mock of Object.values(mocks))restoreMock(mock);};